/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-telegram-bot-api";
exports.ids = ["vendor-chunks/node-telegram-bot-api"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-telegram-bot-api/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * If running on Nodejs 5.x and below, we load the transpiled code.\n * Otherwise, we use the ES6 code.\n * We are deprecating support for Node.js v5.x and below.\n */\nconst majorVersion = parseInt(process.versions.node.split('.')[0], 10);\nif (majorVersion <= 5) {\n  const deprecate = (__webpack_require__(/*! ./src/utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\n  deprecate('Node.js v5.x and below will no longer be supported in the future');\n  module.exports = __webpack_require__(/*! ./lib/telegram */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./src/telegram */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZHQUFnQztBQUNwRDtBQUNBLEVBQUUsd0hBQTBDO0FBQzVDLEVBQUU7QUFDRixFQUFFLHdIQUEwQztBQUM1QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJZiBydW5uaW5nIG9uIE5vZGVqcyA1LnggYW5kIGJlbG93LCB3ZSBsb2FkIHRoZSB0cmFuc3BpbGVkIGNvZGUuXG4gKiBPdGhlcndpc2UsIHdlIHVzZSB0aGUgRVM2IGNvZGUuXG4gKiBXZSBhcmUgZGVwcmVjYXRpbmcgc3VwcG9ydCBmb3IgTm9kZS5qcyB2NS54IGFuZCBiZWxvdy5cbiAqL1xuY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJylbMF0sIDEwKTtcbmlmIChtYWpvclZlcnNpb24gPD0gNSkge1xuICBjb25zdCBkZXByZWNhdGUgPSByZXF1aXJlKCcuL3NyYy91dGlscycpLmRlcHJlY2F0ZTtcbiAgZGVwcmVjYXRlKCdOb2RlLmpzIHY1LnggYW5kIGJlbG93IHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiB0aGUgZnV0dXJlJyk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvdGVsZWdyYW0nKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvdGVsZWdyYW0nKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nexports.BaseError = function (_Error) {\n  _inherits(BaseError, _Error);\n\n  /**\n   * @class BaseError\n   * @constructor\n   * @private\n   * @param  {String} code Error code\n   * @param  {String} message Error message\n   */\n  function BaseError(code, message) {\n    _classCallCheck(this, BaseError);\n\n    var _this = _possibleConstructorReturn(this, (BaseError.__proto__ || Object.getPrototypeOf(BaseError)).call(this, code + ': ' + message));\n\n    _this.code = code;\n    return _this;\n  }\n\n  _createClass(BaseError, [{\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        code: this.code,\n        message: this.message\n      };\n    }\n  }]);\n\n  return BaseError;\n}(Error);\n\nexports.FatalError = function (_exports$BaseError) {\n  _inherits(FatalError, _exports$BaseError);\n\n  /**\n   * Fatal Error. Error code is `\"EFATAL\"`.\n   * @class FatalError\n   * @constructor\n   * @param  {String|Error} data Error object or message\n   */\n  function FatalError(data) {\n    _classCallCheck(this, FatalError);\n\n    var error = typeof data === 'string' ? null : data;\n    var message = error ? error.message : data;\n\n    var _this2 = _possibleConstructorReturn(this, (FatalError.__proto__ || Object.getPrototypeOf(FatalError)).call(this, 'EFATAL', message));\n\n    if (error) _this2.stack = error.stack;\n    return _this2;\n  }\n\n  return FatalError;\n}(exports.BaseError);\n\nexports.ParseError = function (_exports$BaseError2) {\n  _inherits(ParseError, _exports$BaseError2);\n\n  /**\n   * Error during parsing. Error code is `\"EPARSE\"`.\n   * @class ParseError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  function ParseError(message, response) {\n    _classCallCheck(this, ParseError);\n\n    var _this3 = _possibleConstructorReturn(this, (ParseError.__proto__ || Object.getPrototypeOf(ParseError)).call(this, 'EPARSE', message));\n\n    _this3.response = response;\n    return _this3;\n  }\n\n  return ParseError;\n}(exports.BaseError);\n\nexports.TelegramError = function (_exports$BaseError3) {\n  _inherits(TelegramError, _exports$BaseError3);\n\n  /**\n   * Error returned from Telegram. Error code is `\"ETELEGRAM\"`.\n   * @class TelegramError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  function TelegramError(message, response) {\n    _classCallCheck(this, TelegramError);\n\n    var _this4 = _possibleConstructorReturn(this, (TelegramError.__proto__ || Object.getPrototypeOf(TelegramError)).call(this, 'ETELEGRAM', message));\n\n    _this4.response = response;\n    return _this4;\n  }\n\n  return TelegramError;\n}(exports.BaseError);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixrREFBa0QsYUFBYSx5RkFBeUY7O0FBRXhKLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WCxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZGFyc2hcXE9uZURyaXZlXFxEZXNrdG9wXFxDb2RlXFxNRVJOIFdlYiBEZXZcXEdyYXBoaVxcbm9kZV9tb2R1bGVzXFxub2RlLXRlbGVncmFtLWJvdC1hcGlcXGxpYlxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5leHBvcnRzLkJhc2VFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEJhc2VFcnJvciwgX0Vycm9yKTtcblxuICAvKipcbiAgICogQGNsYXNzIEJhc2VFcnJvclxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjb2RlIEVycm9yIGNvZGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2VFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VFcnJvcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmFzZUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmFzZUVycm9yKSkuY2FsbCh0aGlzLCBjb2RlICsgJzogJyArIG1lc3NhZ2UpKTtcblxuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlRXJyb3IsIFt7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VFcnJvcjtcbn0oRXJyb3IpO1xuXG5leHBvcnRzLkZhdGFsRXJyb3IgPSBmdW5jdGlvbiAoX2V4cG9ydHMkQmFzZUVycm9yKSB7XG4gIF9pbmhlcml0cyhGYXRhbEVycm9yLCBfZXhwb3J0cyRCYXNlRXJyb3IpO1xuXG4gIC8qKlxuICAgKiBGYXRhbCBFcnJvci4gRXJyb3IgY29kZSBpcyBgXCJFRkFUQUxcImAuXG4gICAqIEBjbGFzcyBGYXRhbEVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd8RXJyb3J9IGRhdGEgRXJyb3Igb2JqZWN0IG9yIG1lc3NhZ2VcbiAgICovXG4gIGZ1bmN0aW9uIEZhdGFsRXJyb3IoZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGYXRhbEVycm9yKTtcblxuICAgIHZhciBlcnJvciA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IG51bGwgOiBkYXRhO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZGF0YTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRmF0YWxFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZhdGFsRXJyb3IpKS5jYWxsKHRoaXMsICdFRkFUQUwnLCBtZXNzYWdlKSk7XG5cbiAgICBpZiAoZXJyb3IpIF90aGlzMi5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gRmF0YWxFcnJvcjtcbn0oZXhwb3J0cy5CYXNlRXJyb3IpO1xuXG5leHBvcnRzLlBhcnNlRXJyb3IgPSBmdW5jdGlvbiAoX2V4cG9ydHMkQmFzZUVycm9yMikge1xuICBfaW5oZXJpdHMoUGFyc2VFcnJvciwgX2V4cG9ydHMkQmFzZUVycm9yMik7XG5cbiAgLyoqXG4gICAqIEVycm9yIGR1cmluZyBwYXJzaW5nLiBFcnJvciBjb2RlIGlzIGBcIkVQQVJTRVwiYC5cbiAgICogQGNsYXNzIFBhcnNlRXJyb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSAge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXNwb25zZSBTZXJ2ZXIgcmVzcG9uc2VcbiAgICovXG4gIGZ1bmN0aW9uIFBhcnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VFcnJvcik7XG5cbiAgICB2YXIgX3RoaXMzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhcnNlRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXJzZUVycm9yKSkuY2FsbCh0aGlzLCAnRVBBUlNFJywgbWVzc2FnZSkpO1xuXG4gICAgX3RoaXMzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBQYXJzZUVycm9yO1xufShleHBvcnRzLkJhc2VFcnJvcik7XG5cbmV4cG9ydHMuVGVsZWdyYW1FcnJvciA9IGZ1bmN0aW9uIChfZXhwb3J0cyRCYXNlRXJyb3IzKSB7XG4gIF9pbmhlcml0cyhUZWxlZ3JhbUVycm9yLCBfZXhwb3J0cyRCYXNlRXJyb3IzKTtcblxuICAvKipcbiAgICogRXJyb3IgcmV0dXJuZWQgZnJvbSBUZWxlZ3JhbS4gRXJyb3IgY29kZSBpcyBgXCJFVEVMRUdSQU1cImAuXG4gICAqIEBjbGFzcyBUZWxlZ3JhbUVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgU2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBmdW5jdGlvbiBUZWxlZ3JhbUVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlbGVncmFtRXJyb3IpO1xuXG4gICAgdmFyIF90aGlzNCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZWxlZ3JhbUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGVsZWdyYW1FcnJvcikpLmNhbGwodGhpcywgJ0VURUxFR1JBTScsIG1lc3NhZ2UpKTtcblxuICAgIF90aGlzNC5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gVGVsZWdyYW1FcnJvcjtcbn0oZXhwb3J0cy5CYXNlRXJyb3IpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js":
/*!************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegram.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// shims\n(__webpack_require__(/*! array.prototype.findindex */ \"(rsc)/./node_modules/array.prototype.findindex/index.js\").shim)(); // for Node.js v0.x\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar TelegramBotWebHook = __webpack_require__(/*! ./telegramWebHook */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js\");\nvar TelegramBotPolling = __webpack_require__(/*! ./telegramPolling */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/eventemitter3/index.js\");\nvar fileType = __webpack_require__(/*! file-type */ \"(rsc)/./node_modules/file-type/index.js\");\nvar request = __webpack_require__(/*! @cypress/request-promise */ \"(rsc)/./node_modules/@cypress/request-promise/lib/rp.js\");\nvar streamedRequest = __webpack_require__(/*! @cypress/request */ \"(rsc)/./node_modules/@cypress/request/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar mime = __webpack_require__(/*! mime */ \"(rsc)/./node_modules/mime/mime.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar URL = __webpack_require__(/*! url */ \"url\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\");\nvar deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\").deprecate);\n\nvar _messageTypes = ['text', 'animation', 'audio', 'channel_chat_created', 'contact', 'delete_chat_photo', 'dice', 'document', 'game', 'group_chat_created', 'invoice', 'left_chat_member', 'location', 'migrate_from_chat_id', 'migrate_to_chat_id', 'new_chat_members', 'new_chat_photo', 'new_chat_title', 'passport_data', 'photo', 'pinned_message', 'poll', 'sticker', 'successful_payment', 'supergroup_chat_created', 'video', 'video_note', 'voice', 'video_chat_started', 'video_chat_ended', 'video_chat_participants_invited', 'video_chat_scheduled', 'message_auto_delete_timer_changed', 'chat_invite_link', 'chat_member_updated', 'web_app_data', 'message_reaction'];\n\nvar _deprecatedMessageTypes = ['new_chat_participant', 'left_chat_participant'];\n\n/**\n * JSON-serialize data. If the provided data is already a String,\n * return it as is.\n * @private\n * @param  {*} data\n * @return {String}\n */\nfunction stringify(data) {\n  if (typeof data === 'string') {\n    return data;\n  }\n  return JSON.stringify(data);\n}\n\nvar TelegramBot = function (_EventEmitter) {\n  _inherits(TelegramBot, _EventEmitter);\n\n  _createClass(TelegramBot, [{\n    key: 'on',\n\n\n    /**\n     * Add listener for the specified [event](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events).\n     * This is the usual `emitter.on()` method.\n     * @param  {String} event\n     * @param  {Function} listener\n     * @see {@link https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events|Available events}\n     * @see https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\n     */\n    value: function on(event, listener) {\n      if (_deprecatedMessageTypes.indexOf(event) !== -1) {\n        var url = 'https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events';\n        deprecate('Events ' + _deprecatedMessageTypes.join(',') + ' are deprecated. See the updated list of events: ' + url);\n      }\n      _get(TelegramBot.prototype.__proto__ || Object.getPrototypeOf(TelegramBot.prototype), 'on', this).call(this, event, listener);\n    }\n\n    /**\n     * Both request method to obtain messages are implemented. To use standard polling, set `polling: true`\n     * on `options`. Notice that [webHook](https://core.telegram.org/bots/api#setwebhook) will need a SSL certificate.\n     * Emits `message` when a message arrives.\n     *\n     * @class TelegramBot\n     * @constructor\n     * @param {String} token Bot Token\n     * @param {Object} [options]\n     * @param {Boolean|Object} [options.polling=false] Set true to enable polling or set options.\n     *  If a WebHook has been set, it will be deleted automatically.\n     * @param {String|Number} [options.polling.timeout=10] *Deprecated. Use `options.polling.params` instead*.\n     *  Timeout in seconds for long polling.\n     * @param {Boolean} [options.testEnvironment=false] Set true to  work with test enviroment.\n     * When working with the test environment, you may use HTTP links without TLS to test your Web App.\n     * @param {String|Number} [options.polling.interval=300] Interval between requests in miliseconds\n     * @param {Boolean} [options.polling.autoStart=true] Start polling immediately\n     * @param {Object} [options.polling.params] Parameters to be used in polling API requests.\n     *  See https://core.telegram.org/bots/api#getupdates for more information.\n     * @param  {Number} [options.polling.params.timeout=10] Timeout in seconds for long polling.\n     * @param {Boolean|Object} [options.webHook=false] Set true to enable WebHook or set options\n     * @param {String} [options.webHook.host=\"0.0.0.0\"] Host to bind to\n     * @param {Number} [options.webHook.port=8443] Port to bind to\n     * @param {String} [options.webHook.key] Path to file with PEM private key for webHook server.\n     *  The file is read **synchronously**!\n     * @param {String} [options.webHook.cert] Path to file with PEM certificate (public) for webHook server.\n     *  The file is read **synchronously**!\n     * @param {String} [options.webHook.pfx] Path to file with PFX private key and certificate chain for webHook server.\n     *  The file is read **synchronously**!\n     * @param {Boolean} [options.webHook.autoOpen=true] Open webHook immediately\n     * @param {Object} [options.webHook.https] Options to be passed to `https.createServer()`.\n     *  Note that `options.webHook.key`, `options.webHook.cert` and `options.webHook.pfx`, if provided, will be\n     *  used to override `key`, `cert` and `pfx` in this object, respectively.\n     *  See https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener for more information.\n     * @param {String} [options.webHook.healthEndpoint=\"/healthz\"] An endpoint for health checks that always responds with 200 OK\n     * @param {Boolean} [options.onlyFirstMatch=false] Set to true to stop after first match. Otherwise, all regexps are executed\n     * @param {Object} [options.request] Options which will be added for all requests to telegram api.\n     *  See https://github.com/request/request#requestoptions-callback for more information.\n     * @param {String} [options.baseApiUrl=\"https://api.telegram.org\"] API Base URl; useful for proxying and testing\n     * @param {Boolean} [options.filepath=true] Allow passing file-paths as arguments when sending files,\n     *  such as photos using `TelegramBot#sendPhoto()`. See [usage information][usage-sending-files-performance]\n     *  for more information on this option and its consequences.\n     * @param {Boolean} [options.badRejection=false] Set to `true`\n     *  **if and only if** the Node.js version you're using terminates the\n     *  process on unhandled rejections. This option is only for\n     *  *forward-compatibility purposes*.\n     * @see https://core.telegram.org/bots/api\n     */\n\n  }], [{\n    key: 'errors',\n\n    /**\n     * The different errors the library uses.\n     * @type {Object}\n     */\n    get: function get() {\n      return errors;\n    }\n\n    /**\n     * The types of message updates the library handles.\n     * @type {String[]}\n     */\n\n  }, {\n    key: 'messageTypes',\n    get: function get() {\n      return _messageTypes;\n    }\n  }]);\n\n  function TelegramBot(token) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TelegramBot);\n\n    var _this = _possibleConstructorReturn(this, (TelegramBot.__proto__ || Object.getPrototypeOf(TelegramBot)).call(this));\n\n    _this.token = token;\n    _this.options = options;\n    _this.options.polling = typeof options.polling === 'undefined' ? false : options.polling;\n    _this.options.webHook = typeof options.webHook === 'undefined' ? false : options.webHook;\n    _this.options.baseApiUrl = options.baseApiUrl || 'https://api.telegram.org';\n    _this.options.filepath = typeof options.filepath === 'undefined' ? true : options.filepath;\n    _this.options.badRejection = typeof options.badRejection === 'undefined' ? false : options.badRejection;\n    _this._textRegexpCallbacks = [];\n    _this._replyListenerId = 0;\n    _this._replyListeners = [];\n    _this._polling = null;\n    _this._webHook = null;\n\n    if (options.polling) {\n      var autoStart = options.polling.autoStart;\n      if (typeof autoStart === 'undefined' || autoStart === true) {\n        _this.startPolling();\n      }\n    }\n\n    if (options.webHook) {\n      var autoOpen = options.webHook.autoOpen;\n      if (typeof autoOpen === 'undefined' || autoOpen === true) {\n        _this.openWebHook();\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Generates url with bot token and provided path/method you want to be got/executed by bot\n   * @param  {String} path\n   * @return {String} url\n   * @private\n   * @see https://core.telegram.org/bots/api#making-requests\n   */\n\n\n  _createClass(TelegramBot, [{\n    key: '_buildURL',\n    value: function _buildURL(_path) {\n      return this.options.baseApiUrl + '/bot' + this.token + (this.options.testEnvironment ? '/test' : '') + '/' + _path;\n    }\n\n    /**\n     * Fix 'reply_markup' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object; either 'form' or 'qs'\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: '_fixReplyMarkup',\n    value: function _fixReplyMarkup(obj) {\n      var replyMarkup = obj.reply_markup;\n      if (replyMarkup && typeof replyMarkup !== 'string') {\n        obj.reply_markup = stringify(replyMarkup);\n      }\n    }\n\n    /**\n     * Fix 'entities' or 'caption_entities' or 'explanation_entities' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object;\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     * @see https://core.telegram.org/bots/api#copymessage\n     * @see https://core.telegram.org/bots/api#sendpoll\n     */\n\n  }, {\n    key: '_fixEntitiesField',\n    value: function _fixEntitiesField(obj) {\n      var entities = obj.entities;\n      var captionEntities = obj.caption_entities;\n      var explanationEntities = obj.explanation_entities;\n      if (entities && typeof entities !== 'string') {\n        obj.entities = stringify(entities);\n      }\n\n      if (captionEntities && typeof captionEntities !== 'string') {\n        obj.caption_entities = stringify(captionEntities);\n      }\n\n      if (explanationEntities && typeof explanationEntities !== 'string') {\n        obj.explanation_entities = stringify(explanationEntities);\n      }\n    }\n  }, {\n    key: '_fixAddFileThumbnail',\n    value: function _fixAddFileThumbnail(options, opts) {\n      if (options.thumb) {\n        if (opts.formData === null) {\n          opts.formData = {};\n        }\n\n        var attachName = 'photo';\n\n        var _formatSendData2 = this._formatSendData(attachName, options.thumb.replace('attach://', '')),\n            _formatSendData3 = _slicedToArray(_formatSendData2, 1),\n            formData = _formatSendData3[0];\n\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          opts.qs.thumbnail = 'attach://' + attachName;\n        }\n      }\n    }\n\n    /**\n     * Fix 'reply_parameters' parameter by making it JSON-serialized, as\n     * required by the Telegram Bot API\n     * @param {Object} obj Object; either 'form' or 'qs'\n     * @private\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: '_fixReplyParameters',\n    value: function _fixReplyParameters(obj) {\n      if (obj.hasOwnProperty('reply_parameters') && typeof obj.reply_parameters !== 'string') {\n        obj.reply_parameters = stringify(obj.reply_parameters);\n      }\n    }\n\n    /**\n     * Make request against the API\n     * @param  {String} _path API endpoint\n     * @param  {Object} [options]\n     * @private\n     * @return {Promise}\n     */\n\n  }, {\n    key: '_request',\n    value: function _request(_path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.token) {\n        return Promise.reject(new errors.FatalError('Telegram Bot Token not provided!'));\n      }\n\n      if (this.options.request) {\n        Object.assign(options, this.options.request);\n      }\n\n      if (options.form) {\n        this._fixReplyMarkup(options.form);\n        this._fixEntitiesField(options.form);\n        this._fixReplyParameters(options.form);\n      }\n      if (options.qs) {\n        this._fixReplyMarkup(options.qs);\n        this._fixReplyParameters(options.qs);\n      }\n\n      options.method = 'POST';\n      options.url = this._buildURL(_path);\n      options.simple = false;\n      options.resolveWithFullResponse = true;\n      options.forever = true;\n      debug('HTTP request: %j', options);\n      return request(options).then(function (resp) {\n        var data = void 0;\n        try {\n          data = resp.body = JSON.parse(resp.body);\n        } catch (err) {\n          throw new errors.ParseError('Error parsing response: ' + resp.body, resp);\n        }\n\n        if (data.ok) {\n          return data.result;\n        }\n\n        throw new errors.TelegramError(data.error_code + ' ' + data.description, resp);\n      }).catch(function (error) {\n        // TODO: why can't we do `error instanceof errors.BaseError`?\n        if (error.response) throw error;\n        throw new errors.FatalError(error);\n      });\n    }\n\n    /**\n     * Format data to be uploaded; handles file paths, streams and buffers\n     * @param  {String} type\n     * @param  {String|stream.Stream|Buffer} data\n     * @param  {Object} fileOptions File options\n     * @param  {String} [fileOptions.filename] File name\n     * @param  {String} [fileOptions.contentType] Content type (i.e. MIME)\n     * @return {Array} formatted\n     * @return {Object} formatted[0] formData\n     * @return {String} formatted[1] fileId\n     * @throws Error if Buffer file type is not supported.\n     * @see https://npmjs.com/package/file-type\n     * @private\n     */\n\n  }, {\n    key: '_formatSendData',\n    value: function _formatSendData(type, data) {\n      var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var deprecationMessage = 'See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files' + ' for more information on how sending files has been improved and' + ' on how to disable this deprecation message altogether.';\n      var filedata = data;\n      var filename = fileOptions.filename;\n      var contentType = fileOptions.contentType;\n\n      if (data instanceof stream.Stream) {\n        if (!filename && data.path) {\n          // Will be 'null' if could not be parsed.\n          // For example, 'data.path' === '/?id=123' from 'request(\"https://example.com/?id=123\")'\n          var url = URL.parse(path.basename(data.path.toString()));\n          if (url.pathname) {\n            filename = qs.unescape(url.pathname);\n          }\n        }\n      } else if (Buffer.isBuffer(data)) {\n        if (!filename && !process.env.NTBA_FIX_350) {\n          deprecate('Buffers will have their filenames default to \"filename\" instead of \"data\". ' + deprecationMessage);\n          filename = 'data';\n        }\n        if (!contentType) {\n          var filetype = fileType(data);\n          if (filetype) {\n            contentType = filetype.mime;\n            var ext = filetype.ext;\n            if (ext && !process.env.NTBA_FIX_350) {\n              filename = filename + '.' + ext;\n            }\n          } else if (!process.env.NTBA_FIX_350) {\n            deprecate('An error will no longer be thrown if file-type of buffer could not be detected. ' + deprecationMessage);\n            throw new errors.FatalError('Unsupported Buffer file-type');\n          }\n        }\n      } else if (data) {\n        if (this.options.filepath && fs.existsSync(data)) {\n          filedata = fs.createReadStream(data);\n          if (!filename) {\n            filename = path.basename(data);\n          }\n        } else {\n          return [null, data];\n        }\n      } else {\n        return [null, data];\n      }\n\n      filename = filename || 'filename';\n      contentType = contentType || mime.lookup(filename);\n      if (process.env.NTBA_FIX_350) {\n        contentType = contentType || 'application/octet-stream';\n      } else {\n        deprecate('In the future, content-type of files you send will default to \"application/octet-stream\". ' + deprecationMessage);\n      }\n\n      // TODO: Add missing file extension.\n\n      return [_defineProperty({}, type, {\n        value: filedata,\n        options: {\n          filename: filename,\n          contentType: contentType\n        }\n      }), null];\n    }\n\n    /**\n     * Start polling.\n     * Rejects returned promise if a WebHook is being used by this instance.\n     * @param  {Object} [options]\n     * @param  {Boolean} [options.restart=true] Consecutive calls to this method causes polling to be restarted\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'startPolling',\n    value: function startPolling() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.hasOpenWebHook()) {\n        return Promise.reject(new errors.FatalError('Polling and WebHook are mutually exclusive'));\n      }\n      options.restart = typeof options.restart === 'undefined' ? true : options.restart;\n      if (!this._polling) {\n        this._polling = new TelegramBotPolling(this);\n      }\n      return this._polling.start(options);\n    }\n\n    /**\n     * Alias of `TelegramBot#startPolling()`. This is **deprecated**.\n     * @param  {Object} [options]\n     * @return {Promise}\n     * @deprecated\n     */\n\n  }, {\n    key: 'initPolling',\n    value: function initPolling() {\n      deprecate('TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.');\n      return this.startPolling();\n    }\n\n    /**\n     * Stops polling after the last polling request resolves.\n     * Multiple invocations do nothing if polling is already stopped.\n     * Returning the promise of the last polling request is **deprecated**.\n     * @param  {Object} [options] Options\n     * @param  {Boolean} [options.cancel] Cancel current request\n     * @param  {String} [options.reason] Reason for stopping polling\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'stopPolling',\n    value: function stopPolling(options) {\n      if (!this._polling) {\n        return Promise.resolve();\n      }\n      return this._polling.stop(options);\n    }\n\n    /**\n     * Get link for file.\n     * Use this method to get link for file for subsequent use.\n     * Attention: link will be valid for 1 hour.\n     *\n     * This method is a sugar extension of the (getFile)[#getfilefileid] method,\n     * which returns just path to file on remote server (you will have to manually build full uri after that).\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Promise which will have  *fileURI* in resolve callback\n     * @see https://core.telegram.org/bots/api#getfile\n     */\n\n  }, {\n    key: 'getFileLink',\n    value: function getFileLink(fileId) {\n      var _this2 = this;\n\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return this.getFile(fileId, form).then(function (resp) {\n        return _this2.options.baseApiUrl + '/file/bot' + _this2.token + '/' + resp.file_path;\n      });\n    }\n\n    /**\n     * Return a readable stream for file.\n     *\n     * `fileStream.path` is the specified file ID i.e. `fileId`.\n     * `fileStream` emits event `info` passing a single argument i.e.\n     * `info` with the interface `{ uri }` where `uri` is the URI of the\n     * file on Telegram servers.\n     *\n     * This method is a sugar extension of the [getFileLink](#TelegramBot+getFileLink) method,\n     * which returns the full URI to the file on remote server.\n     *\n     * @param  {String} fileId File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {stream.Readable} fileStream\n     */\n\n  }, {\n    key: 'getFileStream',\n    value: function getFileStream(fileId) {\n      var _this3 = this;\n\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var fileStream = new stream.PassThrough();\n      fileStream.path = fileId;\n      this.getFileLink(fileId, form).then(function (fileURI) {\n        fileStream.emit('info', {\n          uri: fileURI\n        });\n        pump(streamedRequest(Object.assign({ uri: fileURI }, _this3.options.request)), fileStream);\n      }).catch(function (error) {\n        fileStream.emit('error', error);\n      });\n      return fileStream;\n    }\n\n    /**\n     * Downloads file in the specified folder.\n     *\n     * This method is a sugar extension of the [getFileStream](#TelegramBot+getFileStream) method,\n     * which returns a readable file stream.\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {String} downloadDir Absolute path to the folder in which file will be saved\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Promise, which will have *filePath* of downloaded file in resolve callback\n     */\n\n  }, {\n    key: 'downloadFile',\n    value: function downloadFile(fileId, downloadDir) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var resolve = void 0;\n      var reject = void 0;\n      var promise = new Promise(function (a, b) {\n        resolve = a;\n        reject = b;\n      });\n      var fileStream = this.getFileStream(fileId, form);\n      fileStream.on('info', function (info) {\n        var fileName = info.uri.slice(info.uri.lastIndexOf('/') + 1);\n        // TODO: Ensure fileName doesn't contains slashes\n        var filePath = path.join(downloadDir, fileName);\n        pump(fileStream, fs.createWriteStream(filePath), function (error) {\n          if (error) {\n            return reject(error);\n          }\n          return resolve(filePath);\n        });\n      });\n      fileStream.on('error', function (err) {\n        reject(err);\n      });\n      return promise;\n    }\n\n    /**\n     * Register a RegExp to test against an incomming text message.\n     * @param  {RegExp}   regexpRexecuted with `exec`.\n     * @param  {Function} callback     Callback will be called with 2 parameters,\n     * the `msg` and the result of executing `regexp.exec` on message text.\n     */\n\n  }, {\n    key: 'onText',\n    value: function onText(regexp, callback) {\n      this._textRegexpCallbacks.push({ regexp: regexp, callback: callback });\n    }\n\n    /**\n     * Remove a listener registered with `onText()`.\n     * @param  {RegExp} regexp RegExp used previously in `onText()`\n     * @return {Object} deletedListener The removed reply listener if\n     *   found. This object has `regexp` and `callback`\n     *   properties. If not found, returns `null`.\n     */\n\n  }, {\n    key: 'removeTextListener',\n    value: function removeTextListener(regexp) {\n      var index = this._textRegexpCallbacks.findIndex(function (textListener) {\n        return String(textListener.regexp) === String(regexp);\n      });\n      if (index === -1) {\n        return null;\n      }\n      return this._textRegexpCallbacks.splice(index, 1)[0];\n    }\n\n    /**\n     * Remove all listeners registered with `onText()`.\n     */\n\n  }, {\n    key: 'clearTextListeners',\n    value: function clearTextListeners() {\n      this._textRegexpCallbacks = [];\n    }\n\n    /**\n     * Register a reply to wait for a message response.\n     *\n     * @param  {Number|String} chatId The chat id where the message cames from.\n     * @param  {Number|String} messageId The message id to be replied.\n     * @param  {Function} callback Callback will be called with the reply\n     *  message.\n     * @return {Number} id The ID of the inserted reply listener.\n     */\n\n  }, {\n    key: 'onReplyToMessage',\n    value: function onReplyToMessage(chatId, messageId, callback) {\n      var id = ++this._replyListenerId;\n      this._replyListeners.push({\n        id: id,\n        chatId: chatId,\n        messageId: messageId,\n        callback: callback\n      });\n      return id;\n    }\n\n    /**\n     * Removes a reply that has been prev. registered for a message response.\n     * @param   {Number} replyListenerId The ID of the reply listener.\n     * @return  {Object} deletedListener The removed reply listener if\n     *   found. This object has `id`, `chatId`, `messageId` and `callback`\n     *   properties. If not found, returns `null`.\n     */\n\n  }, {\n    key: 'removeReplyListener',\n    value: function removeReplyListener(replyListenerId) {\n      var index = this._replyListeners.findIndex(function (replyListener) {\n        return replyListener.id === replyListenerId;\n      });\n      if (index === -1) {\n        return null;\n      }\n      return this._replyListeners.splice(index, 1)[0];\n    }\n\n    /**\n     * Removes all replies that have been prev. registered for a message response.\n     *\n     * @return  {Array} deletedListeners An array of removed listeners.\n     */\n\n  }, {\n    key: 'clearReplyListeners',\n    value: function clearReplyListeners() {\n      this._replyListeners = [];\n    }\n\n    /**\n     * Return true if polling. Otherwise, false.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isPolling',\n    value: function isPolling() {\n      return this._polling ? this._polling.isPolling() : false;\n    }\n\n    /**\n     * Open webhook.\n     * Multiple invocations do nothing if webhook is already open.\n     * Rejects returned promise if Polling is being used by this instance.\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'openWebHook',\n    value: function openWebHook() {\n      if (this.isPolling()) {\n        return Promise.reject(new errors.FatalError('WebHook and Polling are mutually exclusive'));\n      }\n      if (!this._webHook) {\n        this._webHook = new TelegramBotWebHook(this);\n      }\n      return this._webHook.open();\n    }\n\n    /**\n     * Close webhook after closing all current connections.\n     * Multiple invocations do nothing if webhook is already closed.\n     *\n     * @return {Promise} Promise\n     */\n\n  }, {\n    key: 'closeWebHook',\n    value: function closeWebHook() {\n      if (!this._webHook) {\n        return Promise.resolve();\n      }\n      return this._webHook.close();\n    }\n\n    /**\n     * Return true if using webhook and it is open i.e. accepts connections.\n     * Otherwise, false.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasOpenWebHook',\n    value: function hasOpenWebHook() {\n      return this._webHook ? this._webHook.isOpen() : false;\n    }\n\n    /**\n     * Process an update; emitting the proper events and executing regexp\n     * callbacks. This method is useful should you be using a different\n     * way to fetch updates, other than those provided by TelegramBot.\n     *\n     * @param  {Object} update\n     * @see https://core.telegram.org/bots/api#update\n     */\n\n  }, {\n    key: 'processUpdate',\n    value: function processUpdate(update) {\n      var _this4 = this;\n\n      debug('Process Update %j', update);\n      var message = update.message;\n      var editedMessage = update.edited_message;\n      var channelPost = update.channel_post;\n      var editedChannelPost = update.edited_channel_post;\n      var businessConnection = update.business_connection;\n      var businesssMessage = update.business_message;\n      var editedBusinessMessage = update.edited_business_message;\n      var deletedBusinessMessage = update.deleted_business_messages;\n      var messageReaction = update.message_reaction;\n      var messageReactionCount = update.message_reaction_count;\n      var inlineQuery = update.inline_query;\n      var chosenInlineResult = update.chosen_inline_result;\n      var callbackQuery = update.callback_query;\n      var shippingQuery = update.shipping_query;\n      var preCheckoutQuery = update.pre_checkout_query;\n      var poll = update.poll;\n      var pollAnswer = update.poll_answer;\n      var myChatMember = update.my_chat_member;\n      var chatMember = update.chat_member;\n      var chatJoinRequest = update.chat_join_request;\n      var chatBoost = update.chat_boost;\n      var removedChatBoost = update.removed_chat_boost;\n\n      if (message) {\n        debug('Process Update message %j', message);\n        var metadata = {};\n        metadata.type = TelegramBot.messageTypes.find(function (messageType) {\n          return message[messageType];\n        });\n        this.emit('message', message, metadata);\n        if (metadata.type) {\n          debug('Emitting %s: %j', metadata.type, message);\n          this.emit(metadata.type, message, metadata);\n        }\n        if (message.text) {\n          debug('Text message');\n          this._textRegexpCallbacks.some(function (reg) {\n            debug('Matching %s with %s', message.text, reg.regexp);\n\n            if (!(reg.regexp instanceof RegExp)) {\n              reg.regexp = new RegExp(reg.regexp);\n            }\n\n            var result = reg.regexp.exec(message.text);\n            if (!result) {\n              return false;\n            }\n            // reset index so we start at the beginning of the regex each time\n            reg.regexp.lastIndex = 0;\n            debug('Matches %s', reg.regexp);\n            reg.callback(message, result);\n            // returning truthy value exits .some\n            return _this4.options.onlyFirstMatch;\n          });\n        }\n        if (message.reply_to_message) {\n          // Only callbacks waiting for this message\n          this._replyListeners.forEach(function (reply) {\n            // Message from the same chat\n            if (reply.chatId === message.chat.id) {\n              // Responding to that message\n              if (reply.messageId === message.reply_to_message.message_id) {\n                // Resolve the promise\n                reply.callback(message);\n              }\n            }\n          });\n        }\n      } else if (editedMessage) {\n        debug('Process Update edited_message %j', editedMessage);\n        this.emit('edited_message', editedMessage);\n        if (editedMessage.text) {\n          this.emit('edited_message_text', editedMessage);\n        }\n        if (editedMessage.caption) {\n          this.emit('edited_message_caption', editedMessage);\n        }\n      } else if (channelPost) {\n        debug('Process Update channel_post %j', channelPost);\n        this.emit('channel_post', channelPost);\n      } else if (editedChannelPost) {\n        debug('Process Update edited_channel_post %j', editedChannelPost);\n        this.emit('edited_channel_post', editedChannelPost);\n        if (editedChannelPost.text) {\n          this.emit('edited_channel_post_text', editedChannelPost);\n        }\n        if (editedChannelPost.caption) {\n          this.emit('edited_channel_post_caption', editedChannelPost);\n        }\n      } else if (businessConnection) {\n        debug('Process Update business_connection %j', businessConnection);\n        this.emit('business_connection', businessConnection);\n      } else if (businesssMessage) {\n        debug('Process Update business_message %j', businesssMessage);\n        this.emit('business_message', businesssMessage);\n      } else if (editedBusinessMessage) {\n        debug('Process Update edited_business_message %j', editedBusinessMessage);\n        this.emit('edited_business_message', editedBusinessMessage);\n      } else if (deletedBusinessMessage) {\n        debug('Process Update deleted_business_messages %j', deletedBusinessMessage);\n        this.emit('deleted_business_messages', deletedBusinessMessage);\n      } else if (messageReaction) {\n        debug('Process Update message_reaction %j', messageReaction);\n        this.emit('message_reaction', messageReaction);\n      } else if (messageReactionCount) {\n        debug('Process Update message_reaction_count %j', messageReactionCount);\n        this.emit('message_reaction_count', messageReactionCount);\n      } else if (inlineQuery) {\n        debug('Process Update inline_query %j', inlineQuery);\n        this.emit('inline_query', inlineQuery);\n      } else if (chosenInlineResult) {\n        debug('Process Update chosen_inline_result %j', chosenInlineResult);\n        this.emit('chosen_inline_result', chosenInlineResult);\n      } else if (callbackQuery) {\n        debug('Process Update callback_query %j', callbackQuery);\n        this.emit('callback_query', callbackQuery);\n      } else if (shippingQuery) {\n        debug('Process Update shipping_query %j', shippingQuery);\n        this.emit('shipping_query', shippingQuery);\n      } else if (preCheckoutQuery) {\n        debug('Process Update pre_checkout_query %j', preCheckoutQuery);\n        this.emit('pre_checkout_query', preCheckoutQuery);\n      } else if (poll) {\n        debug('Process Update poll %j', poll);\n        this.emit('poll', poll);\n      } else if (pollAnswer) {\n        debug('Process Update poll_answer %j', pollAnswer);\n        this.emit('poll_answer', pollAnswer);\n      } else if (chatMember) {\n        debug('Process Update chat_member %j', chatMember);\n        this.emit('chat_member', chatMember);\n      } else if (myChatMember) {\n        debug('Process Update my_chat_member %j', myChatMember);\n        this.emit('my_chat_member', myChatMember);\n      } else if (chatJoinRequest) {\n        debug('Process Update my_chat_member %j', chatJoinRequest);\n        this.emit('chat_join_request', chatJoinRequest);\n      } else if (chatBoost) {\n        debug('Process Update chat_boost %j', chatBoost);\n        this.emit('chat_boost', chatBoost);\n      } else if (removedChatBoost) {\n        debug('Process Update removed_chat_boost %j', removedChatBoost);\n        this.emit('removed_chat_boost', removedChatBoost);\n      }\n    }\n\n    /** Start Telegram Bot API methods */\n\n    /**\n    * Use this method to receive incoming updates using long polling.\n    * This method has an [older, compatible signature][getUpdates-v0.25.0]\n    * that is being deprecated.\n    *\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise}\n    * @see https://core.telegram.org/bots/api#getupdates\n    */\n\n  }, {\n    key: 'getUpdates',\n    value: function getUpdates() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /* The older method signature was getUpdates(timeout, limit, offset).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0');\n        form = {\n          timeout: arguments[0],\n          limit: arguments[1],\n          offset: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n\n      return this._request('getUpdates', { form: form });\n    }\n\n    /**\n     * Specify an url to receive incoming updates via an outgoing webHook.\n     * This method has an [older, compatible signature][setWebHook-v0.25.0]\n     * that is being deprecated.\n     *\n     * @param  {String} url URL where Telegram will make HTTP Post. Leave empty to\n     * delete webHook.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {String|stream.Stream} [options.certificate] PEM certificate key (public).\n     * @param  {String} [options.secret_token] Optional secret token to be sent in a header `X-Telegram-Bot-Api-Secret-Token` in every webhook request.\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#setwebhook\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'setWebHook',\n    value: function setWebHook(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      /* The older method signature was setWebHook(url, cert).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      var cert = void 0;\n      // Note: 'options' could be an object, if a stream was provided (in place of 'cert')\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' || options instanceof stream.Stream) {\n        deprecate('The method signature setWebHook(url, cert) has been deprecated since v0.25.0');\n        cert = options;\n        options = {}; // eslint-disable-line no-param-reassign\n      } else {\n        cert = options.certificate;\n      }\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.url = url;\n\n      if (cert) {\n        try {\n          var sendData = this._formatSendData('certificate', cert, fileOptions);\n          opts.formData = sendData[0];\n          opts.qs.certificate = sendData[1];\n        } catch (ex) {\n          return Promise.reject(ex);\n        }\n      }\n\n      return this._request('setWebHook', opts);\n    }\n\n    /**\n     * Use this method to remove webhook integration if you decide to\n     * switch back to getUpdates. Returns True on success.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#deletewebhook\n     */\n\n  }, {\n    key: 'deleteWebHook',\n    value: function deleteWebHook() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('deleteWebhook', { form: form });\n    }\n\n    /**\n     * Use this method to get current webhook status.\n     * On success, returns a [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object.\n     * If the bot is using getUpdates, will return an object with the\n     * url field empty.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#getwebhookinfo\n     */\n\n  }, {\n    key: 'getWebHookInfo',\n    value: function getWebHookInfo() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getWebhookInfo', { form: form });\n    }\n\n    /**\n     * A simple method for testing your bot's authentication token. Requires no parameters.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} basic information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.\n     * @see https://core.telegram.org/bots/api#getme\n     */\n\n  }, {\n    key: 'getMe',\n    value: function getMe() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMe', { form: form });\n    }\n\n    /**\n     * This method log out your bot from the cloud Bot API server before launching the bot locally.\n     * You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates.\n     * After a successful call, you will not be able to log in again using the same token for 10 minutes.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#logout\n     */\n\n  }, {\n    key: 'logOut',\n    value: function logOut() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('logOut', { form: form });\n    }\n\n    /**\n     * This method close the bot instance before moving it from one local server to another.\n     * This method will return error 429 in the first 10 minutes after the bot is launched.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#close\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('close', { form: form });\n    }\n\n    /**\n     * Send text message.\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} text Text of the message to be sent\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendmessage\n     */\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(chatId, text) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.text = text;\n      return this._request('sendMessage', { form: form });\n    }\n\n    /**\n     * Forward messages of any kind.\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent (or channel username in the format `@channelusername`)\n     * @param  {Number|String} messageId  Unique message identifier in the chat specified in fromChatId\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}\n     * @see https://core.telegram.org/bots/api#forwardmessage\n     */\n\n  }, {\n    key: 'forwardMessage',\n    value: function forwardMessage(chatId, fromChatId, messageId) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_id = messageId;\n      return this._request('forwardMessage', { form: form });\n    }\n\n    /**\n     * Use this method to forward multiple messages of any kind.\n     * If some of the specified messages can't be found or forwarded, they are skipped.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent (or channel username in the format `@channelusername`)\n     * @param  {Array<Number|String>} messageIds Identifiers of 1-100 messages in the chat from_chat_id to forward.\n     * The identifiers must be specified in a strictly increasing order.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} An array of MessageId of the sent messages on success\n     * @see https://core.telegram.org/bots/api#forwardmessages\n     */\n\n  }, {\n    key: 'forwardMessages',\n    value: function forwardMessages(chatId, fromChatId, messageIds) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_ids = messageIds;\n      return this._request('forwardMessages', { form: form });\n    }\n\n    /**\n     * Copy messages of any kind. **Service messages and invoice messages can't be copied.**\n     * The method is analogous to the method forwardMessages, but the copied message doesn't\n     * have a link to the original message.\n     * Returns the MessageId of the sent message on success.\n     * @param  {Number|String} chatId     Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent\n     * @param  {Number|String} messageId  Unique message identifier\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The [MessageId](https://core.telegram.org/bots/api#messageid) of the sent message on success\n     * @see https://core.telegram.org/bots/api#copymessage\n     */\n\n  }, {\n    key: 'copyMessage',\n    value: function copyMessage(chatId, fromChatId, messageId) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_id = messageId;\n      return this._request('copyMessage', { form: form });\n    }\n\n    /**\n     * Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped.\n     * Service messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.\n     * Returns the MessageId of the sent message on success.\n     * @param  {Number|String} chatId Unique identifier for the target chat\n     * @param  {Number|String} fromChatId Unique identifier for the chat where the\n     * original message was sent\n     * @param  {Array} messageIds  Identifiers of 1-100 messages in the chat from_chat_id to copy.\n     * The identifiers must be specified in a strictly increasing order.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} An array of MessageId of the sent messages\n     * @see https://core.telegram.org/bots/api#copymessages\n     */\n\n  }, {\n    key: 'copyMessages',\n    value: function copyMessages(chatId, fromChatId, messageIds) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.from_chat_id = fromChatId;\n      form.message_ids = stringify(messageIds);\n      return this._request('copyMessages', { form: form });\n    }\n\n    /**\n     * Send photo\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} photo A file path or a Stream. Can\n     * also be a `file_id` previously uploaded\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendphoto\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendPhoto',\n    value: function sendPhoto(chatId, photo) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('photo', photo, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.photo = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendPhoto', opts);\n    }\n\n    /**\n    * Send audio\n    *\n    * **Your audio must be in the .MP3 or .M4A format.**\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {String|stream.Stream|Buffer} audio A file path, Stream or Buffer.\n    * Can also be a `file_id` previously uploaded.\n    * @param  {Object} [options] Additional Telegram query options\n    * @param  {Object} [fileOptions] Optional file related meta-data\n    * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n    * @see https://core.telegram.org/bots/api#sendaudio\n    * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendAudio',\n    value: function sendAudio(chatId, audio) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n\n      opts.qs.chat_id = chatId;\n\n      try {\n        var sendData = this._formatSendData('audio', audio, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.audio = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      return this._request('sendAudio', opts);\n    }\n\n    /**\n    * Send Document\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {String|stream.Stream|Buffer} doc A file path, Stream or Buffer.\n    * Can also be a `file_id` previously uploaded.\n    * @param  {Object} [options] Additional Telegram query options\n    * @param  {Object} [fileOptions] Optional file related meta-data\n    * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n    * @see https://core.telegram.org/bots/api#sendDocument\n    * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendDocument',\n    value: function sendDocument(chatId, doc) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('document', doc, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.document = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      return this._request('sendDocument', opts);\n    }\n\n    /**\n     * Use this method to send video files, **Telegram clients support mp4 videos** (other formats may be sent as Document).\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} video A file path or Stream.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendvideo\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendVideo',\n    value: function sendVideo(chatId, video) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('video', video, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.video = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVideo', opts);\n    }\n\n    /**\n     * Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} animation A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendanimation\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendAnimation',\n    value: function sendAnimation(chatId, animation) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('animation', animation, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.animation = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendAnimation', opts);\n    }\n\n    /**\n     * Send voice\n     *\n     * **Your audio must be in an .OGG file encoded with OPUS**, or in .MP3 format, or in .M4A format (other formats may be sent as Audio or Document)\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} voice A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendvoice\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendVoice',\n    value: function sendVoice(chatId, voice) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('voice', voice, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.voice = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVoice', opts);\n    }\n\n    /**\n     * Use this method to send video messages\n     * Telegram clients support **rounded square MPEG4 videos** of up to 1 minute long.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} videoNote A file path or Stream.\n     * Can also be a `file_id` previously uploaded.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @info The length parameter is actually optional. However, the API (at time of writing) requires you to always provide it until it is fixed.\n     * @see https://core.telegram.org/bots/api#sendvideonote\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n    */\n\n  }, {\n    key: 'sendVideoNote',\n    value: function sendVideoNote(chatId, videoNote) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('video_note', videoNote, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.video_note = sendData[1];\n        this._fixAddFileThumbnail(options, opts);\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendVideoNote', opts);\n    }\n\n    /**\n     * Use this method to send a group of photos or videos as an album.\n     *\n     * **Documents and audio files can be only grouped in an album with messages of the same type**\n     *\n     * If you wish to [specify file options](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files),\n     * add a `fileOptions` property to the target input in `media`.\n     *\n     * @param  {String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Array} media A JSON-serialized array describing photos and videos to be sent, must include 2–10 items\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, an array of the sent [Messages](https://core.telegram.org/bots/api#message)\n     * is returned.\n     * @see https://core.telegram.org/bots/api#sendmediagroup\n     * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n     */\n\n  }, {\n    key: 'sendMediaGroup',\n    value: function sendMediaGroup(chatId, media) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n\n      opts.formData = {};\n      var inputMedia = [];\n      var index = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var input = _step.value;\n\n          var payload = Object.assign({}, input);\n          delete payload.media;\n          delete payload.fileOptions;\n          try {\n            var attachName = String(index);\n\n            var _formatSendData4 = this._formatSendData(attachName, input.media, input.fileOptions),\n                _formatSendData5 = _slicedToArray(_formatSendData4, 2),\n                formData = _formatSendData5[0],\n                fileId = _formatSendData5[1];\n\n            if (formData) {\n              opts.formData[attachName] = formData[attachName];\n              payload.media = 'attach://' + attachName;\n            } else {\n              payload.media = fileId;\n            }\n          } catch (ex) {\n            return Promise.reject(ex);\n          }\n          inputMedia.push(payload);\n          index++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      opts.qs.media = stringify(inputMedia);\n\n      return this._request('sendMediaGroup', opts);\n    }\n\n    /**\n     * Send location.\n     * Use this method to send point on the map.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendlocation\n     */\n\n  }, {\n    key: 'sendLocation',\n    value: function sendLocation(chatId, latitude, longitude) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.latitude = latitude;\n      form.longitude = longitude;\n      return this._request('sendLocation', { form: form });\n    }\n\n    /**\n     * Use this method to edit live location messages sent by\n     * the bot or via the bot (for inline bots).\n     *\n     *  A location **can be edited until its live_period expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api#stopmessagelivelocation)**\n     *\n     * Note that you must provide one of chat_id, message_id, or\n     * inline_message_id in your request.\n     *\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n     * @see https://core.telegram.org/bots/api#editmessagelivelocation\n     */\n\n  }, {\n    key: 'editMessageLiveLocation',\n    value: function editMessageLiveLocation(latitude, longitude) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.latitude = latitude;\n      form.longitude = longitude;\n      return this._request('editMessageLiveLocation', { form: form });\n    }\n\n    /**\n     * Use this method to stop updating a live location message sent by\n     * the bot or via the bot (for inline bots) before live_period expires.\n     *\n     * Note that you must provide one of chat_id, message_id, or\n     * inline_message_id in your request.\n     *\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n     * @see https://core.telegram.org/bots/api#stopmessagelivelocation\n     */\n\n  }, {\n    key: 'stopMessageLiveLocation',\n    value: function stopMessageLiveLocation() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('stopMessageLiveLocation', { form: form });\n    }\n\n    /**\n     * Send venue.\n     * Use this method to send information about a venue.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Float} latitude Latitude of location\n     * @param  {Float} longitude Longitude of location\n     * @param  {String} title Name of the venue\n     * @param  {String} address Address of the venue\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned.\n     * @see https://core.telegram.org/bots/api#sendvenue\n     */\n\n  }, {\n    key: 'sendVenue',\n    value: function sendVenue(chatId, latitude, longitude, title, address) {\n      var form = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n      form.chat_id = chatId;\n      form.latitude = latitude;\n      form.longitude = longitude;\n      form.title = title;\n      form.address = address;\n      return this._request('sendVenue', { form: form });\n    }\n\n    /**\n     * Send contact.\n     * Use this method to send phone contacts.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} phoneNumber Contact's phone number\n     * @param  {String} firstName Contact's first name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendcontact\n     */\n\n  }, {\n    key: 'sendContact',\n    value: function sendContact(chatId, phoneNumber, firstName) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.phone_number = phoneNumber;\n      form.first_name = firstName;\n      return this._request('sendContact', { form: form });\n    }\n\n    /**\n     * Send poll.\n     * Use this method to send a native poll.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {String} question Poll question, 1-300 characters\n     * @param  {Array} pollOptions Poll options, between 2-10 options (only 1-100 characters each)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#sendpoll\n     */\n\n  }, {\n    key: 'sendPoll',\n    value: function sendPoll(chatId, question, pollOptions) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.question = question;\n      form.options = stringify(pollOptions);\n      return this._request('sendPoll', { form: form });\n    }\n\n    /**\n     * Send Dice\n     * Use this method to send an animated emoji that will display a random value.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n     * @see https://core.telegram.org/bots/api#senddice\n     */\n\n  }, {\n    key: 'sendDice',\n    value: function sendDice(chatId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('dice');\n        opts.formData = sendData[0];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendDice', opts);\n    }\n\n    /**\n     * Send chat action.\n     *\n     * Use this method when you need to tell the user that something is happening on the bot's side.\n     * **The status is set for 5 seconds or less** (when a message arrives from your bot, Telegram clients clear its typing status).\n     *\n     *  Action `typing` for [text messages](https://core.telegram.org/bots/api#sendmessage),\n     * `upload_photo` for [photos](https://core.telegram.org/bots/api#sendphoto), `record_video` or `upload_video` for [videos](https://core.telegram.org/bots/api#sendvideo),\n     * `record_voice` or `upload_voice` for [voice notes](https://core.telegram.org/bots/api#sendvoice), `upload_document` for [general files](https://core.telegram.org/bots/api#senddocument),\n     * `choose_sticker` for [stickers](https://core.telegram.org/bots/api#sendsticker), `find_location` for [location data](https://core.telegram.org/bots/api#sendlocation),\n     * `record_video_note` or `upload_video_note` for [video notes](https://core.telegram.org/bots/api#sendvideonote).\n     *\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} action Type of action to broadcast.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#sendchataction\n     */\n\n  }, {\n    key: 'sendChatAction',\n    value: function sendChatAction(chatId, action) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.action = action;\n      return this._request('sendChatAction', { form: form });\n    }\n\n    /**\n     * Use this method to change the chosen reactions on a message.\n     * - Service messages can't be reacted to.\n     * - Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel.\n     * - In albums, bots must react to the first message.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n     * @param  {Number} messageId  Unique identifier of the target message\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise<Boolean>} True on success\n     * @see https://core.telegram.org/bots/api#setmessagereaction\n     */\n\n  }, {\n    key: 'setMessageReaction',\n    value: function setMessageReaction(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      if (form.reaction) {\n        form.reaction = stringify(form.reaction);\n      }\n      return this._request('setMessageReaction', { form: form });\n    }\n\n    /**\n     * Use this method to get a list of profile pictures for a user.\n     * Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.\n     * This method has an [older, compatible signature][getUserProfilePhotos-v0.25.0]\n     * that is being deprecated.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise}  Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object\n     * @see https://core.telegram.org/bots/api#getuserprofilephotos\n     */\n\n  }, {\n    key: 'getUserProfilePhotos',\n    value: function getUserProfilePhotos(userId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      /* The older method signature was getUserProfilePhotos(userId, offset, limit).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0');\n        form = {\n          offset: arguments[1],\n          limit: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n      form.user_id = userId;\n      return this._request('getUserProfilePhotos', { form: form });\n    }\n\n    /**\n     * Get file.\n     * Use this method to get basic info about a file and prepare it for downloading.\n     *\n     * Attention: **link will be valid for 1 hour.**\n     *\n     * @param  {String} fileId  File identifier to get info about\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n     * @see https://core.telegram.org/bots/api#getfile\n     */\n\n  }, {\n    key: 'getFile',\n    value: function getFile(fileId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.file_id = fileId;\n      return this._request('getFile', { form: form });\n    }\n\n    /**\n      * Use this method to ban a user in a group, a supergroup or a channel.\n      * In the case of supergroups and channels, the user will not be able to\n      * return to the chat on their own using invite links, etc., unless unbanned first..\n      *\n      * The **bot must be an administrator in the group, supergroup or a channel** for this to work.\n      *\n      *\n      * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n      * @param  {Number} userId  Unique identifier of the target user\n      * @param  {Object} [options] Additional Telegram query options\n      * @return {Promise} True on success.\n      * @see https://core.telegram.org/bots/api#banchatmember\n      */\n\n  }, {\n    key: 'banChatMember',\n    value: function banChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('banChatMember', { form: form });\n    }\n\n    /**\n    * Use this method to unban a previously kicked user in a supergroup.\n    * The user will not return to the group automatically, but will be\n    * able to join via link, etc.\n    *\n    * The **bot must be an administrator** in the supergroup or channel for this to work.\n    *\n    * **By default**, this method guarantees that after the call the user is not a member of the chat, but will be able to join it.\n    * So **if the user is a member of the chat they will also be removed from the chat**. If you don't want this, use the parameter *only_if_banned*\n    *\n    * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId  Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unbanchatmember\n    */\n\n  }, {\n    key: 'unbanChatMember',\n    value: function unbanChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('unbanChatMember', { form: form });\n    }\n\n    /**\n    * Use this method to restrict a user in a supergroup.\n    * The bot **must be an administrator in the supergroup** for this to work\n    * and must have the appropriate admin rights. Pass True for all boolean parameters\n    * to lift restrictions from a user. Returns True on success.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#restrictchatmember\n    */\n\n  }, {\n    key: 'restrictChatMember',\n    value: function restrictChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('restrictChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to promote or demote a user in a supergroup or a channel.\n     * The bot **must be an administrator** in the chat for this to work\n     * and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success.\n     * @see https://core.telegram.org/bots/api#promotechatmember\n     */\n\n  }, {\n    key: 'promoteChatMember',\n    value: function promoteChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('promoteChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to set a custom title for an administrator in a supergroup promoted by the bot.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId Unique identifier of the target user\n     * @param  {String} customTitle New custom title for the administrator; 0-16 characters, emoji are not allowed\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n     */\n\n  }, {\n    key: 'setChatAdministratorCustomTitle',\n    value: function setChatAdministratorCustomTitle(chatId, userId, customTitle) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      form.custom_title = customTitle;\n      return this._request('setChatAdministratorCustomTitle', { form: form });\n    }\n\n    /**\n     * Use this method to ban a channel chat in a supergroup or a channel.\n     *\n     * Until the chat is [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of any of their channels.\n     * The bot **must be an administrator in the supergroup or channel** for this to work and must have the appropriate administrator rights\n     *\n     * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} senderChatId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success.\n     * @see https://core.telegram.org/bots/api#banchatsenderchat\n     */\n\n  }, {\n    key: 'banChatSenderChat',\n    value: function banChatSenderChat(chatId, senderChatId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sender_chat_id = senderChatId;\n      return this._request('banChatSenderChat', { form: form });\n    }\n\n    /**\n    * Use this method to unban a previously banned channel chat in a supergroup or channel.\n    *\n    * The bot **must be an administrator** for this to work and must have the appropriate administrator rights.\n    *\n    * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} senderChatId Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unbanchatsenderchat\n    */\n\n  }, {\n    key: 'unbanChatSenderChat',\n    value: function unbanChatSenderChat(chatId, senderChatId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sender_chat_id = senderChatId;\n      return this._request('unbanChatSenderChat', { form: form });\n    }\n\n    /**\n     * Use this method to set default chat permissions for all members.\n     *\n     * The bot **must be an administrator in the group or a supergroup** for this to\n     * work and **must have the `can_restrict_members` admin rights.**\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Array} chatPermissions New default chat permissions\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatpermissions\n     */\n\n  }, {\n    key: 'setChatPermissions',\n    value: function setChatPermissions(chatId, chatPermissions) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.permissions = stringify(chatPermissions);\n      return this._request('setChatPermissions', { form: form });\n    }\n\n    /**\n     * Use this method to generate a new primary invite link for a chat. **Any previously generated primary link is revoked**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Exported invite link as String on success.\n     * @see https://core.telegram.org/bots/api#exportchatinvitelink\n     */\n\n  }, {\n    key: 'exportChatInviteLink',\n    value: function exportChatInviteLink(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('exportChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to create an additional invite link for a chat.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * The link generated with this method can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink)\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Object} The new invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#createchatinvitelink\n     */\n\n  }, {\n    key: 'createChatInviteLink',\n    value: function createChatInviteLink(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('createChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to edit a non-primary invite link created by the bot.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} inviteLink Text with the invite link to edit\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#editchatinvitelink\n     */\n\n  }, {\n    key: 'editChatInviteLink',\n    value: function editChatInviteLink(chatId, inviteLink) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.invite_link = inviteLink;\n      return this._request('editChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to revoke an invite link created by the bot.\n     * Note: If the primary link is revoked, a new link is automatically generated\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} inviteLink The invite link to revoke\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} The revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n     * @see https://core.telegram.org/bots/api#revokechatinvitelink\n     */\n\n  }, {\n    key: 'revokeChatInviteLink',\n    value: function revokeChatInviteLink(chatId, inviteLink) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.invite_link = inviteLink;\n      return this._request('revokeChatInviteLink', { form: form });\n    }\n\n    /**\n     * Use this method to approve a chat join request.\n     *\n     * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right.**\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#approvechatjoinrequest\n     */\n\n  }, {\n    key: 'approveChatJoinRequest',\n    value: function approveChatJoinRequest(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('approveChatJoinRequest', { form: form });\n    }\n\n    /**\n     * Use this method to decline a chat join request.\n     *\n     * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right**.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#declinechatjoinrequest\n     */\n\n  }, {\n    key: 'declineChatJoinRequest',\n    value: function declineChatJoinRequest(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('declineChatJoinRequest', { form: form });\n    }\n\n    /**\n     * Use this method to set a new profile photo for the chat. **Photos can't be changed for private chats**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {stream.Stream|Buffer} photo A file path or a Stream.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatphoto\n     */\n\n  }, {\n    key: 'setChatPhoto',\n    value: function setChatPhoto(chatId, photo) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('photo', photo, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.photo = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('setChatPhoto', opts);\n    }\n\n    /**\n    * Use this method to delete a chat photo. **Photos can't be changed for private chats**.\n    *\n    * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#deletechatphoto\n    */\n\n  }, {\n    key: 'deleteChatPhoto',\n    value: function deleteChatPhoto(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('deleteChatPhoto', { form: form });\n    }\n\n    /**\n     * Use this method to change the title of a chat. **Titles can't be changed for private chats**.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} title New chat title, 1-255 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchattitle\n     */\n\n  }, {\n    key: 'setChatTitle',\n    value: function setChatTitle(chatId, title) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.title = title;\n      return this._request('setChatTitle', { form: form });\n    }\n\n    /**\n     * Use this method to change the description of a group, a supergroup or a channel.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} description New chat title, 0-255 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatdescription\n     */\n\n  }, {\n    key: 'setChatDescription',\n    value: function setChatDescription(chatId, description) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.description = description;\n      return this._request('setChatDescription', { form: form });\n    }\n\n    /**\n     * Use this method to pin a message in a supergroup.\n     *\n     * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n     * right in a supergroup or `can_edit_messages` administrator right in a channel.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Number} messageId Identifier of a message to pin\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#pinchatmessage\n     */\n\n  }, {\n    key: 'pinChatMessage',\n    value: function pinChatMessage(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      return this._request('pinChatMessage', { form: form });\n    }\n\n    /**\n     * Use this method to remove a message from the list of pinned messages in a chat\n     *\n     * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n     * right in a supergroup or `can_edit_messages` administrator right in a channel.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinchatmessage\n     */\n\n  }, {\n    key: 'unpinChatMessage',\n    value: function unpinChatMessage(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unpinChatMessage', { form: form });\n    }\n\n    /**\n    * Use this method to clear the list of pinned messages in a chat.\n    *\n    * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n    * right in a supergroup or `can_edit_messages` administrator right in a channel.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#unpinallchatmessages\n    */\n\n  }, {\n    key: 'unpinAllChatMessages',\n    value: function unpinAllChatMessages(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unpinAllChatMessages', { form: form });\n    }\n\n    /**\n     * Use this method for your bot to leave a group, supergroup or channel\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#leavechat\n     */\n\n  }, {\n    key: 'leaveChat',\n    value: function leaveChat(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('leaveChat', { form: form });\n    }\n\n    /**\n     * Use this method to get up to date information about the chat\n     * (current name of the user for one-on-one conversations, current\n     * username of a user, group or channel, etc.).\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`) or channel\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success\n     * @see https://core.telegram.org/bots/api#getchat\n     */\n\n  }, {\n    key: 'getChat',\n    value: function getChat(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChat', { form: form });\n    }\n\n    /**\n     * Use this method to get a list of administrators in a chat\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns an Array of [ChatMember](https://core.telegram.org/bots/api#chatmember) objects that contains information about all chat administrators except other bots.\n     * If the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned\n     * @see https://core.telegram.org/bots/api#getchatadministrators\n     */\n\n  }, {\n    key: 'getChatAdministrators',\n    value: function getChatAdministrators(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChatAdministrators', { form: form });\n    }\n\n    /**\n    * Use this method to get the number of members in a chat.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} Int on success\n    * @see https://core.telegram.org/bots/api#getchatmembercount\n    */\n\n  }, {\n    key: 'getChatMemberCount',\n    value: function getChatMemberCount(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getChatMemberCount', { form: form });\n    }\n\n    /**\n     * Use this method to get information about a member of a chat.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatMember](https://core.telegram.org/bots/api#chatmember) object on success\n     * @see https://core.telegram.org/bots/api#getchatmember\n     */\n\n  }, {\n    key: 'getChatMember',\n    value: function getChatMember(chatId, userId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.user_id = userId;\n      return this._request('getChatMember', { form: form });\n    }\n\n    /**\n     * Use this method to set a new group sticker set for a supergroup.\n     *\n     * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n     *\n     * **Note:** Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {String} stickerSetName Name of the sticker set to be set as the group sticker set\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatstickerset\n     */\n\n  }, {\n    key: 'setChatStickerSet',\n    value: function setChatStickerSet(chatId, stickerSetName) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.sticker_set_name = stickerSetName;\n      return this._request('setChatStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to delete a group sticker set from a supergroup.\n     *\n     * Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletechatstickerset\n     */\n\n  }, {\n    key: 'deleteChatStickerSet',\n    value: function deleteChatStickerSet(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('deleteChatStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects\n     * @see https://core.telegram.org/bots/api#getforumtopiciconstickers\n     */\n\n  }, {\n    key: 'getForumTopicIconStickers',\n    value: function getForumTopicIconStickers(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('getForumTopicIconStickers', { form: form });\n    }\n\n    /**\n     * Use this method to create a topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n     *\n     * Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api#forumtopic) object.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param  {String} name Topic name, 1-128 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @see https://core.telegram.org/bots/api#createforumtopic\n     */\n\n  }, {\n    key: 'createForumTopic',\n    value: function createForumTopic(chatId, name) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.name = name;\n      return this._request('createForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to edit name and icon of a topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#editforumtopic\n     */\n\n  }, {\n    key: 'editForumTopic',\n    value: function editForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('editForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to close an open topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#closeforumtopic\n     */\n\n  }, {\n    key: 'closeForumTopic',\n    value: function closeForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('closeForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to reopen a closed topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#reopenforumtopic\n     */\n\n  }, {\n    key: 'reopenForumTopic',\n    value: function reopenForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('reopenForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to delete a forum topic along with all its messages in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deleteforumtopic\n     */\n\n  }, {\n    key: 'deleteForumTopic',\n    value: function deleteForumTopic(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('deleteForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to clear the list of pinned messages in a forum topic.\n     * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinallforumtopicmessages\n     */\n\n  }, {\n    key: 'unpinAllForumTopicMessages',\n    value: function unpinAllForumTopicMessages(chatId, messageThreadId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_thread_id = messageThreadId;\n      return this._request('unpinAllForumTopicMessages', { form: form });\n    }\n\n    /**\n    * Use this method to edit the name of the 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {String} name New topic name, 1-128 characters\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#editgeneralforumtopic\n    */\n\n  }, {\n    key: 'editGeneralForumTopic',\n    value: function editGeneralForumTopic(chatId, name) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.name = name;\n      return this._request('editGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to close an open 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#closegeneralforumtopic\n    */\n\n  }, {\n    key: 'closeGeneralForumTopic',\n    value: function closeGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('closeGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to reopen a closed 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically unhidden if it was hidden.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#reopengeneralforumtopic\n    */\n\n  }, {\n    key: 'reopenGeneralForumTopic',\n    value: function reopenGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('reopenGeneralForumTopic', { form: form });\n    }\n\n    /**\n    * Use this method to hide the 'General' topic in a forum supergroup chat.\n    * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n    * The topic will be automatically closed if it was open.\n    *\n    * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n    * @param {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#hidegeneralforumtopic\n    */\n\n  }, {\n    key: 'hideGeneralForumTopic',\n    value: function hideGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('hideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to unhide the 'General' topic in a forum supergroup chat.\n     * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unhidegeneralforumtopic\n     */\n\n  }, {\n    key: 'unhideGeneralForumTopic',\n    value: function unhideGeneralForumTopic(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unhideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to clear the list of pinned messages in a General forum topic.\n     * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n     *\n     * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n     * @param {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages\n     */\n\n  }, {\n    key: 'unpinAllGeneralForumTopicMessages',\n    value: function unpinAllGeneralForumTopicMessages(chatId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.chat_id = chatId;\n      return this._request('unhideGeneralForumTopic', { form: form });\n    }\n\n    /**\n     * Use this method to send answers to callback queries sent from\n     * [inline keyboards](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating).\n     *\n     * The answer will be displayed to the user as a notification at the top of the chat screen or as an alert.\n     *\n     * This method has **older, compatible signatures ([1][answerCallbackQuery-v0.27.1])([2][answerCallbackQuery-v0.29.0])**\n     * that are being deprecated.\n     *\n     * @param  {String} callbackQueryId Unique identifier for the query to be answered\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#answercallbackquery\n     */\n\n  }, {\n    key: 'answerCallbackQuery',\n    value: function answerCallbackQuery(callbackQueryId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      /* The older method signature (in/before v0.27.1) was answerCallbackQuery(callbackQueryId, text, showAlert).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library */\n      if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) !== 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1');\n        form = {\n          callback_query_id: arguments[0],\n          text: arguments[1],\n          show_alert: arguments[2]\n        };\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      }\n      /* The older method signature (in/before v0.29.0) was answerCallbackQuery([options]).\n       * We need to ensure backwards-compatibility while maintaining\n       * consistency of the method signatures throughout the library. */\n      if ((typeof callbackQueryId === 'undefined' ? 'undefined' : _typeof(callbackQueryId)) === 'object') {\n        /* eslint-disable no-param-reassign, prefer-rest-params */\n        deprecate('The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0');\n        form = callbackQueryId;\n        /* eslint-enable no-param-reassign, prefer-rest-params */\n      } else {\n        form.callback_query_id = callbackQueryId;\n      }\n      return this._request('answerCallbackQuery', { form: form });\n    }\n\n    /**\n     * Use this method to get the list of boosts added to a chat by a use.\n     * Requires administrator rights in the chat\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {Number} user_id Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object\n     * @see https://core.telegram.org/bots/api#getuserchatboosts\n     */\n\n  }, {\n    key: 'getUserChatBoosts',\n    value: function getUserChatBoosts(chatId, pollId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = pollId;\n      return this._request('getUserChatBoosts', { form: form });\n    }\n\n    /**\n     * Use this method to get information about the connection of the bot with a business account\n     *\n     * @param  {Number|String} businessConnectionId  Unique identifier for the group/channel\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object\n     * @see https://core.telegram.org/bots/api#getbusinessconnection\n     */\n\n  }, {\n    key: 'getBusinessConnection',\n    value: function getBusinessConnection(businessConnectionId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.business_connection_id = businessConnectionId;\n      return this._request('getBusinessConnection', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of the bot's commands.\n     *\n     * See https://core.telegram.org/bots#commands for more details about bot commands\n     *\n     * @param  {Array} commands  List of bot commands to be set as the list of the [bot's commands](https://core.telegram.org/bots/api#botcommand). At most 100 commands can be specified.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmycommands\n     */\n\n  }, {\n    key: 'setMyCommands',\n    value: function setMyCommands(commands) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.commands = stringify(commands);\n\n      if (form.scope) {\n        form.scope = stringify(form.scope);\n      }\n\n      return this._request('setMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to delete the list of the bot's commands for the given scope and user language.\n     *\n     *  After deletion, [higher level commands](https://core.telegram.org/bots/api#determining-list-of-commands) will be shown to affected users.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletemycommands\n     */\n\n  }, {\n    key: 'deleteMyCommands',\n    value: function deleteMyCommands() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('deleteMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to get the current list of the bot's commands for the given scope and user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) on success. If commands aren't set, an empty list is returned.\n     * @see https://core.telegram.org/bots/api#getmycommands\n     */\n\n  }, {\n    key: 'getMyCommands',\n    value: function getMyCommands() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (form.scope) {\n        form.scope = stringify(form.scope);\n      }\n      return this._request('getMyCommands', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's name.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmyname\n     */\n\n  }, {\n    key: 'setMyName',\n    value: function setMyName() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyName', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot name for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [BotName](https://core.telegram.org/bots/api#botname) on success\n     * @see https://core.telegram.org/bots/api#getmyname\n     */\n\n  }, {\n    key: 'getMyName',\n    value: function getMyName() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyName', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty.\n     *\n     * Returns True on success.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setmydescription\n     */\n\n  }, {\n    key: 'setMyDescription',\n    value: function setMyDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyDescription', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot description for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.\n     * @see https://core.telegram.org/bots/api#getmydescription\n     */\n\n  }, {\n    key: 'getMyDescription',\n    value: function getMyDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyDescription', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's short description, which is shown on the bot's profile page\n     * and is sent together with the link when users share the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns True on success.\n     * @see https://core.telegram.org/bots/api#setmyshortdescription\n     */\n\n  }, {\n    key: 'setMyShortDescription',\n    value: function setMyShortDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyShortDescription', { form: form });\n    }\n\n    /**\n     * Use this method to get the current bot short description for the given user language.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Returns [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.\n     * @see https://core.telegram.org/bots/api#getmyshortdescription\n     */\n\n  }, {\n    key: 'getMyShortDescription',\n    value: function getMyShortDescription() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyShortDescription', { form: form });\n    }\n\n    /**\n     * Use this method to change the bot's menu button in a private chat, or the default menu button.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setchatmenubutton\n     */\n\n  }, {\n    key: 'setChatMenuButton',\n    value: function setChatMenuButton() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setChatMenuButton', { form: form });\n    }\n\n    /**\n     * Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [MenuButton](https://core.telegram.org/bots/api#menubutton) on success\n     * @see https://core.telegram.org/bots/api#getchatmenubutton\n     */\n\n  }, {\n    key: 'getChatMenuButton',\n    value: function getChatMenuButton() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getChatMenuButton', { form: form });\n    }\n\n    /**\n     * Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels.\n     *\n     * These rights will be suggested to users, but they are are free to modify the list before adding the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#getchatmenubutton\n     */\n\n  }, {\n    key: 'setMyDefaultAdministratorRights',\n    value: function setMyDefaultAdministratorRights() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('setMyDefaultAdministratorRights', { form: form });\n    }\n\n    /**\n     * Use this method to get the current default administrator rights of the bot.\n     *\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success\n     * @see https://core.telegram.org/bots/api#getmydefaultadministratorrights\n     */\n\n  }, {\n    key: 'getMyDefaultAdministratorRights',\n    value: function getMyDefaultAdministratorRights() {\n      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this._request('getMyDefaultAdministratorRights', { form: form });\n    }\n\n    /**\n     * Use this method to edit text or [game](https://core.telegram.org/bots/api#games) messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: that **you must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {String} text  New text of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagetext\n     */\n\n  }, {\n    key: 'editMessageText',\n    value: function editMessageText(text) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.text = text;\n      return this._request('editMessageText', { form: form });\n    }\n\n    /**\n     * Use this method to edit captions of messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {String} caption  New caption of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagecaption\n     */\n\n  }, {\n    key: 'editMessageCaption',\n    value: function editMessageCaption(caption) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.caption = caption;\n      return this._request('editMessageCaption', { form: form });\n    }\n\n    /**\n     * Use this method to edit animation, audio, document, photo, or video messages.\n     *\n     * If a message is a part of a message album, then it can be edited only to a photo or a video.\n     *\n     * Otherwise, message type can be changed arbitrarily. When inline message is edited, new file can't be uploaded.\n     * Use previously uploaded file via its file_id or specify a URL.\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {Object} media  A JSON-serialized object for a new media content of the message\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagemedia\n     */\n\n  }, {\n    key: 'editMessageMedia',\n    value: function editMessageMedia(media) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var regexAttach = /attach:\\/\\/.+/;\n\n      if (typeof media.media === 'string' && regexAttach.test(media.media)) {\n        var opts = {\n          qs: form\n        };\n\n        opts.formData = {};\n\n        var payload = Object.assign({}, media);\n        delete payload.media;\n\n        try {\n          var attachName = String(0);\n\n          var _formatSendData6 = this._formatSendData(attachName, media.media.replace('attach://', ''), media.fileOptions),\n              _formatSendData7 = _slicedToArray(_formatSendData6, 1),\n              formData = _formatSendData7[0];\n\n          if (formData) {\n            opts.formData[attachName] = formData[attachName];\n            payload.media = 'attach://' + attachName;\n          } else {\n            throw new errors.FatalError('Failed to process the replacement action for your ' + media.type);\n          }\n        } catch (ex) {\n          return Promise.reject(ex);\n        }\n\n        opts.qs.media = stringify(payload);\n\n        return this._request('editMessageMedia', opts);\n      }\n\n      form.media = stringify(media);\n\n      return this._request('editMessageMedia', { form: form });\n    }\n\n    /**\n     * Use this method to edit only the reply markup of messages sent by the bot or via the bot (for inline bots).\n     *\n     * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n     *\n     * @param  {Object} replyMarkup  A JSON-serialized object for an inline keyboard.\n     * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n     * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#editmessagetext\n     */\n\n  }, {\n    key: 'editMessageReplyMarkup',\n    value: function editMessageReplyMarkup(replyMarkup) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.reply_markup = replyMarkup;\n      return this._request('editMessageReplyMarkup', { form: form });\n    }\n\n    /**\n     * Use this method to stop a poll which was sent by the bot.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the group/channel\n     * @param  {Number} pollId Identifier of the original message with the poll\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the stopped [Poll](https://core.telegram.org/bots/api#poll) is returned\n     * @see https://core.telegram.org/bots/api#stoppoll\n     */\n\n  }, {\n    key: 'stopPoll',\n    value: function stopPoll(chatId, pollId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = pollId;\n      return this._request('stopPoll', { form: form });\n    }\n\n    /**\n     * Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,\n     * or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers.\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String|stream.Stream|Buffer} sticker A file path, Stream or Buffer.\n     * Can also be a `file_id` previously uploaded. Stickers are WebP format files.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendsticker\n     */\n\n  }, {\n    key: 'sendSticker',\n    value: function sendSticker(chatId, sticker) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.chat_id = chatId;\n      try {\n        var sendData = this._formatSendData('sticker', sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('sendSticker', opts);\n    }\n\n    /**\n     * Use this method to get a sticker set.\n     *\n     * @param  {String} name Name of the sticker set\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [StickerSet](https://core.telegram.org/bots/api#stickerset) object is returned\n     * @see https://core.telegram.org/bots/api#getstickerset\n     */\n\n  }, {\n    key: 'getStickerSet',\n    value: function getStickerSet(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('getStickerSet', { form: form });\n    }\n\n    /**\n     * Use this method to get information about custom emoji stickers by their identifiers.\n     *\n     * @param  {Array} custom_emoji_ids List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.\n     * @see https://core.telegram.org/bots/api#getcustomemojistickers\n     */\n\n  }, {\n    key: 'getCustomEmojiStickers',\n    value: function getCustomEmojiStickers(customEmojiIds) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.custom_emoji_ids = stringify(customEmojiIds);\n      return this._request('getCustomEmojiStickers', { form: form });\n    }\n\n    /**\n     * Use this method to upload a file with a sticker for later use in *createNewStickerSet* and *addStickerToSet* methods (can be used multiple\n     * times).\n     *\n     * @param  {Number} userId User identifier of sticker file owner\n     * @param  {String|stream.Stream|Buffer} sticker A file path or a Stream with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. Can also be a `file_id` previously uploaded.\n     * @param {String} stickerFormat Allow values:  `static`, `animated` or `video`\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n     * @see https://core.telegram.org/bots/api#uploadstickerfile\n     */\n\n  }, {\n    key: 'uploadStickerFile',\n    value: function uploadStickerFile(userId, sticker) {\n      var stickerFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'static';\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.sticker_format = stickerFormat;\n\n      try {\n        var sendData = this._formatSendData('sticker', sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('uploadStickerFile', opts);\n    }\n\n    /**\n     * Use this method to create new sticker set owned by a user.\n     *\n     * The bot will be able to edit the created sticker set.\n     *\n     * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n     *\n     * @param  {Number} userId User identifier of created sticker set owner\n     * @param  {String} name Short name of sticker set, to be used in `t.me/addstickers/` URLs (e.g.,   *\"animals\"*). Can contain only english letters, digits and underscores.\n     *  Must begin with a letter, can't contain consecutive underscores and must end in `\"_by_<bot_username>\"`. `<bot_username>` is case insensitive. 1-64 characters.\n     * @param  {String} title Sticker set title, 1-64 characters\n     * @param  {String|stream.Stream|Buffer} pngSticker Png image with the sticker, must be up to 512 kilobytes in size,\n     *  dimensions must not exceed 512px, and either width or height must be exactly 512px.\n     * @param  {String} emojis One or more emoji corresponding to the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#createnewstickerset\n     */\n\n  }, {\n    key: 'createNewStickerSet',\n    value: function createNewStickerSet(userId, name, title, pngSticker, emojis) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.title = title;\n      opts.qs.emojis = emojis;\n      opts.qs.mask_position = stringify(options.mask_position);\n      try {\n        var sendData = this._formatSendData('png_sticker', pngSticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.png_sticker = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('createNewStickerSet', opts);\n    }\n\n    /**\n     * Use this method to add a new sticker to a set created by the bot.\n     *\n     * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n     *\n     * Animated stickers can be added to animated sticker sets and only to them\n     *\n     * Note:\n     * - Emoji sticker sets can have up to 200 sticker\n     * - Static or Animated sticker sets can have up to 120 stickers\n     *\n     * @param  {Number} userId User identifier of sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String|stream.Stream|Buffer} sticker Png image with the sticker (must be up to 512 kilobytes in size,\n     * dimensions must not exceed 512px, and either width or height must be exactly 512px, [TGS animation](https://core.telegram.org/stickers#animated-sticker-requirements)\n     * with the sticker or [WEBM video](https://core.telegram.org/stickers#video-sticker-requirements) with the sticker.\n     * @param  {String} emojis One or more emoji corresponding to the sticker\n     * @param  {String} stickerType Allow values: `png_sticker`, `tgs_sticker`, or `webm_sticker`.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise}  True on success\n     * @see https://core.telegram.org/bots/api#addstickertoset\n     */\n\n  }, {\n    key: 'addStickerToSet',\n    value: function addStickerToSet(userId, name, sticker, emojis) {\n      var stickerType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'png_sticker';\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n      var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.emojis = emojis;\n      opts.qs.mask_position = stringify(options.mask_position);\n\n      if (typeof stickerType !== 'string' || ['png_sticker', 'tgs_sticker', 'webm_sticker'].indexOf(stickerType) === -1) {\n        return Promise.reject(new Error('stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker'));\n      }\n\n      try {\n        var sendData = this._formatSendData(stickerType, sticker, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs[stickerType] = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('addStickerToSet', opts);\n    }\n\n    /**\n     * Use this method to move a sticker in a set created by the bot to a specific position.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Number} position New sticker position in the set, zero-based\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickerpositioninset\n     */\n\n  }, {\n    key: 'setStickerPositionInSet',\n    value: function setStickerPositionInSet(sticker, position) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.sticker = sticker;\n      form.position = position;\n      return this._request('setStickerPositionInSet', { form: form });\n    }\n\n    /**\n     * Use this method to delete a sticker from a set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletestickerfromset\n     * @todo Add tests for this method!\n     */\n\n  }, {\n    key: 'deleteStickerFromSet',\n    value: function deleteStickerFromSet(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      return this._request('deleteStickerFromSet', { form: form });\n    }\n\n    /**\n     * Use this method to replace an existing sticker in a sticker set with a new one\n     *\n     * @param  {Number} user_id User identifier of the sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#replacestickerinset\n     * @todo Add tests for this method!\n     */\n\n  }, {\n    key: 'replaceStickerInSet',\n    value: function replaceStickerInSet(userId, name, oldSticker) {\n      var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      form.user_id = userId;\n      form.name = name;\n      form.old_sticker = oldSticker;\n      return this._request('deleteStickerFromSet', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of emoji assigned to a regular or custom emoji sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param { Array } emojiList A JSON-serialized list of 1-20 emoji associated with the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickeremojilist\n     */\n\n  }, {\n    key: 'setStickerEmojiList',\n    value: function setStickerEmojiList(sticker, emojiList) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.sticker = sticker;\n      form.emoji_list = stringify(emojiList);\n      return this._request('setStickerEmojiList', { form: form });\n    }\n\n    /**\n     * Use this method to change the list of emoji assigned to a `regular` or `custom emoji` sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickerkeywords\n     */\n\n  }, {\n    key: 'setStickerKeywords',\n    value: function setStickerKeywords(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      if (form.keywords) {\n        form.keywords = stringify(form.keywords);\n      }\n      return this._request('setStickerKeywords', { form: form });\n    }\n\n    /**\n     * Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of a mask sticker.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} sticker File identifier of the sticker\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickermaskposition\n     */\n\n  }, {\n    key: 'setStickerMaskPosition',\n    value: function setStickerMaskPosition(sticker) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.sticker = sticker;\n      if (form.mask_position) {\n        form.mask_position = stringify(form.mask_position);\n      }\n      return this._request('setStickerMaskPosition', { form: form });\n    }\n\n    /**\n     * Use this method to set the title of a created sticker set.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {String} title Sticker set title, 1-64 characters\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickersettitle\n     */\n\n  }, {\n    key: 'setStickerSetTitle',\n    value: function setStickerSetTitle(name, title) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.name = name;\n      form.title = title;\n      return this._request('setStickerSetTitle', { form: form });\n    }\n\n    /**\n     * Use this method to add a thumb to a set created by the bot.\n     *\n     * Animated thumbnails can be set for animated sticker sets only. Video thumbnails can be set only for video sticker sets only\n     *\n     * @param  {Number} userId User identifier of sticker set owner\n     * @param  {String} name Sticker set name\n     * @param  {String|stream.Stream|Buffer} thumbnail A .WEBP or .PNG image with the thumbnail,\n     * must be up to 128 kilobytes in size and have width and height exactly 100px,\n     * a TGS animation with the thumbnail up to 32 kilobytes in size or a WEBM video with the thumbnail up to 32 kilobytes in size.\n     *\n     * Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram\n     * to get a file from the Internet, or upload a new one. Animated sticker set thumbnails can't be uploaded via HTTP URL.\n     * @param  {Object} [options] Additional Telegram query options\n     * @param  {Object} [fileOptions] Optional file related meta-data\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setstickersetthumbnail\n     */\n\n  }, {\n    key: 'setStickerSetThumbnail',\n    value: function setStickerSetThumbnail(userId, name, thumbnail) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      var opts = {\n        qs: options\n      };\n      opts.qs.user_id = userId;\n      opts.qs.name = name;\n      opts.qs.mask_position = stringify(options.mask_position);\n      try {\n        var sendData = this._formatSendData('thumbnail', thumbnail, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.thumbnail = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      return this._request('setStickerSetThumbnail', opts);\n    }\n\n    /**\n     * Use this method to set the thumbnail of a custom emoji sticker set.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail\n     */\n\n  }, {\n    key: 'setCustomEmojiStickerSetThumbnail',\n    value: function setCustomEmojiStickerSetThumbnail(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('setCustomEmojiStickerSetThumbnail', { form: form });\n    }\n\n    /**\n     * Use this method to delete a sticker set that was created by the bot.\n     *\n     * The sticker must belong to a sticker set created by the bot.\n     *\n     * @param  {String} name Sticker set name\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} True on success\n     * @see https://core.telegram.org/bots/api#deletestickerset\n     */\n\n  }, {\n    key: 'deleteStickerSet',\n    value: function deleteStickerSet(name) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.name = name;\n      return this._request('deleteStickerSet', { form: form });\n    }\n\n    /**\n     * Send answers to an inline query.\n     *\n     * Note: No more than 50 results per query are allowed.\n     *\n     * @param  {String} inlineQueryId Unique identifier of the query\n     * @param  {InlineQueryResult[]} results An array of results for the inline query\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, True is returned\n     * @see https://core.telegram.org/bots/api#answerinlinequery\n     */\n\n  }, {\n    key: 'answerInlineQuery',\n    value: function answerInlineQuery(inlineQueryId, results) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.inline_query_id = inlineQueryId;\n      form.results = stringify(results);\n      return this._request('answerInlineQuery', { form: form });\n    }\n\n    /**\n     * Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps)\n     * and send a corresponding message on behalf of the user to the chat from which the query originated.\n     *\n     * @param  {String} webAppQueryId Unique identifier for the query to be answered\n     * @param  {InlineQueryResult} result object that represents one result of an inline query\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, a [SentWebAppMessage](https://core.telegram.org/bots/api#sentwebappmessage) object is returned\n     * @see https://core.telegram.org/bots/api#answerwebappquery\n     */\n\n  }, {\n    key: 'answerWebAppQuery',\n    value: function answerWebAppQuery(webAppQueryId, result) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.web_app_query_id = webAppQueryId;\n      form.result = stringify(result);\n      return this._request('answerWebAppQuery', { form: form });\n    }\n\n    /**\n     * Use this method to send an invoice.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} title Product name, 1-32 characters\n     * @param  {String} description Product description, 1-255 characters\n     * @param  {String} payload Bot defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.\n     * @param  {String} providerToken Payments provider token, obtained via `@BotFather`\n     * @param  {String} currency Three-letter ISO 4217 currency code\n     * @param  {Array} prices Breakdown of prices\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendinvoice\n     */\n\n  }, {\n    key: 'sendInvoice',\n    value: function sendInvoice(chatId, title, description, payload, providerToken, currency, prices) {\n      var form = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n\n      form.chat_id = chatId;\n      form.title = title;\n      form.description = description;\n      form.payload = payload;\n      form.provider_token = providerToken;\n      form.currency = currency;\n      form.prices = stringify(prices);\n      form.provider_data = stringify(form.provider_data);\n      if (form.suggested_tip_amounts) {\n        form.suggested_tip_amounts = stringify(form.suggested_tip_amounts);\n      }\n      return this._request('sendInvoice', { form: form });\n    }\n\n    /**\n    * Use this method to create a link for an invoice.\n    *\n    * @param {String} title Product name, 1-32 characters\n    * @param {String} description Product description, 1-255 characters\n    * @param {String} payload Bot defined invoice payload\n    * @param {String} providerToken Payment provider token\n    * @param {String} currency Three-letter ISO 4217 currency code\n    * @param {Array} prices Breakdown of prices\n    * @param {Object} [options] Additional Telegram query options\n    * @returns {Promise} The created invoice link as String on success.\n    * @see https://core.telegram.org/bots/api#createinvoicelink\n    */\n\n  }, {\n    key: 'createInvoiceLink',\n    value: function createInvoiceLink(title, description, payload, providerToken, currency, prices) {\n      var form = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n      form.title = title;\n      form.description = description;\n      form.payload = payload;\n      form.provider_token = providerToken;\n      form.currency = currency;\n      form.prices = stringify(prices);\n      return this._request('createInvoiceLink', { form: form });\n    }\n\n    /**\n    * Use this method to reply to shipping queries.\n    *\n    * If you sent an invoice requesting a shipping address and the parameter is_flexible was specified,\n    * the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a shipping_query field to the bot\n    *\n    * @param  {String} shippingQueryId  Unique identifier for the query to be answered\n    * @param  {Boolean} ok Specify if delivery of the product is possible\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} On success, True is returned\n    * @see https://core.telegram.org/bots/api#answershippingquery\n    */\n\n  }, {\n    key: 'answerShippingQuery',\n    value: function answerShippingQuery(shippingQueryId, ok) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.shipping_query_id = shippingQueryId;\n      form.ok = ok;\n      form.shipping_options = stringify(form.shipping_options);\n      return this._request('answerShippingQuery', { form: form });\n    }\n\n    /**\n     * Use this method to respond to such pre-checkout queries\n     *\n     * Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of\n     * an [Update](https://core.telegram.org/bots/api#update) with the field *pre_checkout_query*.\n     *\n     * **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.\n     *\n     * @param  {String} preCheckoutQueryId  Unique identifier for the query to be answered\n     * @param  {Boolean} ok Specify if every order details are ok\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, True is returned\n     * @see https://core.telegram.org/bots/api#answerprecheckoutquery\n     */\n\n  }, {\n    key: 'answerPreCheckoutQuery',\n    value: function answerPreCheckoutQuery(preCheckoutQueryId, ok) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.pre_checkout_query_id = preCheckoutQueryId;\n      form.ok = ok;\n      return this._request('answerPreCheckoutQuery', { form: form });\n    }\n\n    /**\n     * Use this method to send a game.\n     *\n     * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n     * @param  {String} gameShortName name of the game to be sent. Set up your games via `@BotFather`.\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n     * @see https://core.telegram.org/bots/api#sendgame\n     */\n\n  }, {\n    key: 'sendGame',\n    value: function sendGame(chatId, gameShortName) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.game_short_name = gameShortName;\n      return this._request('sendGame', { form: form });\n    }\n\n    /**\n     * Use this method to set the score of the specified user in a game message.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Number} score New score value, must be non-negative\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n     * @see https://core.telegram.org/bots/api#setgamescore\n     */\n\n  }, {\n    key: 'setGameScore',\n    value: function setGameScore(userId, score) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.user_id = userId;\n      form.score = score;\n      return this._request('setGameScore', { form: form });\n    }\n\n    /**\n     * Use this method to get data for high score tables.\n     *\n     * Will return the score of the specified user and several of their neighbors in a game.\n     *\n     * @param  {Number} userId  Unique identifier of the target user\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise} On success, returns an Array of [GameHighScore](https://core.telegram.org/bots/api#gamehighscore) objects\n     * @see https://core.telegram.org/bots/api#getgamehighscores\n     */\n\n  }, {\n    key: 'getGameHighScores',\n    value: function getGameHighScores(userId) {\n      var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      form.user_id = userId;\n      return this._request('getGameHighScores', { form: form });\n    }\n\n    /**\n    * Use this method to delete a message, including service messages, with the following limitations:\n    * - A message can only be deleted if it was sent less than 48 hours ago.\n    * - A dice message can only be deleted if it was sent more than 24 hours ago.\n    * - Bots can delete outgoing messages in groups and supergroups.\n    * - Bots can delete incoming messages in groups, supergroups and channels.\n    * - Bots granted `can_post_messages` permissions can delete outgoing messages in channels.\n    * - If the bot is an administrator of a group, it can delete any message there.\n    * - If the bot has `can_delete_messages` permission in a supergroup, it can delete any message there.\n    *\n    * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n    * @param  {Number} messageId  Unique identifier of the target message\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success\n    * @see https://core.telegram.org/bots/api#deletemessage\n    */\n\n  }, {\n    key: 'deleteMessage',\n    value: function deleteMessage(chatId, messageId) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_id = messageId;\n      return this._request('deleteMessage', { form: form });\n    }\n\n    /**\n     * Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped.\n     *\n     * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n     * @param  {Array<Number|String>} messageIds  Identifiers of 1-100 messages to delete. See deleteMessage for limitations on which messages can be deleted\n     * @param  {Object} [options] Additional Telegram query options\n     * @return {Promise<Boolean>} True on success\n     * @see https://core.telegram.org/bots/api#deletemessages\n     */\n\n  }, {\n    key: 'deleteMessages',\n    value: function deleteMessages(chatId, messageIds) {\n      var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      form.chat_id = chatId;\n      form.message_ids = stringify(messageIds);\n      return this._request('deleteMessages', { form: form });\n    }\n  }]);\n\n  return TelegramBot;\n}(EventEmitter);\n\nmodule.exports = TelegramBot;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxR0FBcUcscUJBQXFCLG1CQUFtQjs7QUFFN0ksbUNBQW1DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFcnBCLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsc0RBQXNELGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsb0JBQW9CLE9BQU8sNENBQTRDLDRCQUE0QixxQkFBcUIsT0FBTyx1QkFBdUIsNEJBQTRCLG9CQUFvQjs7QUFFemMsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLGtEQUFrRCxhQUFhLHlGQUF5Rjs7QUFFeEosMkNBQTJDLCtEQUErRCx1R0FBdUcseUVBQXlFLGVBQWUsMEVBQTBFLEdBQUc7O0FBRXRYO0FBQ0Esc0hBQXlDLElBQUk7O0FBRTdDLGFBQWEsbUJBQU8sQ0FBQywwRUFBVTtBQUMvQix5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBbUI7QUFDcEQseUJBQXlCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3BELFlBQVksbUJBQU8sQ0FBQyx5RkFBTztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxxR0FBZTtBQUMxQyxlQUFlLG1CQUFPLENBQUMsMERBQVc7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLHlGQUEwQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyx3RUFBa0I7QUFDaEQsU0FBUyxtQkFBTyxDQUFDLGdDQUFhO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsK0NBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsZ0RBQU07QUFDekIsZ0JBQWdCLHlHQUE0Qjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRLDhEQUE4RDtBQUNyRixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQiw2QkFBNkI7QUFDN0MsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkNBQTZDLGNBQWM7QUFDM0QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxZQUFZO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixzQkFBc0I7QUFDdEMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFlBQVk7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxZQUFZO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFlBQVk7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFlBQVk7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLDZCQUE2QjtBQUM1QztBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCxnRUFBZ0U7QUFDOUg7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsWUFBWTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUSxvREFBb0Q7QUFDNUUsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWMsUUFBUTtBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsWUFBWTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxZQUFZO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFlBQVk7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxZQUFZO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELFlBQVk7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxZQUFZO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxZQUFZO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELFlBQVk7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxZQUFZO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFLFlBQVk7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxZQUFZO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsWUFBWTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQiw2QkFBNkI7QUFDN0MsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixxQkFBcUI7QUFDckMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcbGliXFx0ZWxlZ3JhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gc2hpbXNcbnJlcXVpcmUoJ2FycmF5LnByb3RvdHlwZS5maW5kaW5kZXgnKS5zaGltKCk7IC8vIGZvciBOb2RlLmpzIHYwLnhcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgVGVsZWdyYW1Cb3RXZWJIb29rID0gcmVxdWlyZSgnLi90ZWxlZ3JhbVdlYkhvb2snKTtcbnZhciBUZWxlZ3JhbUJvdFBvbGxpbmcgPSByZXF1aXJlKCcuL3RlbGVncmFtUG9sbGluZycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xudmFyIGZpbGVUeXBlID0gcmVxdWlyZSgnZmlsZS10eXBlJyk7XG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ0BjeXByZXNzL3JlcXVlc3QtcHJvbWlzZScpO1xudmFyIHN0cmVhbWVkUmVxdWVzdCA9IHJlcXVpcmUoJ0BjeXByZXNzL3JlcXVlc3QnKTtcbnZhciBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgbWltZSA9IHJlcXVpcmUoJ21pbWUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwdW1wID0gcmVxdWlyZSgncHVtcCcpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5kZXByZWNhdGU7XG5cbnZhciBfbWVzc2FnZVR5cGVzID0gWyd0ZXh0JywgJ2FuaW1hdGlvbicsICdhdWRpbycsICdjaGFubmVsX2NoYXRfY3JlYXRlZCcsICdjb250YWN0JywgJ2RlbGV0ZV9jaGF0X3Bob3RvJywgJ2RpY2UnLCAnZG9jdW1lbnQnLCAnZ2FtZScsICdncm91cF9jaGF0X2NyZWF0ZWQnLCAnaW52b2ljZScsICdsZWZ0X2NoYXRfbWVtYmVyJywgJ2xvY2F0aW9uJywgJ21pZ3JhdGVfZnJvbV9jaGF0X2lkJywgJ21pZ3JhdGVfdG9fY2hhdF9pZCcsICduZXdfY2hhdF9tZW1iZXJzJywgJ25ld19jaGF0X3Bob3RvJywgJ25ld19jaGF0X3RpdGxlJywgJ3Bhc3Nwb3J0X2RhdGEnLCAncGhvdG8nLCAncGlubmVkX21lc3NhZ2UnLCAncG9sbCcsICdzdGlja2VyJywgJ3N1Y2Nlc3NmdWxfcGF5bWVudCcsICdzdXBlcmdyb3VwX2NoYXRfY3JlYXRlZCcsICd2aWRlbycsICd2aWRlb19ub3RlJywgJ3ZvaWNlJywgJ3ZpZGVvX2NoYXRfc3RhcnRlZCcsICd2aWRlb19jaGF0X2VuZGVkJywgJ3ZpZGVvX2NoYXRfcGFydGljaXBhbnRzX2ludml0ZWQnLCAndmlkZW9fY2hhdF9zY2hlZHVsZWQnLCAnbWVzc2FnZV9hdXRvX2RlbGV0ZV90aW1lcl9jaGFuZ2VkJywgJ2NoYXRfaW52aXRlX2xpbmsnLCAnY2hhdF9tZW1iZXJfdXBkYXRlZCcsICd3ZWJfYXBwX2RhdGEnLCAnbWVzc2FnZV9yZWFjdGlvbiddO1xuXG52YXIgX2RlcHJlY2F0ZWRNZXNzYWdlVHlwZXMgPSBbJ25ld19jaGF0X3BhcnRpY2lwYW50JywgJ2xlZnRfY2hhdF9wYXJ0aWNpcGFudCddO1xuXG4vKipcbiAqIEpTT04tc2VyaWFsaXplIGRhdGEuIElmIHRoZSBwcm92aWRlZCBkYXRhIGlzIGFscmVhZHkgYSBTdHJpbmcsXG4gKiByZXR1cm4gaXQgYXMgaXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7Kn0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG52YXIgVGVsZWdyYW1Cb3QgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoVGVsZWdyYW1Cb3QsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIF9jcmVhdGVDbGFzcyhUZWxlZ3JhbUJvdCwgW3tcbiAgICBrZXk6ICdvbicsXG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBbZXZlbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI2V2ZW50cykuXG4gICAgICogVGhpcyBpcyB0aGUgdXN1YWwgYGVtaXR0ZXIub24oKWAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNldmVudHN8QXZhaWxhYmxlIGV2ZW50c31cbiAgICAgKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2VtaXR0ZXJfb25fZXZlbnRuYW1lX2xpc3RlbmVyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgaWYgKF9kZXByZWNhdGVkTWVzc2FnZVR5cGVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI2V2ZW50cyc7XG4gICAgICAgIGRlcHJlY2F0ZSgnRXZlbnRzICcgKyBfZGVwcmVjYXRlZE1lc3NhZ2VUeXBlcy5qb2luKCcsJykgKyAnIGFyZSBkZXByZWNhdGVkLiBTZWUgdGhlIHVwZGF0ZWQgbGlzdCBvZiBldmVudHM6ICcgKyB1cmwpO1xuICAgICAgfVxuICAgICAgX2dldChUZWxlZ3JhbUJvdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUZWxlZ3JhbUJvdC5wcm90b3R5cGUpLCAnb24nLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm90aCByZXF1ZXN0IG1ldGhvZCB0byBvYnRhaW4gbWVzc2FnZXMgYXJlIGltcGxlbWVudGVkLiBUbyB1c2Ugc3RhbmRhcmQgcG9sbGluZywgc2V0IGBwb2xsaW5nOiB0cnVlYFxuICAgICAqIG9uIGBvcHRpb25zYC4gTm90aWNlIHRoYXQgW3dlYkhvb2tdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0d2ViaG9vaykgd2lsbCBuZWVkIGEgU1NMIGNlcnRpZmljYXRlLlxuICAgICAqIEVtaXRzIGBtZXNzYWdlYCB3aGVuIGEgbWVzc2FnZSBhcnJpdmVzLlxuICAgICAqXG4gICAgICogQGNsYXNzIFRlbGVncmFtQm90XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIEJvdCBUb2tlblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBbb3B0aW9ucy5wb2xsaW5nPWZhbHNlXSBTZXQgdHJ1ZSB0byBlbmFibGUgcG9sbGluZyBvciBzZXQgb3B0aW9ucy5cbiAgICAgKiAgSWYgYSBXZWJIb29rIGhhcyBiZWVuIHNldCwgaXQgd2lsbCBiZSBkZWxldGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5wb2xsaW5nLnRpbWVvdXQ9MTBdICpEZXByZWNhdGVkLiBVc2UgYG9wdGlvbnMucG9sbGluZy5wYXJhbXNgIGluc3RlYWQqLlxuICAgICAqICBUaW1lb3V0IGluIHNlY29uZHMgZm9yIGxvbmcgcG9sbGluZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRlc3RFbnZpcm9ubWVudD1mYWxzZV0gU2V0IHRydWUgdG8gIHdvcmsgd2l0aCB0ZXN0IGVudmlyb21lbnQuXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggdGhlIHRlc3QgZW52aXJvbm1lbnQsIHlvdSBtYXkgdXNlIEhUVFAgbGlua3Mgd2l0aG91dCBUTFMgdG8gdGVzdCB5b3VyIFdlYiBBcHAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5wb2xsaW5nLmludGVydmFsPTMwMF0gSW50ZXJ2YWwgYmV0d2VlbiByZXF1ZXN0cyBpbiBtaWxpc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9sbGluZy5hdXRvU3RhcnQ9dHJ1ZV0gU3RhcnQgcG9sbGluZyBpbW1lZGlhdGVseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb2xsaW5nLnBhcmFtc10gUGFyYW1ldGVycyB0byBiZSB1c2VkIGluIHBvbGxpbmcgQVBJIHJlcXVlc3RzLlxuICAgICAqICBTZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR1cGRhdGVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMucG9sbGluZy5wYXJhbXMudGltZW91dD0xMF0gVGltZW91dCBpbiBzZWNvbmRzIGZvciBsb25nIHBvbGxpbmcuXG4gICAgICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gW29wdGlvbnMud2ViSG9vaz1mYWxzZV0gU2V0IHRydWUgdG8gZW5hYmxlIFdlYkhvb2sgb3Igc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5ob3N0PVwiMC4wLjAuMFwiXSBIb3N0IHRvIGJpbmQgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2ViSG9vay5wb3J0PTg0NDNdIFBvcnQgdG8gYmluZCB0b1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLmtleV0gUGF0aCB0byBmaWxlIHdpdGggUEVNIHByaXZhdGUga2V5IGZvciB3ZWJIb29rIHNlcnZlci5cbiAgICAgKiAgVGhlIGZpbGUgaXMgcmVhZCAqKnN5bmNocm9ub3VzbHkqKiFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5jZXJ0XSBQYXRoIHRvIGZpbGUgd2l0aCBQRU0gY2VydGlmaWNhdGUgKHB1YmxpYykgZm9yIHdlYkhvb2sgc2VydmVyLlxuICAgICAqICBUaGUgZmlsZSBpcyByZWFkICoqc3luY2hyb25vdXNseSoqIVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLnBmeF0gUGF0aCB0byBmaWxlIHdpdGggUEZYIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBjaGFpbiBmb3Igd2ViSG9vayBzZXJ2ZXIuXG4gICAgICogIFRoZSBmaWxlIGlzIHJlYWQgKipzeW5jaHJvbm91c2x5KiohXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53ZWJIb29rLmF1dG9PcGVuPXRydWVdIE9wZW4gd2ViSG9vayBpbW1lZGlhdGVseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53ZWJIb29rLmh0dHBzXSBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byBgaHR0cHMuY3JlYXRlU2VydmVyKClgLlxuICAgICAqICBOb3RlIHRoYXQgYG9wdGlvbnMud2ViSG9vay5rZXlgLCBgb3B0aW9ucy53ZWJIb29rLmNlcnRgIGFuZCBgb3B0aW9ucy53ZWJIb29rLnBmeGAsIGlmIHByb3ZpZGVkLCB3aWxsIGJlXG4gICAgICogIHVzZWQgdG8gb3ZlcnJpZGUgYGtleWAsIGBjZXJ0YCBhbmQgYHBmeGAgaW4gdGhpcyBvYmplY3QsIHJlc3BlY3RpdmVseS5cbiAgICAgKiAgU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cHMuaHRtbCNodHRwc19odHRwc19jcmVhdGVzZXJ2ZXJfb3B0aW9uc19yZXF1ZXN0bGlzdGVuZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2suaGVhbHRoRW5kcG9pbnQ9XCIvaGVhbHRoelwiXSBBbiBlbmRwb2ludCBmb3IgaGVhbHRoIGNoZWNrcyB0aGF0IGFsd2F5cyByZXNwb25kcyB3aXRoIDIwMCBPS1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25seUZpcnN0TWF0Y2g9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHN0b3AgYWZ0ZXIgZmlyc3QgbWF0Y2guIE90aGVyd2lzZSwgYWxsIHJlZ2V4cHMgYXJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJlcXVlc3RdIE9wdGlvbnMgd2hpY2ggd2lsbCBiZSBhZGRlZCBmb3IgYWxsIHJlcXVlc3RzIHRvIHRlbGVncmFtIGFwaS5cbiAgICAgKiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QjcmVxdWVzdG9wdGlvbnMtY2FsbGJhY2sgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJhc2VBcGlVcmw9XCJodHRwczovL2FwaS50ZWxlZ3JhbS5vcmdcIl0gQVBJIEJhc2UgVVJsOyB1c2VmdWwgZm9yIHByb3h5aW5nIGFuZCB0ZXN0aW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maWxlcGF0aD10cnVlXSBBbGxvdyBwYXNzaW5nIGZpbGUtcGF0aHMgYXMgYXJndW1lbnRzIHdoZW4gc2VuZGluZyBmaWxlcyxcbiAgICAgKiAgc3VjaCBhcyBwaG90b3MgdXNpbmcgYFRlbGVncmFtQm90I3NlbmRQaG90bygpYC4gU2VlIFt1c2FnZSBpbmZvcm1hdGlvbl1bdXNhZ2Utc2VuZGluZy1maWxlcy1wZXJmb3JtYW5jZV1cbiAgICAgKiAgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyBvcHRpb24gYW5kIGl0cyBjb25zZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWRSZWplY3Rpb249ZmFsc2VdIFNldCB0byBgdHJ1ZWBcbiAgICAgKiAgKippZiBhbmQgb25seSBpZioqIHRoZSBOb2RlLmpzIHZlcnNpb24geW91J3JlIHVzaW5nIHRlcm1pbmF0ZXMgdGhlXG4gICAgICogIHByb2Nlc3Mgb24gdW5oYW5kbGVkIHJlamVjdGlvbnMuIFRoaXMgb3B0aW9uIGlzIG9ubHkgZm9yXG4gICAgICogICpmb3J3YXJkLWNvbXBhdGliaWxpdHkgcHVycG9zZXMqLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ2Vycm9ycycsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlmZmVyZW50IGVycm9ycyB0aGUgbGlicmFyeSB1c2VzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlcyBvZiBtZXNzYWdlIHVwZGF0ZXMgdGhlIGxpYnJhcnkgaGFuZGxlcy5cbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21lc3NhZ2VUeXBlcycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX21lc3NhZ2VUeXBlcztcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBUZWxlZ3JhbUJvdCh0b2tlbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZWxlZ3JhbUJvdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGVsZWdyYW1Cb3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUZWxlZ3JhbUJvdCkpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMudG9rZW4gPSB0b2tlbjtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBfdGhpcy5vcHRpb25zLnBvbGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5wb2xsaW5nID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy5wb2xsaW5nO1xuICAgIF90aGlzLm9wdGlvbnMud2ViSG9vayA9IHR5cGVvZiBvcHRpb25zLndlYkhvb2sgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBvcHRpb25zLndlYkhvb2s7XG4gICAgX3RoaXMub3B0aW9ucy5iYXNlQXBpVXJsID0gb3B0aW9ucy5iYXNlQXBpVXJsIHx8ICdodHRwczovL2FwaS50ZWxlZ3JhbS5vcmcnO1xuICAgIF90aGlzLm9wdGlvbnMuZmlsZXBhdGggPSB0eXBlb2Ygb3B0aW9ucy5maWxlcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5maWxlcGF0aDtcbiAgICBfdGhpcy5vcHRpb25zLmJhZFJlamVjdGlvbiA9IHR5cGVvZiBvcHRpb25zLmJhZFJlamVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG9wdGlvbnMuYmFkUmVqZWN0aW9uO1xuICAgIF90aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzID0gW107XG4gICAgX3RoaXMuX3JlcGx5TGlzdGVuZXJJZCA9IDA7XG4gICAgX3RoaXMuX3JlcGx5TGlzdGVuZXJzID0gW107XG4gICAgX3RoaXMuX3BvbGxpbmcgPSBudWxsO1xuICAgIF90aGlzLl93ZWJIb29rID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLnBvbGxpbmcpIHtcbiAgICAgIHZhciBhdXRvU3RhcnQgPSBvcHRpb25zLnBvbGxpbmcuYXV0b1N0YXJ0O1xuICAgICAgaWYgKHR5cGVvZiBhdXRvU3RhcnQgPT09ICd1bmRlZmluZWQnIHx8IGF1dG9TdGFydCA9PT0gdHJ1ZSkge1xuICAgICAgICBfdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53ZWJIb29rKSB7XG4gICAgICB2YXIgYXV0b09wZW4gPSBvcHRpb25zLndlYkhvb2suYXV0b09wZW47XG4gICAgICBpZiAodHlwZW9mIGF1dG9PcGVuID09PSAndW5kZWZpbmVkJyB8fCBhdXRvT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICBfdGhpcy5vcGVuV2ViSG9vaygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHVybCB3aXRoIGJvdCB0b2tlbiBhbmQgcHJvdmlkZWQgcGF0aC9tZXRob2QgeW91IHdhbnQgdG8gYmUgZ290L2V4ZWN1dGVkIGJ5IGJvdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAgICogQHJldHVybiB7U3RyaW5nfSB1cmxcbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21ha2luZy1yZXF1ZXN0c1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUZWxlZ3JhbUJvdCwgW3tcbiAgICBrZXk6ICdfYnVpbGRVUkwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRVUkwoX3BhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYmFzZUFwaVVybCArICcvYm90JyArIHRoaXMudG9rZW4gKyAodGhpcy5vcHRpb25zLnRlc3RFbnZpcm9ubWVudCA/ICcvdGVzdCcgOiAnJykgKyAnLycgKyBfcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXggJ3JlcGx5X21hcmt1cCcgcGFyYW1ldGVyIGJ5IG1ha2luZyBpdCBKU09OLXNlcmlhbGl6ZWQsIGFzXG4gICAgICogcmVxdWlyZWQgYnkgdGhlIFRlbGVncmFtIEJvdCBBUElcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdDsgZWl0aGVyICdmb3JtJyBvciAncXMnXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpeFJlcGx5TWFya3VwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFJlcGx5TWFya3VwKG9iaikge1xuICAgICAgdmFyIHJlcGx5TWFya3VwID0gb2JqLnJlcGx5X21hcmt1cDtcbiAgICAgIGlmIChyZXBseU1hcmt1cCAmJiB0eXBlb2YgcmVwbHlNYXJrdXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iai5yZXBseV9tYXJrdXAgPSBzdHJpbmdpZnkocmVwbHlNYXJrdXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpeCAnZW50aXRpZXMnIG9yICdjYXB0aW9uX2VudGl0aWVzJyBvciAnZXhwbGFuYXRpb25fZW50aXRpZXMnIHBhcmFtZXRlciBieSBtYWtpbmcgaXQgSlNPTi1zZXJpYWxpemVkLCBhc1xuICAgICAqIHJlcXVpcmVkIGJ5IHRoZSBUZWxlZ3JhbSBCb3QgQVBJXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3Q7XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY29weW1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHBvbGxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2ZpeEVudGl0aWVzRmllbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml4RW50aXRpZXNGaWVsZChvYmopIHtcbiAgICAgIHZhciBlbnRpdGllcyA9IG9iai5lbnRpdGllcztcbiAgICAgIHZhciBjYXB0aW9uRW50aXRpZXMgPSBvYmouY2FwdGlvbl9lbnRpdGllcztcbiAgICAgIHZhciBleHBsYW5hdGlvbkVudGl0aWVzID0gb2JqLmV4cGxhbmF0aW9uX2VudGl0aWVzO1xuICAgICAgaWYgKGVudGl0aWVzICYmIHR5cGVvZiBlbnRpdGllcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLmVudGl0aWVzID0gc3RyaW5naWZ5KGVudGl0aWVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcHRpb25FbnRpdGllcyAmJiB0eXBlb2YgY2FwdGlvbkVudGl0aWVzICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvYmouY2FwdGlvbl9lbnRpdGllcyA9IHN0cmluZ2lmeShjYXB0aW9uRW50aXRpZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwbGFuYXRpb25FbnRpdGllcyAmJiB0eXBlb2YgZXhwbGFuYXRpb25FbnRpdGllcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLmV4cGxhbmF0aW9uX2VudGl0aWVzID0gc3RyaW5naWZ5KGV4cGxhbmF0aW9uRW50aXRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19maXhBZGRGaWxlVGh1bWJuYWlsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cykge1xuICAgICAgaWYgKG9wdGlvbnMudGh1bWIpIHtcbiAgICAgICAgaWYgKG9wdHMuZm9ybURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHRzLmZvcm1EYXRhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0YWNoTmFtZSA9ICdwaG90byc7XG5cbiAgICAgICAgdmFyIF9mb3JtYXRTZW5kRGF0YTIgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShhdHRhY2hOYW1lLCBvcHRpb25zLnRodW1iLnJlcGxhY2UoJ2F0dGFjaDovLycsICcnKSksXG4gICAgICAgICAgICBfZm9ybWF0U2VuZERhdGEzID0gX3NsaWNlZFRvQXJyYXkoX2Zvcm1hdFNlbmREYXRhMiwgMSksXG4gICAgICAgICAgICBmb3JtRGF0YSA9IF9mb3JtYXRTZW5kRGF0YTNbMF07XG5cbiAgICAgICAgaWYgKGZvcm1EYXRhKSB7XG4gICAgICAgICAgb3B0cy5mb3JtRGF0YVthdHRhY2hOYW1lXSA9IGZvcm1EYXRhW2F0dGFjaE5hbWVdO1xuICAgICAgICAgIG9wdHMucXMudGh1bWJuYWlsID0gJ2F0dGFjaDovLycgKyBhdHRhY2hOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRml4ICdyZXBseV9wYXJhbWV0ZXJzJyBwYXJhbWV0ZXIgYnkgbWFraW5nIGl0IEpTT04tc2VyaWFsaXplZCwgYXNcbiAgICAgKiByZXF1aXJlZCBieSB0aGUgVGVsZWdyYW0gQm90IEFQSVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0OyBlaXRoZXIgJ2Zvcm0nIG9yICdxcydcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVzc2FnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZml4UmVwbHlQYXJhbWV0ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFJlcGx5UGFyYW1ldGVycyhvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJ3JlcGx5X3BhcmFtZXRlcnMnKSAmJiB0eXBlb2Ygb2JqLnJlcGx5X3BhcmFtZXRlcnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iai5yZXBseV9wYXJhbWV0ZXJzID0gc3RyaW5naWZ5KG9iai5yZXBseV9wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlcXVlc3QgYWdhaW5zdCB0aGUgQVBJXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBfcGF0aCBBUEkgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3JlcXVlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdChfcGF0aCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAoIXRoaXMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignVGVsZWdyYW0gQm90IFRva2VuIG5vdCBwcm92aWRlZCEnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWVzdCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy5yZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgICAgICB0aGlzLl9maXhSZXBseU1hcmt1cChvcHRpb25zLmZvcm0pO1xuICAgICAgICB0aGlzLl9maXhFbnRpdGllc0ZpZWxkKG9wdGlvbnMuZm9ybSk7XG4gICAgICAgIHRoaXMuX2ZpeFJlcGx5UGFyYW1ldGVycyhvcHRpb25zLmZvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucXMpIHtcbiAgICAgICAgdGhpcy5fZml4UmVwbHlNYXJrdXAob3B0aW9ucy5xcyk7XG4gICAgICAgIHRoaXMuX2ZpeFJlcGx5UGFyYW1ldGVycyhvcHRpb25zLnFzKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUE9TVCc7XG4gICAgICBvcHRpb25zLnVybCA9IHRoaXMuX2J1aWxkVVJMKF9wYXRoKTtcbiAgICAgIG9wdGlvbnMuc2ltcGxlID0gZmFsc2U7XG4gICAgICBvcHRpb25zLnJlc29sdmVXaXRoRnVsbFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgIG9wdGlvbnMuZm9yZXZlciA9IHRydWU7XG4gICAgICBkZWJ1ZygnSFRUUCByZXF1ZXN0OiAlaicsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Qob3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gcmVzcC5ib2R5ID0gSlNPTi5wYXJzZShyZXNwLmJvZHkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlBhcnNlRXJyb3IoJ0Vycm9yIHBhcnNpbmcgcmVzcG9uc2U6ICcgKyByZXNwLmJvZHksIHJlc3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEub2spIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlRlbGVncmFtRXJyb3IoZGF0YS5lcnJvcl9jb2RlICsgJyAnICsgZGF0YS5kZXNjcmlwdGlvbiwgcmVzcCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gVE9ETzogd2h5IGNhbid0IHdlIGRvIGBlcnJvciBpbnN0YW5jZW9mIGVycm9ycy5CYXNlRXJyb3JgP1xuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHRocm93IGVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGRhdGEgdG8gYmUgdXBsb2FkZWQ7IGhhbmRsZXMgZmlsZSBwYXRocywgc3RyZWFtcyBhbmQgYnVmZmVyc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZmlsZU9wdGlvbnMgRmlsZSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbZmlsZU9wdGlvbnMuZmlsZW5hbWVdIEZpbGUgbmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2ZpbGVPcHRpb25zLmNvbnRlbnRUeXBlXSBDb250ZW50IHR5cGUgKGkuZS4gTUlNRSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gZm9ybWF0dGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBmb3JtYXR0ZWRbMF0gZm9ybURhdGFcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZFsxXSBmaWxlSWRcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIEJ1ZmZlciBmaWxlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZmlsZS10eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2Zvcm1hdFNlbmREYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1hdFNlbmREYXRhKHR5cGUsIGRhdGEpIHtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXMnICsgJyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgc2VuZGluZyBmaWxlcyBoYXMgYmVlbiBpbXByb3ZlZCBhbmQnICsgJyBvbiBob3cgdG8gZGlzYWJsZSB0aGlzIGRlcHJlY2F0aW9uIG1lc3NhZ2UgYWx0b2dldGhlci4nO1xuICAgICAgdmFyIGZpbGVkYXRhID0gZGF0YTtcbiAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVPcHRpb25zLmZpbGVuYW1lO1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gZmlsZU9wdGlvbnMuY29udGVudFR5cGU7XG5cbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlN0cmVhbSkge1xuICAgICAgICBpZiAoIWZpbGVuYW1lICYmIGRhdGEucGF0aCkge1xuICAgICAgICAgIC8vIFdpbGwgYmUgJ251bGwnIGlmIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICAgICAgLy8gRm9yIGV4YW1wbGUsICdkYXRhLnBhdGgnID09PSAnLz9pZD0xMjMnIGZyb20gJ3JlcXVlc3QoXCJodHRwczovL2V4YW1wbGUuY29tLz9pZD0xMjNcIiknXG4gICAgICAgICAgdmFyIHVybCA9IFVSTC5wYXJzZShwYXRoLmJhc2VuYW1lKGRhdGEucGF0aC50b1N0cmluZygpKSk7XG4gICAgICAgICAgaWYgKHVybC5wYXRobmFtZSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBxcy51bmVzY2FwZSh1cmwucGF0aG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgaWYgKCFmaWxlbmFtZSAmJiAhcHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICAgICAgZGVwcmVjYXRlKCdCdWZmZXJzIHdpbGwgaGF2ZSB0aGVpciBmaWxlbmFtZXMgZGVmYXVsdCB0byBcImZpbGVuYW1lXCIgaW5zdGVhZCBvZiBcImRhdGFcIi4gJyArIGRlcHJlY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgZmlsZW5hbWUgPSAnZGF0YSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICAgIHZhciBmaWxldHlwZSA9IGZpbGVUeXBlKGRhdGEpO1xuICAgICAgICAgIGlmIChmaWxldHlwZSkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSBmaWxldHlwZS5taW1lO1xuICAgICAgICAgICAgdmFyIGV4dCA9IGZpbGV0eXBlLmV4dDtcbiAgICAgICAgICAgIGlmIChleHQgJiYgIXByb2Nlc3MuZW52Lk5UQkFfRklYXzM1MCkge1xuICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lICsgJy4nICsgZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXByb2Nlc3MuZW52Lk5UQkFfRklYXzM1MCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlKCdBbiBlcnJvciB3aWxsIG5vIGxvbmdlciBiZSB0aHJvd24gaWYgZmlsZS10eXBlIG9mIGJ1ZmZlciBjb3VsZCBub3QgYmUgZGV0ZWN0ZWQuICcgKyBkZXByZWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5GYXRhbEVycm9yKCdVbnN1cHBvcnRlZCBCdWZmZXIgZmlsZS10eXBlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5maWxlcGF0aCAmJiBmcy5leGlzdHNTeW5jKGRhdGEpKSB7XG4gICAgICAgICAgZmlsZWRhdGEgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGRhdGEpO1xuICAgICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtudWxsLCBkYXRhXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCBkYXRhXTtcbiAgICAgIH1cblxuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCAnZmlsZW5hbWUnO1xuICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZSB8fCBtaW1lLmxvb2t1cChmaWxlbmFtZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXByZWNhdGUoJ0luIHRoZSBmdXR1cmUsIGNvbnRlbnQtdHlwZSBvZiBmaWxlcyB5b3Ugc2VuZCB3aWxsIGRlZmF1bHQgdG8gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIi4gJyArIGRlcHJlY2F0aW9uTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEFkZCBtaXNzaW5nIGZpbGUgZXh0ZW5zaW9uLlxuXG4gICAgICByZXR1cm4gW19kZWZpbmVQcm9wZXJ0eSh7fSwgdHlwZSwge1xuICAgICAgICB2YWx1ZTogZmlsZWRhdGEsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICAgIH1cbiAgICAgIH0pLCBudWxsXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nLlxuICAgICAqIFJlamVjdHMgcmV0dXJuZWQgcHJvbWlzZSBpZiBhIFdlYkhvb2sgaXMgYmVpbmcgdXNlZCBieSB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMucmVzdGFydD10cnVlXSBDb25zZWN1dGl2ZSBjYWxscyB0byB0aGlzIG1ldGhvZCBjYXVzZXMgcG9sbGluZyB0byBiZSByZXN0YXJ0ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydFBvbGxpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydFBvbGxpbmcoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmICh0aGlzLmhhc09wZW5XZWJIb29rKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignUG9sbGluZyBhbmQgV2ViSG9vayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJykpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5yZXN0YXJ0ID0gdHlwZW9mIG9wdGlvbnMucmVzdGFydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucy5yZXN0YXJ0O1xuICAgICAgaWYgKCF0aGlzLl9wb2xsaW5nKSB7XG4gICAgICAgIHRoaXMuX3BvbGxpbmcgPSBuZXcgVGVsZWdyYW1Cb3RQb2xsaW5nKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3BvbGxpbmcuc3RhcnQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYFRlbGVncmFtQm90I3N0YXJ0UG9sbGluZygpYC4gVGhpcyBpcyAqKmRlcHJlY2F0ZWQqKi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5pdFBvbGxpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UG9sbGluZygpIHtcbiAgICAgIGRlcHJlY2F0ZSgnVGVsZWdyYW1Cb3QjaW5pdFBvbGxpbmcoKSBpcyBkZXByZWNhdGVkLiBVc2UgVGVsZWdyYW1Cb3Qjc3RhcnRQb2xsaW5nKCkgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHBvbGxpbmcgYWZ0ZXIgdGhlIGxhc3QgcG9sbGluZyByZXF1ZXN0IHJlc29sdmVzLlxuICAgICAqIE11bHRpcGxlIGludm9jYXRpb25zIGRvIG5vdGhpbmcgaWYgcG9sbGluZyBpcyBhbHJlYWR5IHN0b3BwZWQuXG4gICAgICogUmV0dXJuaW5nIHRoZSBwcm9taXNlIG9mIHRoZSBsYXN0IHBvbGxpbmcgcmVxdWVzdCBpcyAqKmRlcHJlY2F0ZWQqKi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsXSBDYW5jZWwgY3VycmVudCByZXF1ZXN0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb25dIFJlYXNvbiBmb3Igc3RvcHBpbmcgcG9sbGluZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3BQb2xsaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcFBvbGxpbmcob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9wb2xsaW5nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nLnN0b3Aob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbmsgZm9yIGZpbGUuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBsaW5rIGZvciBmaWxlIGZvciBzdWJzZXF1ZW50IHVzZS5cbiAgICAgKiBBdHRlbnRpb246IGxpbmsgd2lsbCBiZSB2YWxpZCBmb3IgMSBob3VyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYSBzdWdhciBleHRlbnNpb24gb2YgdGhlIChnZXRGaWxlKVsjZ2V0ZmlsZWZpbGVpZF0gbWV0aG9kLFxuICAgICAqIHdoaWNoIHJldHVybnMganVzdCBwYXRoIHRvIGZpbGUgb24gcmVtb3RlIHNlcnZlciAoeW91IHdpbGwgaGF2ZSB0byBtYW51YWxseSBidWlsZCBmdWxsIHVyaSBhZnRlciB0aGF0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZUlkICBGaWxlIGlkZW50aWZpZXIgdG8gZ2V0IGluZm8gYWJvdXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHdpbGwgaGF2ZSAgKmZpbGVVUkkqIGluIHJlc29sdmUgY2FsbGJhY2tcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0ZmlsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGaWxlTGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVMaW5rKGZpbGVJZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZShmaWxlSWQsIGZvcm0pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmJhc2VBcGlVcmwgKyAnL2ZpbGUvYm90JyArIF90aGlzMi50b2tlbiArICcvJyArIHJlc3AuZmlsZV9wYXRoO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcmVhZGFibGUgc3RyZWFtIGZvciBmaWxlLlxuICAgICAqXG4gICAgICogYGZpbGVTdHJlYW0ucGF0aGAgaXMgdGhlIHNwZWNpZmllZCBmaWxlIElEIGkuZS4gYGZpbGVJZGAuXG4gICAgICogYGZpbGVTdHJlYW1gIGVtaXRzIGV2ZW50IGBpbmZvYCBwYXNzaW5nIGEgc2luZ2xlIGFyZ3VtZW50IGkuZS5cbiAgICAgKiBgaW5mb2Agd2l0aCB0aGUgaW50ZXJmYWNlIGB7IHVyaSB9YCB3aGVyZSBgdXJpYCBpcyB0aGUgVVJJIG9mIHRoZVxuICAgICAqIGZpbGUgb24gVGVsZWdyYW0gc2VydmVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSBbZ2V0RmlsZUxpbmtdKCNUZWxlZ3JhbUJvdCtnZXRGaWxlTGluaykgbWV0aG9kLFxuICAgICAqIHdoaWNoIHJldHVybnMgdGhlIGZ1bGwgVVJJIHRvIHRoZSBmaWxlIG9uIHJlbW90ZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCBGaWxlIGlkZW50aWZpZXIgdG8gZ2V0IGluZm8gYWJvdXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtzdHJlYW0uUmVhZGFibGV9IGZpbGVTdHJlYW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RmlsZVN0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVTdHJlYW0oZmlsZUlkKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgZmlsZVN0cmVhbSA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKTtcbiAgICAgIGZpbGVTdHJlYW0ucGF0aCA9IGZpbGVJZDtcbiAgICAgIHRoaXMuZ2V0RmlsZUxpbmsoZmlsZUlkLCBmb3JtKS50aGVuKGZ1bmN0aW9uIChmaWxlVVJJKSB7XG4gICAgICAgIGZpbGVTdHJlYW0uZW1pdCgnaW5mbycsIHtcbiAgICAgICAgICB1cmk6IGZpbGVVUklcbiAgICAgICAgfSk7XG4gICAgICAgIHB1bXAoc3RyZWFtZWRSZXF1ZXN0KE9iamVjdC5hc3NpZ24oeyB1cmk6IGZpbGVVUkkgfSwgX3RoaXMzLm9wdGlvbnMucmVxdWVzdCkpLCBmaWxlU3RyZWFtKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBmaWxlU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsZVN0cmVhbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgZmlsZSBpbiB0aGUgc3BlY2lmaWVkIGZvbGRlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSBbZ2V0RmlsZVN0cmVhbV0oI1RlbGVncmFtQm90K2dldEZpbGVTdHJlYW0pIG1ldGhvZCxcbiAgICAgKiB3aGljaCByZXR1cm5zIGEgcmVhZGFibGUgZmlsZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkb3dubG9hZERpciBBYnNvbHV0ZSBwYXRoIHRvIHRoZSBmb2xkZXIgaW4gd2hpY2ggZmlsZSB3aWxsIGJlIHNhdmVkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSwgd2hpY2ggd2lsbCBoYXZlICpmaWxlUGF0aCogb2YgZG93bmxvYWRlZCBmaWxlIGluIHJlc29sdmUgY2FsbGJhY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZG93bmxvYWRGaWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRGaWxlKGZpbGVJZCwgZG93bmxvYWREaXIpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdmFyIHJlc29sdmUgPSB2b2lkIDA7XG4gICAgICB2YXIgcmVqZWN0ID0gdm9pZCAwO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXNvbHZlID0gYTtcbiAgICAgICAgcmVqZWN0ID0gYjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZpbGVTdHJlYW0gPSB0aGlzLmdldEZpbGVTdHJlYW0oZmlsZUlkLCBmb3JtKTtcbiAgICAgIGZpbGVTdHJlYW0ub24oJ2luZm8nLCBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBpbmZvLnVyaS5zbGljZShpbmZvLnVyaS5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIC8vIFRPRE86IEVuc3VyZSBmaWxlTmFtZSBkb2Vzbid0IGNvbnRhaW5zIHNsYXNoZXNcbiAgICAgICAgdmFyIGZpbGVQYXRoID0gcGF0aC5qb2luKGRvd25sb2FkRGlyLCBmaWxlTmFtZSk7XG4gICAgICAgIHB1bXAoZmlsZVN0cmVhbSwgZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlUGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBmaWxlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgUmVnRXhwIHRvIHRlc3QgYWdhaW5zdCBhbiBpbmNvbW1pbmcgdGV4dCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSAge1JlZ0V4cH0gICByZWdleHBSZXhlY3V0ZWQgd2l0aCBgZXhlY2AuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAgICBDYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIDIgcGFyYW1ldGVycyxcbiAgICAgKiB0aGUgYG1zZ2AgYW5kIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIGByZWdleHAuZXhlY2Agb24gbWVzc2FnZSB0ZXh0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblRleHQocmVnZXhwLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5wdXNoKHsgcmVnZXhwOiByZWdleHAsIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggYG9uVGV4dCgpYC5cbiAgICAgKiBAcGFyYW0gIHtSZWdFeHB9IHJlZ2V4cCBSZWdFeHAgdXNlZCBwcmV2aW91c2x5IGluIGBvblRleHQoKWBcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlbGV0ZWRMaXN0ZW5lciBUaGUgcmVtb3ZlZCByZXBseSBsaXN0ZW5lciBpZlxuICAgICAqICAgZm91bmQuIFRoaXMgb2JqZWN0IGhhcyBgcmVnZXhwYCBhbmQgYGNhbGxiYWNrYFxuICAgICAqICAgcHJvcGVydGllcy4gSWYgbm90IGZvdW5kLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlVGV4dExpc3RlbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVGV4dExpc3RlbmVyKHJlZ2V4cCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5maW5kSW5kZXgoZnVuY3Rpb24gKHRleHRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRleHRMaXN0ZW5lci5yZWdleHApID09PSBTdHJpbmcocmVnZXhwKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCB3aXRoIGBvblRleHQoKWAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyVGV4dExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyVGV4dExpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHJlcGx5IHRvIHdhaXQgZm9yIGEgbWVzc2FnZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBUaGUgY2hhdCBpZCB3aGVyZSB0aGUgbWVzc2FnZSBjYW1lcyBmcm9tLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IG1lc3NhZ2VJZCBUaGUgbWVzc2FnZSBpZCB0byBiZSByZXBsaWVkLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSByZXBseVxuICAgICAqICBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gaWQgVGhlIElEIG9mIHRoZSBpbnNlcnRlZCByZXBseSBsaXN0ZW5lci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25SZXBseVRvTWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVwbHlUb01lc3NhZ2UoY2hhdElkLCBtZXNzYWdlSWQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaWQgPSArK3RoaXMuX3JlcGx5TGlzdGVuZXJJZDtcbiAgICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNoYXRJZDogY2hhdElkLFxuICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcmVwbHkgdGhhdCBoYXMgYmVlbiBwcmV2LiByZWdpc3RlcmVkIGZvciBhIG1lc3NhZ2UgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtICAge051bWJlcn0gcmVwbHlMaXN0ZW5lcklkIFRoZSBJRCBvZiB0aGUgcmVwbHkgbGlzdGVuZXIuXG4gICAgICogQHJldHVybiAge09iamVjdH0gZGVsZXRlZExpc3RlbmVyIFRoZSByZW1vdmVkIHJlcGx5IGxpc3RlbmVyIGlmXG4gICAgICogICBmb3VuZC4gVGhpcyBvYmplY3QgaGFzIGBpZGAsIGBjaGF0SWRgLCBgbWVzc2FnZUlkYCBhbmQgYGNhbGxiYWNrYFxuICAgICAqICAgcHJvcGVydGllcy4gSWYgbm90IGZvdW5kLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlUmVwbHlMaXN0ZW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVJlcGx5TGlzdGVuZXIocmVwbHlMaXN0ZW5lcklkKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9yZXBseUxpc3RlbmVycy5maW5kSW5kZXgoZnVuY3Rpb24gKHJlcGx5TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlcGx5TGlzdGVuZXIuaWQgPT09IHJlcGx5TGlzdGVuZXJJZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXBseUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHJlcGxpZXMgdGhhdCBoYXZlIGJlZW4gcHJldi4gcmVnaXN0ZXJlZCBmb3IgYSBtZXNzYWdlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJldHVybiAge0FycmF5fSBkZWxldGVkTGlzdGVuZXJzIEFuIGFycmF5IG9mIHJlbW92ZWQgbGlzdGVuZXJzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhclJlcGx5TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJSZXBseUxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgcG9sbGluZy4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzUG9sbGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUG9sbGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nID8gdGhpcy5fcG9sbGluZy5pc1BvbGxpbmcoKSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gd2ViaG9vay5cbiAgICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHdlYmhvb2sgaXMgYWxyZWFkeSBvcGVuLlxuICAgICAqIFJlamVjdHMgcmV0dXJuZWQgcHJvbWlzZSBpZiBQb2xsaW5nIGlzIGJlaW5nIHVzZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29wZW5XZWJIb29rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbldlYkhvb2soKSB7XG4gICAgICBpZiAodGhpcy5pc1BvbGxpbmcoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9ycy5GYXRhbEVycm9yKCdXZWJIb29rIGFuZCBQb2xsaW5nIGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3dlYkhvb2spIHtcbiAgICAgICAgdGhpcy5fd2ViSG9vayA9IG5ldyBUZWxlZ3JhbUJvdFdlYkhvb2sodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2ViSG9vay5vcGVuKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2Ugd2ViaG9vayBhZnRlciBjbG9zaW5nIGFsbCBjdXJyZW50IGNvbm5lY3Rpb25zLlxuICAgICAqIE11bHRpcGxlIGludm9jYXRpb25zIGRvIG5vdGhpbmcgaWYgd2ViaG9vayBpcyBhbHJlYWR5IGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvc2VXZWJIb29rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VXZWJIb29rKCkge1xuICAgICAgaWYgKCF0aGlzLl93ZWJIb29rKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93ZWJIb29rLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdXNpbmcgd2ViaG9vayBhbmQgaXQgaXMgb3BlbiBpLmUuIGFjY2VwdHMgY29ubmVjdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2hhc09wZW5XZWJIb29rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzT3BlbldlYkhvb2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2ViSG9vayA/IHRoaXMuX3dlYkhvb2suaXNPcGVuKCkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFuIHVwZGF0ZTsgZW1pdHRpbmcgdGhlIHByb3BlciBldmVudHMgYW5kIGV4ZWN1dGluZyByZWdleHBcbiAgICAgKiBjYWxsYmFja3MuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBzaG91bGQgeW91IGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICogd2F5IHRvIGZldGNoIHVwZGF0ZXMsIG90aGVyIHRoYW4gdGhvc2UgcHJvdmlkZWQgYnkgVGVsZWdyYW1Cb3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHVwZGF0ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1cGRhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGUodXBkYXRlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlICVqJywgdXBkYXRlKTtcbiAgICAgIHZhciBtZXNzYWdlID0gdXBkYXRlLm1lc3NhZ2U7XG4gICAgICB2YXIgZWRpdGVkTWVzc2FnZSA9IHVwZGF0ZS5lZGl0ZWRfbWVzc2FnZTtcbiAgICAgIHZhciBjaGFubmVsUG9zdCA9IHVwZGF0ZS5jaGFubmVsX3Bvc3Q7XG4gICAgICB2YXIgZWRpdGVkQ2hhbm5lbFBvc3QgPSB1cGRhdGUuZWRpdGVkX2NoYW5uZWxfcG9zdDtcbiAgICAgIHZhciBidXNpbmVzc0Nvbm5lY3Rpb24gPSB1cGRhdGUuYnVzaW5lc3NfY29ubmVjdGlvbjtcbiAgICAgIHZhciBidXNpbmVzc3NNZXNzYWdlID0gdXBkYXRlLmJ1c2luZXNzX21lc3NhZ2U7XG4gICAgICB2YXIgZWRpdGVkQnVzaW5lc3NNZXNzYWdlID0gdXBkYXRlLmVkaXRlZF9idXNpbmVzc19tZXNzYWdlO1xuICAgICAgdmFyIGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UgPSB1cGRhdGUuZGVsZXRlZF9idXNpbmVzc19tZXNzYWdlcztcbiAgICAgIHZhciBtZXNzYWdlUmVhY3Rpb24gPSB1cGRhdGUubWVzc2FnZV9yZWFjdGlvbjtcbiAgICAgIHZhciBtZXNzYWdlUmVhY3Rpb25Db3VudCA9IHVwZGF0ZS5tZXNzYWdlX3JlYWN0aW9uX2NvdW50O1xuICAgICAgdmFyIGlubGluZVF1ZXJ5ID0gdXBkYXRlLmlubGluZV9xdWVyeTtcbiAgICAgIHZhciBjaG9zZW5JbmxpbmVSZXN1bHQgPSB1cGRhdGUuY2hvc2VuX2lubGluZV9yZXN1bHQ7XG4gICAgICB2YXIgY2FsbGJhY2tRdWVyeSA9IHVwZGF0ZS5jYWxsYmFja19xdWVyeTtcbiAgICAgIHZhciBzaGlwcGluZ1F1ZXJ5ID0gdXBkYXRlLnNoaXBwaW5nX3F1ZXJ5O1xuICAgICAgdmFyIHByZUNoZWNrb3V0UXVlcnkgPSB1cGRhdGUucHJlX2NoZWNrb3V0X3F1ZXJ5O1xuICAgICAgdmFyIHBvbGwgPSB1cGRhdGUucG9sbDtcbiAgICAgIHZhciBwb2xsQW5zd2VyID0gdXBkYXRlLnBvbGxfYW5zd2VyO1xuICAgICAgdmFyIG15Q2hhdE1lbWJlciA9IHVwZGF0ZS5teV9jaGF0X21lbWJlcjtcbiAgICAgIHZhciBjaGF0TWVtYmVyID0gdXBkYXRlLmNoYXRfbWVtYmVyO1xuICAgICAgdmFyIGNoYXRKb2luUmVxdWVzdCA9IHVwZGF0ZS5jaGF0X2pvaW5fcmVxdWVzdDtcbiAgICAgIHZhciBjaGF0Qm9vc3QgPSB1cGRhdGUuY2hhdF9ib29zdDtcbiAgICAgIHZhciByZW1vdmVkQ2hhdEJvb3N0ID0gdXBkYXRlLnJlbW92ZWRfY2hhdF9ib29zdDtcblxuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG1lc3NhZ2UgJWonLCBtZXNzYWdlKTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0ge307XG4gICAgICAgIG1ldGFkYXRhLnR5cGUgPSBUZWxlZ3JhbUJvdC5tZXNzYWdlVHlwZXMuZmluZChmdW5jdGlvbiAobWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZVttZXNzYWdlVHlwZV07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlLCBtZXRhZGF0YSk7XG4gICAgICAgIGlmIChtZXRhZGF0YS50eXBlKSB7XG4gICAgICAgICAgZGVidWcoJ0VtaXR0aW5nICVzOiAlaicsIG1ldGFkYXRhLnR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZW1pdChtZXRhZGF0YS50eXBlLCBtZXNzYWdlLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGV4dCkge1xuICAgICAgICAgIGRlYnVnKCdUZXh0IG1lc3NhZ2UnKTtcbiAgICAgICAgICB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzLnNvbWUoZnVuY3Rpb24gKHJlZykge1xuICAgICAgICAgICAgZGVidWcoJ01hdGNoaW5nICVzIHdpdGggJXMnLCBtZXNzYWdlLnRleHQsIHJlZy5yZWdleHApO1xuXG4gICAgICAgICAgICBpZiAoIShyZWcucmVnZXhwIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICByZWcucmVnZXhwID0gbmV3IFJlZ0V4cChyZWcucmVnZXhwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlZy5yZWdleHAuZXhlYyhtZXNzYWdlLnRleHQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgaW5kZXggc28gd2Ugc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVnZXggZWFjaCB0aW1lXG4gICAgICAgICAgICByZWcucmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBkZWJ1ZygnTWF0Y2hlcyAlcycsIHJlZy5yZWdleHApO1xuICAgICAgICAgICAgcmVnLmNhbGxiYWNrKG1lc3NhZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgdHJ1dGh5IHZhbHVlIGV4aXRzIC5zb21lXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0Lm9wdGlvbnMub25seUZpcnN0TWF0Y2g7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVwbHlfdG9fbWVzc2FnZSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbGJhY2tzIHdhaXRpbmcgZm9yIHRoaXMgbWVzc2FnZVxuICAgICAgICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlcGx5KSB7XG4gICAgICAgICAgICAvLyBNZXNzYWdlIGZyb20gdGhlIHNhbWUgY2hhdFxuICAgICAgICAgICAgaWYgKHJlcGx5LmNoYXRJZCA9PT0gbWVzc2FnZS5jaGF0LmlkKSB7XG4gICAgICAgICAgICAgIC8vIFJlc3BvbmRpbmcgdG8gdGhhdCBtZXNzYWdlXG4gICAgICAgICAgICAgIGlmIChyZXBseS5tZXNzYWdlSWQgPT09IG1lc3NhZ2UucmVwbHlfdG9fbWVzc2FnZS5tZXNzYWdlX2lkKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHJlcGx5LmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWRpdGVkTWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX21lc3NhZ2UgJWonLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfbWVzc2FnZScsIGVkaXRlZE1lc3NhZ2UpO1xuICAgICAgICBpZiAoZWRpdGVkTWVzc2FnZS50ZXh0KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfbWVzc2FnZV90ZXh0JywgZWRpdGVkTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRlZE1lc3NhZ2UuY2FwdGlvbikge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2VfY2FwdGlvbicsIGVkaXRlZE1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxQb3N0KSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaGFubmVsX3Bvc3QgJWonLCBjaGFubmVsUG9zdCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhbm5lbF9wb3N0JywgY2hhbm5lbFBvc3QpO1xuICAgICAgfSBlbHNlIGlmIChlZGl0ZWRDaGFubmVsUG9zdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX2NoYW5uZWxfcG9zdCAlaicsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfY2hhbm5lbF9wb3N0JywgZWRpdGVkQ2hhbm5lbFBvc3QpO1xuICAgICAgICBpZiAoZWRpdGVkQ2hhbm5lbFBvc3QudGV4dCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdF90ZXh0JywgZWRpdGVkQ2hhbm5lbFBvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGl0ZWRDaGFubmVsUG9zdC5jYXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfY2hhbm5lbF9wb3N0X2NhcHRpb24nLCBlZGl0ZWRDaGFubmVsUG9zdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NDb25uZWN0aW9uKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBidXNpbmVzc19jb25uZWN0aW9uICVqJywgYnVzaW5lc3NDb25uZWN0aW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdidXNpbmVzc19jb25uZWN0aW9uJywgYnVzaW5lc3NDb25uZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoYnVzaW5lc3NzTWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgYnVzaW5lc3NfbWVzc2FnZSAlaicsIGJ1c2luZXNzc01lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ2J1c2luZXNzX21lc3NhZ2UnLCBidXNpbmVzc3NNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdGVkQnVzaW5lc3NNZXNzYWdlKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBlZGl0ZWRfYnVzaW5lc3NfbWVzc2FnZSAlaicsIGVkaXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2J1c2luZXNzX21lc3NhZ2UnLCBlZGl0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChkZWxldGVkQnVzaW5lc3NNZXNzYWdlKSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBkZWxldGVkX2J1c2luZXNzX21lc3NhZ2VzICVqJywgZGVsZXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVsZXRlZF9idXNpbmVzc19tZXNzYWdlcycsIGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlUmVhY3Rpb24pIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG1lc3NhZ2VfcmVhY3Rpb24gJWonLCBtZXNzYWdlUmVhY3Rpb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2VfcmVhY3Rpb24nLCBtZXNzYWdlUmVhY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlUmVhY3Rpb25Db3VudCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgbWVzc2FnZV9yZWFjdGlvbl9jb3VudCAlaicsIG1lc3NhZ2VSZWFjdGlvbkNvdW50KTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlX3JlYWN0aW9uX2NvdW50JywgbWVzc2FnZVJlYWN0aW9uQ291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpbmxpbmVRdWVyeSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgaW5saW5lX3F1ZXJ5ICVqJywgaW5saW5lUXVlcnkpO1xuICAgICAgICB0aGlzLmVtaXQoJ2lubGluZV9xdWVyeScsIGlubGluZVF1ZXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvc2VuSW5saW5lUmVzdWx0KSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaG9zZW5faW5saW5lX3Jlc3VsdCAlaicsIGNob3NlbklubGluZVJlc3VsdCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hvc2VuX2lubGluZV9yZXN1bHQnLCBjaG9zZW5JbmxpbmVSZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFja1F1ZXJ5KSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjYWxsYmFja19xdWVyeSAlaicsIGNhbGxiYWNrUXVlcnkpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxiYWNrX3F1ZXJ5JywgY2FsbGJhY2tRdWVyeSk7XG4gICAgICB9IGVsc2UgaWYgKHNoaXBwaW5nUXVlcnkpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHNoaXBwaW5nX3F1ZXJ5ICVqJywgc2hpcHBpbmdRdWVyeSk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2hpcHBpbmdfcXVlcnknLCBzaGlwcGluZ1F1ZXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAocHJlQ2hlY2tvdXRRdWVyeSkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgcHJlX2NoZWNrb3V0X3F1ZXJ5ICVqJywgcHJlQ2hlY2tvdXRRdWVyeSk7XG4gICAgICAgIHRoaXMuZW1pdCgncHJlX2NoZWNrb3V0X3F1ZXJ5JywgcHJlQ2hlY2tvdXRRdWVyeSk7XG4gICAgICB9IGVsc2UgaWYgKHBvbGwpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHBvbGwgJWonLCBwb2xsKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb2xsJywgcG9sbCk7XG4gICAgICB9IGVsc2UgaWYgKHBvbGxBbnN3ZXIpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHBvbGxfYW5zd2VyICVqJywgcG9sbEFuc3dlcik7XG4gICAgICAgIHRoaXMuZW1pdCgncG9sbF9hbnN3ZXInLCBwb2xsQW5zd2VyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhdE1lbWJlcikge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhdF9tZW1iZXIgJWonLCBjaGF0TWVtYmVyKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGF0X21lbWJlcicsIGNoYXRNZW1iZXIpO1xuICAgICAgfSBlbHNlIGlmIChteUNoYXRNZW1iZXIpIHtcbiAgICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG15X2NoYXRfbWVtYmVyICVqJywgbXlDaGF0TWVtYmVyKTtcbiAgICAgICAgdGhpcy5lbWl0KCdteV9jaGF0X21lbWJlcicsIG15Q2hhdE1lbWJlcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXRKb2luUmVxdWVzdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgbXlfY2hhdF9tZW1iZXIgJWonLCBjaGF0Sm9pblJlcXVlc3QpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYXRfam9pbl9yZXF1ZXN0JywgY2hhdEpvaW5SZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhdEJvb3N0KSB7XG4gICAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaGF0X2Jvb3N0ICVqJywgY2hhdEJvb3N0KTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGF0X2Jvb3N0JywgY2hhdEJvb3N0KTtcbiAgICAgIH0gZWxzZSBpZiAocmVtb3ZlZENoYXRCb29zdCkge1xuICAgICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgcmVtb3ZlZF9jaGF0X2Jvb3N0ICVqJywgcmVtb3ZlZENoYXRCb29zdCk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZF9jaGF0X2Jvb3N0JywgcmVtb3ZlZENoYXRCb29zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFN0YXJ0IFRlbGVncmFtIEJvdCBBUEkgbWV0aG9kcyAqL1xuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVjZWl2ZSBpbmNvbWluZyB1cGRhdGVzIHVzaW5nIGxvbmcgcG9sbGluZy5cbiAgICAqIFRoaXMgbWV0aG9kIGhhcyBhbiBbb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlXVtnZXRVcGRhdGVzLXYwLjI1LjBdXG4gICAgKiB0aGF0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAgKlxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVwZGF0ZXNcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRVcGRhdGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXBkYXRlcygpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgd2FzIGdldFVwZGF0ZXModGltZW91dCwgbGltaXQsIG9mZnNldCkuXG4gICAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAgICogY29uc2lzdGVuY3kgb2YgdGhlIG1ldGhvZCBzaWduYXR1cmVzIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkgKi9cbiAgICAgIGlmICgodHlwZW9mIGZvcm0gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGZvcm0pKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIGdldFVwZGF0ZXModGltZW91dCwgbGltaXQsIG9mZnNldCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yNS4wJyk7XG4gICAgICAgIGZvcm0gPSB7XG4gICAgICAgICAgdGltZW91dDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGxpbWl0OiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRVcGRhdGVzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYW4gdXJsIHRvIHJlY2VpdmUgaW5jb21pbmcgdXBkYXRlcyB2aWEgYW4gb3V0Z29pbmcgd2ViSG9vay5cbiAgICAgKiBUaGlzIG1ldGhvZCBoYXMgYW4gW29sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZV1bc2V0V2ViSG9vay12MC4yNS4wXVxuICAgICAqIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdXJsIFVSTCB3aGVyZSBUZWxlZ3JhbSB3aWxsIG1ha2UgSFRUUCBQb3N0LiBMZWF2ZSBlbXB0eSB0b1xuICAgICAqIGRlbGV0ZSB3ZWJIb29rLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfSBbb3B0aW9ucy5jZXJ0aWZpY2F0ZV0gUEVNIGNlcnRpZmljYXRlIGtleSAocHVibGljKS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnNlY3JldF90b2tlbl0gT3B0aW9uYWwgc2VjcmV0IHRva2VuIHRvIGJlIHNlbnQgaW4gYSBoZWFkZXIgYFgtVGVsZWdyYW0tQm90LUFwaS1TZWNyZXQtVG9rZW5gIGluIGV2ZXJ5IHdlYmhvb2sgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHdlYmhvb2tcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0V2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdlYkhvb2sodXJsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSB3YXMgc2V0V2ViSG9vayh1cmwsIGNlcnQpLlxuICAgICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgICB2YXIgY2VydCA9IHZvaWQgMDtcbiAgICAgIC8vIE5vdGU6ICdvcHRpb25zJyBjb3VsZCBiZSBhbiBvYmplY3QsIGlmIGEgc3RyZWFtIHdhcyBwcm92aWRlZCAoaW4gcGxhY2Ugb2YgJ2NlcnQnKVxuICAgICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zIGluc3RhbmNlb2Ygc3RyZWFtLlN0cmVhbSkge1xuICAgICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIHNldFdlYkhvb2sodXJsLCBjZXJ0KSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI1LjAnKTtcbiAgICAgICAgY2VydCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VydCA9IG9wdGlvbnMuY2VydGlmaWNhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMudXJsID0gdXJsO1xuXG4gICAgICBpZiAoY2VydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdjZXJ0aWZpY2F0ZScsIGNlcnQsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgICAgb3B0cy5xcy5jZXJ0aWZpY2F0ZSA9IHNlbmREYXRhWzFdO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFdlYkhvb2snLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVtb3ZlIHdlYmhvb2sgaW50ZWdyYXRpb24gaWYgeW91IGRlY2lkZSB0b1xuICAgICAqIHN3aXRjaCBiYWNrIHRvIGdldFVwZGF0ZXMuIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZXdlYmhvb2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlV2ViSG9vaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVdlYkhvb2soKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVXZWJob29rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgY3VycmVudCB3ZWJob29rIHN0YXR1cy5cbiAgICAgKiBPbiBzdWNjZXNzLCByZXR1cm5zIGEgW1dlYmhvb2tJbmZvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3dlYmhvb2tpbmZvKSBvYmplY3QuXG4gICAgICogSWYgdGhlIGJvdCBpcyB1c2luZyBnZXRVcGRhdGVzLCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiB1cmwgZmllbGQgZW1wdHkuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0d2ViaG9va2luZm9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0V2ViSG9va0luZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXZWJIb29rSW5mbygpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFdlYmhvb2tJbmZvJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIG1ldGhvZCBmb3IgdGVzdGluZyB5b3VyIGJvdCdzIGF1dGhlbnRpY2F0aW9uIHRva2VuLiBSZXF1aXJlcyBubyBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJvdCBpbiBmb3JtIG9mIGEgW1VzZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcikgb2JqZWN0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1lKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TWUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbG9nIG91dCB5b3VyIGJvdCBmcm9tIHRoZSBjbG91ZCBCb3QgQVBJIHNlcnZlciBiZWZvcmUgbGF1bmNoaW5nIHRoZSBib3QgbG9jYWxseS5cbiAgICAgKiBZb3UgbXVzdCBsb2cgb3V0IHRoZSBib3QgYmVmb3JlIHJ1bm5pbmcgaXQgbG9jYWxseSwgb3RoZXJ3aXNlIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBib3Qgd2lsbCByZWNlaXZlIHVwZGF0ZXMuXG4gICAgICogQWZ0ZXIgYSBzdWNjZXNzZnVsIGNhbGwsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGxvZyBpbiBhZ2FpbiB1c2luZyB0aGUgc2FtZSB0b2tlbiBmb3IgMTAgbWludXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbG9nb3V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xvZ091dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ091dCgpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2xvZ091dCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjbG9zZSB0aGUgYm90IGluc3RhbmNlIGJlZm9yZSBtb3ZpbmcgaXQgZnJvbSBvbmUgbG9jYWwgc2VydmVyIHRvIGFub3RoZXIuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZXJyb3IgNDI5IGluIHRoZSBmaXJzdCAxMCBtaW51dGVzIGFmdGVyIHRoZSBib3QgaXMgbGF1bmNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Nsb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjbG9zZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBUZXh0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIHNlbnRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZE1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kTWVzc2FnZShjaGF0SWQsIHRleHQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS50ZXh0ID0gdGV4dDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kTWVzc2FnZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIG1lc3NhZ2VzIG9mIGFueSBraW5kLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBmcm9tQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCB3aGVyZSB0aGVcbiAgICAgKiBvcmlnaW5hbCBtZXNzYWdlIHdhcyBzZW50IChvciBjaGFubmVsIHVzZXJuYW1lIGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IG1lc3NhZ2VJZCAgVW5pcXVlIG1lc3NhZ2UgaWRlbnRpZmllciBpbiB0aGUgY2hhdCBzcGVjaWZpZWQgaW4gZnJvbUNoYXRJZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZvcndhcmRtZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ZvcndhcmRNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5mcm9tX2NoYXRfaWQgPSBmcm9tQ2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2ZvcndhcmRNZXNzYWdlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBmb3J3YXJkIG11bHRpcGxlIG1lc3NhZ2VzIG9mIGFueSBraW5kLlxuICAgICAqIElmIHNvbWUgb2YgdGhlIHNwZWNpZmllZCBtZXNzYWdlcyBjYW4ndCBiZSBmb3VuZCBvciBmb3J3YXJkZWQsIHRoZXkgYXJlIHNraXBwZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJvbUNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgd2hlcmUgdGhlXG4gICAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudCAob3IgY2hhbm5lbCB1c2VybmFtZSBpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtBcnJheTxOdW1iZXJ8U3RyaW5nPn0gbWVzc2FnZUlkcyBJZGVudGlmaWVycyBvZiAxLTEwMCBtZXNzYWdlcyBpbiB0aGUgY2hhdCBmcm9tX2NoYXRfaWQgdG8gZm9yd2FyZC5cbiAgICAgKiBUaGUgaWRlbnRpZmllcnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gYSBzdHJpY3RseSBpbmNyZWFzaW5nIG9yZGVyLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEFuIGFycmF5IG9mIE1lc3NhZ2VJZCBvZiB0aGUgc2VudCBtZXNzYWdlcyBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZvcndhcmRtZXNzYWdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3J3YXJkTWVzc2FnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3J3YXJkTWVzc2FnZXMoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWRzKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZHMgPSBtZXNzYWdlSWRzO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2ZvcndhcmRNZXNzYWdlcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IG1lc3NhZ2VzIG9mIGFueSBraW5kLiAqKlNlcnZpY2UgbWVzc2FnZXMgYW5kIGludm9pY2UgbWVzc2FnZXMgY2FuJ3QgYmUgY29waWVkLioqXG4gICAgICogVGhlIG1ldGhvZCBpcyBhbmFsb2dvdXMgdG8gdGhlIG1ldGhvZCBmb3J3YXJkTWVzc2FnZXMsIGJ1dCB0aGUgY29waWVkIG1lc3NhZ2UgZG9lc24ndFxuICAgICAqIGhhdmUgYSBsaW5rIHRvIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxuICAgICAqIFJldHVybnMgdGhlIE1lc3NhZ2VJZCBvZiB0aGUgc2VudCBtZXNzYWdlIG9uIHN1Y2Nlc3MuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJvbUNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgd2hlcmUgdGhlXG4gICAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudFxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IG1lc3NhZ2VJZCAgVW5pcXVlIG1lc3NhZ2UgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBbTWVzc2FnZUlkXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2VpZCkgb2YgdGhlIHNlbnQgbWVzc2FnZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvcHlNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weU1lc3NhZ2UoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5mcm9tX2NoYXRfaWQgPSBmcm9tQ2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NvcHlNZXNzYWdlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjb3B5IG1lc3NhZ2VzIG9mIGFueSBraW5kLiBJZiBzb21lIG9mIHRoZSBzcGVjaWZpZWQgbWVzc2FnZXMgY2FuJ3QgYmUgZm91bmQgb3IgY29waWVkLCB0aGV5IGFyZSBza2lwcGVkLlxuICAgICAqIFNlcnZpY2UgbWVzc2FnZXMsIGdpdmVhd2F5IG1lc3NhZ2VzLCBnaXZlYXdheSB3aW5uZXJzIG1lc3NhZ2VzLCBhbmQgaW52b2ljZSBtZXNzYWdlcyBjYW4ndCBiZSBjb3BpZWQuXG4gICAgICogUmV0dXJucyB0aGUgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2Ugb24gc3VjY2Vzcy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdFxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgICAqIG9yaWdpbmFsIG1lc3NhZ2Ugd2FzIHNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbWVzc2FnZUlkcyAgSWRlbnRpZmllcnMgb2YgMS0xMDAgbWVzc2FnZXMgaW4gdGhlIGNoYXQgZnJvbV9jaGF0X2lkIHRvIGNvcHkuXG4gICAgICogVGhlIGlkZW50aWZpZXJzIG11c3QgYmUgc3BlY2lmaWVkIGluIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBvcmRlci5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBbiBhcnJheSBvZiBNZXNzYWdlSWQgb2YgdGhlIHNlbnQgbWVzc2FnZXNcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY29weW1lc3NhZ2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NvcHlNZXNzYWdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlNZXNzYWdlcyhjaGF0SWQsIGZyb21DaGF0SWQsIG1lc3NhZ2VJZHMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5mcm9tX2NoYXRfaWQgPSBmcm9tQ2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkcyA9IHN0cmluZ2lmeShtZXNzYWdlSWRzKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjb3B5TWVzc2FnZXMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBwaG90b1xuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gcGhvdG8gQSBmaWxlIHBhdGggb3IgYSBTdHJlYW0uIENhblxuICAgICAqIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwaG90b1xuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kUGhvdG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kUGhvdG8oY2hhdElkLCBwaG90bykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3Bob3RvJywgcGhvdG8sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnBob3RvID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRQaG90bycsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogU2VuZCBhdWRpb1xuICAgICpcbiAgICAqICoqWW91ciBhdWRpbyBtdXN0IGJlIGluIHRoZSAuTVAzIG9yIC5NNEEgZm9ybWF0LioqXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGF1ZGlvIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRhdWRpb1xuICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZEF1ZGlvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEF1ZGlvKGNoYXRJZCwgYXVkaW8pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnYXVkaW8nLCBhdWRpbywgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMuYXVkaW8gPSBzZW5kRGF0YVsxXTtcbiAgICAgICAgdGhpcy5fZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQXVkaW8nLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFNlbmQgRG9jdW1lbnRcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBkb2MgQSBmaWxlIHBhdGgsIFN0cmVhbSBvciBCdWZmZXIuXG4gICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICogQHJldHVybiB7UHJvbWlzZX0gIE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmREb2N1bWVudFxuICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZERvY3VtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZERvY3VtZW50KGNoYXRJZCwgZG9jKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnZG9jdW1lbnQnLCBkb2MsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLmRvY3VtZW50ID0gc2VuZERhdGFbMV07XG4gICAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZERvY3VtZW50Jywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgdmlkZW8gZmlsZXMsICoqVGVsZWdyYW0gY2xpZW50cyBzdXBwb3J0IG1wNCB2aWRlb3MqKiAob3RoZXIgZm9ybWF0cyBtYXkgYmUgc2VudCBhcyBEb2N1bWVudCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHZpZGVvIEEgZmlsZSBwYXRoIG9yIFN0cmVhbS5cbiAgICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlb1xuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kVmlkZW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kVmlkZW8oY2hhdElkLCB2aWRlbykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3ZpZGVvJywgdmlkZW8sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnZpZGVvID0gc2VuZERhdGFbMV07XG4gICAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWaWRlbycsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuaW1hdGlvbiBmaWxlcyAoR0lGIG9yIEguMjY0L01QRUctNCBBVkMgdmlkZW8gd2l0aG91dCBzb3VuZCkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBhbmltYXRpb24gQSBmaWxlIHBhdGgsIFN0cmVhbSBvciBCdWZmZXIuXG4gICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kYW5pbWF0aW9uXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRBbmltYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kQW5pbWF0aW9uKGNoYXRJZCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnYW5pbWF0aW9uJywgYW5pbWF0aW9uLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5hbmltYXRpb24gPSBzZW5kRGF0YVsxXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZEFuaW1hdGlvbicsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgdm9pY2VcbiAgICAgKlxuICAgICAqICoqWW91ciBhdWRpbyBtdXN0IGJlIGluIGFuIC5PR0cgZmlsZSBlbmNvZGVkIHdpdGggT1BVUyoqLCBvciBpbiAuTVAzIGZvcm1hdCwgb3IgaW4gLk00QSBmb3JtYXQgKG90aGVyIGZvcm1hdHMgbWF5IGJlIHNlbnQgYXMgQXVkaW8gb3IgRG9jdW1lbnQpXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB2b2ljZSBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2b2ljZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kVm9pY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kVm9pY2UoY2hhdElkLCB2b2ljZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3ZvaWNlJywgdm9pY2UsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnZvaWNlID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWb2ljZScsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHZpZGVvIG1lc3NhZ2VzXG4gICAgICogVGVsZWdyYW0gY2xpZW50cyBzdXBwb3J0ICoqcm91bmRlZCBzcXVhcmUgTVBFRzQgdmlkZW9zKiogb2YgdXAgdG8gMSBtaW51dGUgbG9uZy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHZpZGVvTm90ZSBBIGZpbGUgcGF0aCBvciBTdHJlYW0uXG4gICAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBpbmZvIFRoZSBsZW5ndGggcGFyYW1ldGVyIGlzIGFjdHVhbGx5IG9wdGlvbmFsLiBIb3dldmVyLCB0aGUgQVBJIChhdCB0aW1lIG9mIHdyaXRpbmcpIHJlcXVpcmVzIHlvdSB0byBhbHdheXMgcHJvdmlkZSBpdCB1bnRpbCBpdCBpcyBmaXhlZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvbm90ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRWaWRlb05vdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kVmlkZW9Ob3RlKGNoYXRJZCwgdmlkZW9Ob3RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgndmlkZW9fbm90ZScsIHZpZGVvTm90ZSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMudmlkZW9fbm90ZSA9IHNlbmREYXRhWzFdO1xuICAgICAgICB0aGlzLl9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kVmlkZW9Ob3RlJywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYSBncm91cCBvZiBwaG90b3Mgb3IgdmlkZW9zIGFzIGFuIGFsYnVtLlxuICAgICAqXG4gICAgICogKipEb2N1bWVudHMgYW5kIGF1ZGlvIGZpbGVzIGNhbiBiZSBvbmx5IGdyb3VwZWQgaW4gYW4gYWxidW0gd2l0aCBtZXNzYWdlcyBvZiB0aGUgc2FtZSB0eXBlKipcbiAgICAgKlxuICAgICAqIElmIHlvdSB3aXNoIHRvIFtzcGVjaWZ5IGZpbGUgb3B0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlcyksXG4gICAgICogYWRkIGEgYGZpbGVPcHRpb25zYCBwcm9wZXJ0eSB0byB0aGUgdGFyZ2V0IGlucHV0IGluIGBtZWRpYWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG1lZGlhIEEgSlNPTi1zZXJpYWxpemVkIGFycmF5IGRlc2NyaWJpbmcgcGhvdG9zIGFuZCB2aWRlb3MgdG8gYmUgc2VudCwgbXVzdCBpbmNsdWRlIDLigJMxMCBpdGVtc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGFuIGFycmF5IG9mIHRoZSBzZW50IFtNZXNzYWdlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKVxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVkaWFncm91cFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kTWVkaWFHcm91cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRNZWRpYUdyb3VwKGNoYXRJZCwgbWVkaWEpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuXG4gICAgICBvcHRzLmZvcm1EYXRhID0ge307XG4gICAgICB2YXIgaW5wdXRNZWRpYSA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBtZWRpYVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgaW5wdXQpO1xuICAgICAgICAgIGRlbGV0ZSBwYXlsb2FkLm1lZGlhO1xuICAgICAgICAgIGRlbGV0ZSBwYXlsb2FkLmZpbGVPcHRpb25zO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXR0YWNoTmFtZSA9IFN0cmluZyhpbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBfZm9ybWF0U2VuZERhdGE0ID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoYXR0YWNoTmFtZSwgaW5wdXQubWVkaWEsIGlucHV0LmZpbGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBfZm9ybWF0U2VuZERhdGE1ID0gX3NsaWNlZFRvQXJyYXkoX2Zvcm1hdFNlbmREYXRhNCwgMiksXG4gICAgICAgICAgICAgICAgZm9ybURhdGEgPSBfZm9ybWF0U2VuZERhdGE1WzBdLFxuICAgICAgICAgICAgICAgIGZpbGVJZCA9IF9mb3JtYXRTZW5kRGF0YTVbMV07XG5cbiAgICAgICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgICAgICBvcHRzLmZvcm1EYXRhW2F0dGFjaE5hbWVdID0gZm9ybURhdGFbYXR0YWNoTmFtZV07XG4gICAgICAgICAgICAgIHBheWxvYWQubWVkaWEgPSAnYXR0YWNoOi8vJyArIGF0dGFjaE5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gZmlsZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dE1lZGlhLnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wdHMucXMubWVkaWEgPSBzdHJpbmdpZnkoaW5wdXRNZWRpYSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kTWVkaWFHcm91cCcsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgbG9jYXRpb24uXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgcG9pbnQgb24gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge0Zsb2F0fSBsYXRpdHVkZSBMYXRpdHVkZSBvZiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSAge0Zsb2F0fSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIGxvY2F0aW9uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRsb2NhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kTG9jYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kTG9jYXRpb24oY2hhdElkLCBsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICAgIGZvcm0ubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRMb2NhdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBsaXZlIGxvY2F0aW9uIG1lc3NhZ2VzIHNlbnQgYnlcbiAgICAgKiB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgICAqXG4gICAgICogIEEgbG9jYXRpb24gKipjYW4gYmUgZWRpdGVkIHVudGlsIGl0cyBsaXZlX3BlcmlvZCBleHBpcmVzIG9yIGVkaXRpbmcgaXMgZXhwbGljaXRseSBkaXNhYmxlZCBieSBhIGNhbGwgdG8gW3N0b3BNZXNzYWdlTGl2ZUxvY2F0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0b3BtZXNzYWdlbGl2ZWxvY2F0aW9uKSoqXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3JcbiAgICAgKiBpbmxpbmVfbWVzc2FnZV9pZCBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWQuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdlbGl2ZWxvY2F0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXRNZXNzYWdlTGl2ZUxvY2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1lc3NhZ2VMaXZlTG9jYXRpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZUxpdmVMb2NhdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc3RvcCB1cGRhdGluZyBhIGxpdmUgbG9jYXRpb24gbWVzc2FnZSBzZW50IGJ5XG4gICAgICogdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKSBiZWZvcmUgbGl2ZV9wZXJpb2QgZXhwaXJlcy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB5b3UgbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvclxuICAgICAqIGlubGluZV9tZXNzYWdlX2lkIGluIHlvdXIgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWQuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0b3BtZXNzYWdlbGl2ZWxvY2F0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3BNZXNzYWdlTGl2ZUxvY2F0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcE1lc3NhZ2VMaXZlTG9jYXRpb24oKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzdG9wTWVzc2FnZUxpdmVMb2NhdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHZlbnVlLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGluZm9ybWF0aW9uIGFib3V0IGEgdmVudWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgTmFtZSBvZiB0aGUgdmVudWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3MgQWRkcmVzcyBvZiB0aGUgdmVudWVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWQuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2ZW51ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kVmVudWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kVmVudWUoY2hhdElkLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aXRsZSwgYWRkcmVzcykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICAgIGZvcm0udGl0bGUgPSB0aXRsZTtcbiAgICAgIGZvcm0uYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFZlbnVlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgY29udGFjdC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBwaG9uZSBjb250YWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcGhvbmVOdW1iZXIgQ29udGFjdCdzIHBob25lIG51bWJlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlyc3ROYW1lIENvbnRhY3QncyBmaXJzdCBuYW1lXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRjb250YWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRDb250YWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZENvbnRhY3QoY2hhdElkLCBwaG9uZU51bWJlciwgZmlyc3ROYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ucGhvbmVfbnVtYmVyID0gcGhvbmVOdW1iZXI7XG4gICAgICBmb3JtLmZpcnN0X25hbWUgPSBmaXJzdE5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZENvbnRhY3QnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBwb2xsLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGEgbmF0aXZlIHBvbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcXVlc3Rpb24gUG9sbCBxdWVzdGlvbiwgMS0zMDAgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSAge0FycmF5fSBwb2xsT3B0aW9ucyBQb2xsIG9wdGlvbnMsIGJldHdlZW4gMi0xMCBvcHRpb25zIChvbmx5IDEtMTAwIGNoYXJhY3RlcnMgZWFjaClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHBvbGxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZFBvbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kUG9sbChjaGF0SWQsIHF1ZXN0aW9uLCBwb2xsT3B0aW9ucykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnF1ZXN0aW9uID0gcXVlc3Rpb247XG4gICAgICBmb3JtLm9wdGlvbnMgPSBzdHJpbmdpZnkocG9sbE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRQb2xsJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgRGljZVxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuIGFuaW1hdGVkIGVtb2ppIHRoYXQgd2lsbCBkaXNwbGF5IGEgcmFuZG9tIHZhbHVlLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGRpY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZERpY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kRGljZShjaGF0SWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2RpY2UnKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kRGljZScsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgY2hhdCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3UgbmVlZCB0byB0ZWxsIHRoZSB1c2VyIHRoYXQgc29tZXRoaW5nIGlzIGhhcHBlbmluZyBvbiB0aGUgYm90J3Mgc2lkZS5cbiAgICAgKiAqKlRoZSBzdGF0dXMgaXMgc2V0IGZvciA1IHNlY29uZHMgb3IgbGVzcyoqICh3aGVuIGEgbWVzc2FnZSBhcnJpdmVzIGZyb20geW91ciBib3QsIFRlbGVncmFtIGNsaWVudHMgY2xlYXIgaXRzIHR5cGluZyBzdGF0dXMpLlxuICAgICAqXG4gICAgICogIEFjdGlvbiBgdHlwaW5nYCBmb3IgW3RleHQgbWVzc2FnZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2UpLFxuICAgICAqIGB1cGxvYWRfcGhvdG9gIGZvciBbcGhvdG9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwaG90byksIGByZWNvcmRfdmlkZW9gIG9yIGB1cGxvYWRfdmlkZW9gIGZvciBbdmlkZW9zXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmR2aWRlbyksXG4gICAgICogYHJlY29yZF92b2ljZWAgb3IgYHVwbG9hZF92b2ljZWAgZm9yIFt2b2ljZSBub3Rlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdm9pY2UpLCBgdXBsb2FkX2RvY3VtZW50YCBmb3IgW2dlbmVyYWwgZmlsZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGRvY3VtZW50KSxcbiAgICAgKiBgY2hvb3NlX3N0aWNrZXJgIGZvciBbc3RpY2tlcnNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHN0aWNrZXIpLCBgZmluZF9sb2NhdGlvbmAgZm9yIFtsb2NhdGlvbiBkYXRhXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRsb2NhdGlvbiksXG4gICAgICogYHJlY29yZF92aWRlb19ub3RlYCBvciBgdXBsb2FkX3ZpZGVvX25vdGVgIGZvciBbdmlkZW8gbm90ZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvbm90ZSkuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gYWN0aW9uIFR5cGUgb2YgYWN0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGNoYXRhY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VuZENoYXRBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kQ2hhdEFjdGlvbihjaGF0SWQsIGFjdGlvbikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQ2hhdEFjdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBjaG9zZW4gcmVhY3Rpb25zIG9uIGEgbWVzc2FnZS5cbiAgICAgKiAtIFNlcnZpY2UgbWVzc2FnZXMgY2FuJ3QgYmUgcmVhY3RlZCB0by5cbiAgICAgKiAtIEF1dG9tYXRpY2FsbHkgZm9yd2FyZGVkIG1lc3NhZ2VzIGZyb20gYSBjaGFubmVsIHRvIGl0cyBkaXNjdXNzaW9uIGdyb3VwIGhhdmUgdGhlIHNhbWUgYXZhaWxhYmxlIHJlYWN0aW9ucyBhcyBtZXNzYWdlcyBpbiB0aGUgY2hhbm5lbC5cbiAgICAgKiAtIEluIGFsYnVtcywgYm90cyBtdXN0IHJlYWN0IHRvIHRoZSBmaXJzdCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBAY2hhbm5lbHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbWVzc2FnZUlkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW4+fSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0bWVzc2FnZXJlYWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE1lc3NhZ2VSZWFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1lc3NhZ2VSZWFjdGlvbihjaGF0SWQsIG1lc3NhZ2VJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfaWQgPSBtZXNzYWdlSWQ7XG4gICAgICBpZiAoZm9ybS5yZWFjdGlvbikge1xuICAgICAgICBmb3JtLnJlYWN0aW9uID0gc3RyaW5naWZ5KGZvcm0ucmVhY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE1lc3NhZ2VSZWFjdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGEgbGlzdCBvZiBwcm9maWxlIHBpY3R1cmVzIGZvciBhIHVzZXIuXG4gICAgICogUmV0dXJucyBhIFtVc2VyUHJvZmlsZVBob3Rvc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1c2VycHJvZmlsZXBob3Rvcykgb2JqZWN0LlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBhbiBbb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlXVtnZXRVc2VyUHJvZmlsZVBob3Rvcy12MC4yNS4wXVxuICAgICAqIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgUmV0dXJucyBhIFtVc2VyUHJvZmlsZVBob3Rvc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1c2VycHJvZmlsZXBob3Rvcykgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVzZXJwcm9maWxlcGhvdG9zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFVzZXJQcm9maWxlUGhvdG9zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXNlclByb2ZpbGVQaG90b3ModXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIHdhcyBnZXRVc2VyUHJvZmlsZVBob3Rvcyh1c2VySWQsIG9mZnNldCwgbGltaXQpLlxuICAgICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgICBpZiAoKHR5cGVvZiBmb3JtID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihmb3JtKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBnZXRVc2VyUHJvZmlsZVBob3Rvcyh1c2VySWQsIG9mZnNldCwgbGltaXQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjUuMCcpO1xuICAgICAgICBmb3JtID0ge1xuICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzWzFdLFxuICAgICAgICAgIGxpbWl0OiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICB9XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0VXNlclByb2ZpbGVQaG90b3MnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBiYXNpYyBpbmZvIGFib3V0IGEgZmlsZSBhbmQgcHJlcGFyZSBpdCBmb3IgZG93bmxvYWRpbmcuXG4gICAgICpcbiAgICAgKiBBdHRlbnRpb246ICoqbGluayB3aWxsIGJlIHZhbGlkIGZvciAxIGhvdXIuKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZUlkICBGaWxlIGlkZW50aWZpZXIgdG8gZ2V0IGluZm8gYWJvdXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtGaWxlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZpbGUpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRmaWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEZpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlKGZpbGVJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmZpbGVfaWQgPSBmaWxlSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0RmlsZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGJhbiBhIHVzZXIgaW4gYSBncm91cCwgYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICAgICogSW4gdGhlIGNhc2Ugb2Ygc3VwZXJncm91cHMgYW5kIGNoYW5uZWxzLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvXG4gICAgICAqIHJldHVybiB0byB0aGUgY2hhdCBvbiB0aGVpciBvd24gdXNpbmcgaW52aXRlIGxpbmtzLCBldGMuLCB1bmxlc3MgdW5iYW5uZWQgZmlyc3QuLlxuICAgICAgKlxuICAgICAgKiBUaGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBncm91cCwgc3VwZXJncm91cCBvciBhIGNoYW5uZWwqKiBmb3IgdGhpcyB0byB3b3JrLlxuICAgICAgKlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzcy5cbiAgICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JhbmNoYXRtZW1iZXJcbiAgICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JhbkNoYXRNZW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYW5DaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdiYW5DaGF0TWVtYmVyJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHVuYmFuIGEgcHJldmlvdXNseSBraWNrZWQgdXNlciBpbiBhIHN1cGVyZ3JvdXAuXG4gICAgKiBUaGUgdXNlciB3aWxsIG5vdCByZXR1cm4gdG8gdGhlIGdyb3VwIGF1dG9tYXRpY2FsbHksIGJ1dCB3aWxsIGJlXG4gICAgKiBhYmxlIHRvIGpvaW4gdmlhIGxpbmssIGV0Yy5cbiAgICAqXG4gICAgKiBUaGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yKiogaW4gdGhlIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbCBmb3IgdGhpcyB0byB3b3JrLlxuICAgICpcbiAgICAqICoqQnkgZGVmYXVsdCoqLCB0aGlzIG1ldGhvZCBndWFyYW50ZWVzIHRoYXQgYWZ0ZXIgdGhlIGNhbGwgdGhlIHVzZXIgaXMgbm90IGEgbWVtYmVyIG9mIHRoZSBjaGF0LCBidXQgd2lsbCBiZSBhYmxlIHRvIGpvaW4gaXQuXG4gICAgKiBTbyAqKmlmIHRoZSB1c2VyIGlzIGEgbWVtYmVyIG9mIHRoZSBjaGF0IHRoZXkgd2lsbCBhbHNvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2hhdCoqLiBJZiB5b3UgZG9uJ3Qgd2FudCB0aGlzLCB1c2UgdGhlIHBhcmFtZXRlciAqb25seV9pZl9iYW5uZWQqXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmJhbmNoYXRtZW1iZXJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmJhbkNoYXRNZW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJhbkNoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VuYmFuQ2hhdE1lbWJlcicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXN0cmljdCBhIHVzZXIgaW4gYSBzdXBlcmdyb3VwLlxuICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgc3VwZXJncm91cCoqIGZvciB0aGlzIHRvIHdvcmtcbiAgICAqIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy4gUGFzcyBUcnVlIGZvciBhbGwgYm9vbGVhbiBwYXJhbWV0ZXJzXG4gICAgKiB0byBsaWZ0IHJlc3RyaWN0aW9ucyBmcm9tIGEgdXNlci4gUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmVzdHJpY3RjaGF0bWVtYmVyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzdHJpY3RDaGF0TWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdHJpY3RDaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZXN0cmljdENoYXRNZW1iZXInLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHByb21vdGUgb3IgZGVtb3RlIGEgdXNlciBpbiBhIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsLlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IqKiBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrXG4gICAgICogYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLiBQYXNzIEZhbHNlIGZvciBhbGwgYm9vbGVhbiBwYXJhbWV0ZXJzIHRvIGRlbW90ZSBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcHJvbW90ZWNoYXRtZW1iZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvbW90ZUNoYXRNZW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9tb3RlQ2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncHJvbW90ZUNoYXRNZW1iZXInLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIGN1c3RvbSB0aXRsZSBmb3IgYW4gYWRtaW5pc3RyYXRvciBpbiBhIHN1cGVyZ3JvdXAgcHJvbW90ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY3VzdG9tVGl0bGUgTmV3IGN1c3RvbSB0aXRsZSBmb3IgdGhlIGFkbWluaXN0cmF0b3I7IDAtMTYgY2hhcmFjdGVycywgZW1vamkgYXJlIG5vdCBhbGxvd2VkXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRhZG1pbmlzdHJhdG9yY3VzdG9tdGl0bGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0Q2hhdEFkbWluaXN0cmF0b3JDdXN0b21UaXRsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXRBZG1pbmlzdHJhdG9yQ3VzdG9tVGl0bGUoY2hhdElkLCB1c2VySWQsIGN1c3RvbVRpdGxlKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIGZvcm0uY3VzdG9tX3RpdGxlID0gY3VzdG9tVGl0bGU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdEFkbWluaXN0cmF0b3JDdXN0b21UaXRsZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYmFuIGEgY2hhbm5lbCBjaGF0IGluIGEgc3VwZXJncm91cCBvciBhIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBVbnRpbCB0aGUgY2hhdCBpcyBbdW5iYW5uZWRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5iYW5jaGF0c2VuZGVyY2hhdCksIHRoZSBvd25lciBvZiB0aGUgYmFubmVkIGNoYXQgd29uJ3QgYmUgYWJsZSB0byBzZW5kIG1lc3NhZ2VzIG9uIGJlaGFsZiBvZiBhbnkgb2YgdGhlaXIgY2hhbm5lbHMuXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgc3VwZXJncm91cCBvciBjaGFubmVsKiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0c1xuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2VuZGVyQ2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JhbmNoYXRzZW5kZXJjaGF0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JhbkNoYXRTZW5kZXJDaGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFuQ2hhdFNlbmRlckNoYXQoY2hhdElkLCBzZW5kZXJDaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5zZW5kZXJfY2hhdF9pZCA9IHNlbmRlckNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdiYW5DaGF0U2VuZGVyQ2hhdCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmJhbiBhIHByZXZpb3VzbHkgYmFubmVkIGNoYW5uZWwgY2hhdCBpbiBhIHN1cGVyZ3JvdXAgb3IgY2hhbm5lbC5cbiAgICAqXG4gICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yKiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICogQHBhcmFtICB7TnVtYmVyfSBzZW5kZXJDaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VuYmFuY2hhdHNlbmRlcmNoYXRcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bmJhbkNoYXRTZW5kZXJDaGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iYW5DaGF0U2VuZGVyQ2hhdChjaGF0SWQsIHNlbmRlckNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnNlbmRlcl9jaGF0X2lkID0gc2VuZGVyQ2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VuYmFuQ2hhdFNlbmRlckNoYXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBkZWZhdWx0IGNoYXQgcGVybWlzc2lvbnMgZm9yIGFsbCBtZW1iZXJzLlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgZ3JvdXAgb3IgYSBzdXBlcmdyb3VwKiogZm9yIHRoaXMgdG9cbiAgICAgKiB3b3JrIGFuZCAqKm11c3QgaGF2ZSB0aGUgYGNhbl9yZXN0cmljdF9tZW1iZXJzYCBhZG1pbiByaWdodHMuKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjaGF0UGVybWlzc2lvbnMgTmV3IGRlZmF1bHQgY2hhdCBwZXJtaXNzaW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0cGVybWlzc2lvbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0Q2hhdFBlcm1pc3Npb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2hhdFBlcm1pc3Npb25zKGNoYXRJZCwgY2hhdFBlcm1pc3Npb25zKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ucGVybWlzc2lvbnMgPSBzdHJpbmdpZnkoY2hhdFBlcm1pc3Npb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0UGVybWlzc2lvbnMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIGEgbmV3IHByaW1hcnkgaW52aXRlIGxpbmsgZm9yIGEgY2hhdC4gKipBbnkgcHJldmlvdXNseSBnZW5lcmF0ZWQgcHJpbWFyeSBsaW5rIGlzIHJldm9rZWQqKi5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBFeHBvcnRlZCBpbnZpdGUgbGluayBhcyBTdHJpbmcgb24gc3VjY2Vzcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZXhwb3J0Y2hhdGludml0ZWxpbmtcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZXhwb3J0Q2hhdEludml0ZUxpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRDaGF0SW52aXRlTGluayhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2V4cG9ydENoYXRJbnZpdGVMaW5rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYW4gYWRkaXRpb25hbCBpbnZpdGUgbGluayBmb3IgYSBjaGF0LlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgICAqXG4gICAgICogVGhlIGxpbmsgZ2VuZXJhdGVkIHdpdGggdGhpcyBtZXRob2QgY2FuIGJlIHJldm9rZWQgdXNpbmcgdGhlIG1ldGhvZCBbcmV2b2tlQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmV2b2tlY2hhdGludml0ZWxpbmspXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBpbnZpdGUgbGluayBhcyBbQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdGludml0ZWxpbmspIG9iamVjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjcmVhdGVjaGF0aW52aXRlbGlua1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVDaGF0SW52aXRlTGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNoYXRJbnZpdGVMaW5rKGNoYXRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY3JlYXRlQ2hhdEludml0ZUxpbmsnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgYSBub24tcHJpbWFyeSBpbnZpdGUgbGluayBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaW52aXRlTGluayBUZXh0IHdpdGggdGhlIGludml0ZSBsaW5rIHRvIGVkaXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgZWRpdGVkIGludml0ZSBsaW5rIGFzIGEgW0NoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRpbnZpdGVsaW5rKSBvYmplY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdGNoYXRpbnZpdGVsaW5rXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXRDaGF0SW52aXRlTGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRDaGF0SW52aXRlTGluayhjaGF0SWQsIGludml0ZUxpbmspIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5pbnZpdGVfbGluayA9IGludml0ZUxpbms7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdENoYXRJbnZpdGVMaW5rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXZva2UgYW4gaW52aXRlIGxpbmsgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqIE5vdGU6IElmIHRoZSBwcmltYXJ5IGxpbmsgaXMgcmV2b2tlZCwgYSBuZXcgbGluayBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGludml0ZUxpbmsgVGhlIGludml0ZSBsaW5rIHRvIHJldm9rZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZXZva2VkIGludml0ZSBsaW5rIGFzIFtDaGF0SW52aXRlTGlua10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0aW52aXRlbGluaykgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jldm9rZWNoYXRpbnZpdGVsaW5rXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jldm9rZUNoYXRJbnZpdGVMaW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2b2tlQ2hhdEludml0ZUxpbmsoY2hhdElkLCBpbnZpdGVMaW5rKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uaW52aXRlX2xpbmsgPSBpbnZpdGVMaW5rO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3Jldm9rZUNoYXRJbnZpdGVMaW5rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBhcHByb3ZlIGEgY2hhdCBqb2luIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgKiptdXN0IGhhdmUgdGhlIGBjYW5faW52aXRlX3VzZXJzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0LioqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYXBwcm92ZWNoYXRqb2lucmVxdWVzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhcHByb3ZlQ2hhdEpvaW5SZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwcm92ZUNoYXRKb2luUmVxdWVzdChjaGF0SWQsIHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYXBwcm92ZUNoYXRKb2luUmVxdWVzdCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVjbGluZSBhIGNoYXQgam9pbiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kICoqbXVzdCBoYXZlIHRoZSBgY2FuX2ludml0ZV91c2Vyc2AgYWRtaW5pc3RyYXRvciByaWdodCoqLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlY2xpbmVjaGF0am9pbnJlcXVlc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVjbGluZUNoYXRKb2luUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY2xpbmVDaGF0Sm9pblJlcXVlc3QoY2hhdElkLCB1c2VySWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlY2xpbmVDaGF0Sm9pblJlcXVlc3QnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIG5ldyBwcm9maWxlIHBob3RvIGZvciB0aGUgY2hhdC4gKipQaG90b3MgY2FuJ3QgYmUgY2hhbmdlZCBmb3IgcHJpdmF0ZSBjaGF0cyoqLlxuICAgICAqXG4gICAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHBob3RvIEEgZmlsZSBwYXRoIG9yIGEgU3RyZWFtLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRwaG90b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDaGF0UGhvdG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGF0UGhvdG8oY2hhdElkLCBwaG90bykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3Bob3RvJywgcGhvdG8sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnBob3RvID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRQaG90bycsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSBhIGNoYXQgcGhvdG8uICoqUGhvdG9zIGNhbid0IGJlIGNoYW5nZWQgZm9yIHByaXZhdGUgY2hhdHMqKi5cbiAgICAqXG4gICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZWNoYXRwaG90b1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUNoYXRQaG90bycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNoYXRQaG90byhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZUNoYXRQaG90bycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSB0aXRsZSBvZiBhIGNoYXQuICoqVGl0bGVzIGNhbid0IGJlIGNoYW5nZWQgZm9yIHByaXZhdGUgY2hhdHMqKi5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgTmV3IGNoYXQgdGl0bGUsIDEtMjU1IGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHRpdGxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENoYXRUaXRsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXRUaXRsZShjaGF0SWQsIHRpdGxlKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udGl0bGUgPSB0aXRsZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0VGl0bGUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgZGVzY3JpcHRpb24gb2YgYSBncm91cCwgYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZGVzY3JpcHRpb24gTmV3IGNoYXQgdGl0bGUsIDAtMjU1IGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdGRlc2NyaXB0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENoYXREZXNjcmlwdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXREZXNjcmlwdGlvbihjaGF0SWQsIGRlc2NyaXB0aW9uKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0RGVzY3JpcHRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHBpbiBhIG1lc3NhZ2UgaW4gYSBzdXBlcmdyb3VwLlxuICAgICAqXG4gICAgICogSWYgdGhlIGNoYXQgaXMgbm90IGEgcHJpdmF0ZSBjaGF0LCB0aGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBgY2FuX3Bpbl9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvclxuICAgICAqIHJpZ2h0IGluIGEgc3VwZXJncm91cCBvciBgY2FuX2VkaXRfbWVzc2FnZXNgIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtZXNzYWdlSWQgSWRlbnRpZmllciBvZiBhIG1lc3NhZ2UgdG8gcGluXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3BpbmNoYXRtZXNzYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BpbkNoYXRNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGluQ2hhdE1lc3NhZ2UoY2hhdElkLCBtZXNzYWdlSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3BpbkNoYXRNZXNzYWdlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZW1vdmUgYSBtZXNzYWdlIGZyb20gdGhlIGxpc3Qgb2YgcGlubmVkIG1lc3NhZ2VzIGluIGEgY2hhdFxuICAgICAqXG4gICAgICogSWYgdGhlIGNoYXQgaXMgbm90IGEgcHJpdmF0ZSBjaGF0LCB0aGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBgY2FuX3Bpbl9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvclxuICAgICAqIHJpZ2h0IGluIGEgc3VwZXJncm91cCBvciBgY2FuX2VkaXRfbWVzc2FnZXNgIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gYSBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluY2hhdG1lc3NhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5waW5DaGF0TWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGluQ2hhdE1lc3NhZ2UoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bnBpbkNoYXRNZXNzYWdlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGNoYXQuXG4gICAgKlxuICAgICogSWYgdGhlIGNoYXQgaXMgbm90IGEgcHJpdmF0ZSBjaGF0LCB0aGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBgY2FuX3Bpbl9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvclxuICAgICogcmlnaHQgaW4gYSBzdXBlcmdyb3VwIG9yIGBjYW5fZWRpdF9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvciByaWdodCBpbiBhIGNoYW5uZWwuXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluYWxsY2hhdG1lc3NhZ2VzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5waW5BbGxDaGF0TWVzc2FnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnBpbkFsbENoYXRNZXNzYWdlcyhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VucGluQWxsQ2hhdE1lc3NhZ2VzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBmb3IgeW91ciBib3QgdG8gbGVhdmUgYSBncm91cCwgc3VwZXJncm91cCBvciBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbGVhdmVjaGF0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xlYXZlQ2hhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlQ2hhdChjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2xlYXZlQ2hhdCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHVwIHRvIGRhdGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoYXRcbiAgICAgKiAoY3VycmVudCBuYW1lIG9mIHRoZSB1c2VyIGZvciBvbmUtb24tb25lIGNvbnZlcnNhdGlvbnMsIGN1cnJlbnRcbiAgICAgKiB1c2VybmFtZSBvZiBhIHVzZXIsIGdyb3VwIG9yIGNoYW5uZWwsIGV0Yy4pLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApIG9yIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQ2hhdEZ1bGxJbmZvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRmdWxsaW5mbykgb2JqZWN0IG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhdChjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIGxpc3Qgb2YgYWRtaW5pc3RyYXRvcnMgaW4gYSBjaGF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHJldHVybnMgYW4gQXJyYXkgb2YgW0NoYXRNZW1iZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdG1lbWJlcikgb2JqZWN0cyB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGFsbCBjaGF0IGFkbWluaXN0cmF0b3JzIGV4Y2VwdCBvdGhlciBib3RzLlxuICAgICAqIElmIHRoZSBjaGF0IGlzIGEgZ3JvdXAgb3IgYSBzdXBlcmdyb3VwIGFuZCBubyBhZG1pbmlzdHJhdG9ycyB3ZXJlIGFwcG9pbnRlZCwgb25seSB0aGUgY3JlYXRvciB3aWxsIGJlIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRhZG1pbmlzdHJhdG9yc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGF0QWRtaW5pc3RyYXRvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGF0QWRtaW5pc3RyYXRvcnMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0QWRtaW5pc3RyYXRvcnMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbWVtYmVycyBpbiBhIGNoYXQuXG4gICAgKlxuICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXBcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gSW50IG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVtYmVyY291bnRcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGF0TWVtYmVyQ291bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGF0TWVtYmVyQ291bnQoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0TWVtYmVyQ291bnQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBhIG1lbWJlciBvZiBhIGNoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQ2hhdE1lbWJlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0bWVtYmVyKSBvYmplY3Qgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVtYmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldENoYXRNZW1iZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0TWVtYmVyJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBuZXcgZ3JvdXAgc3RpY2tlciBzZXQgZm9yIGEgc3VwZXJncm91cC5cbiAgICAgKlxuICAgICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSB0aGUgZmllbGQgYGNhbl9zZXRfc3RpY2tlcl9zZXRgIG9wdGlvbmFsbHkgcmV0dXJuZWQgaW4gW2dldENoYXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdCkgcmVxdWVzdHMgdG8gY2hlY2sgaWYgdGhlIGJvdCBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlclNldE5hbWUgTmFtZSBvZiB0aGUgc3RpY2tlciBzZXQgdG8gYmUgc2V0IGFzIHRoZSBncm91cCBzdGlja2VyIHNldFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0c3RpY2tlcnNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDaGF0U3RpY2tlclNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXRTdGlja2VyU2V0KGNoYXRJZCwgc3RpY2tlclNldE5hbWUpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5zdGlja2VyX3NldF9uYW1lID0gc3RpY2tlclNldE5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdFN0aWNrZXJTZXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSBhIGdyb3VwIHN0aWNrZXIgc2V0IGZyb20gYSBzdXBlcmdyb3VwLlxuICAgICAqXG4gICAgICogVXNlIHRoZSBmaWVsZCBgY2FuX3NldF9zdGlja2VyX3NldGAgb3B0aW9uYWxseSByZXR1cm5lZCBpbiBbZ2V0Q2hhdF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0KSByZXF1ZXN0cyB0byBjaGVjayBpZiB0aGUgYm90IGNhbiB1c2UgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZWNoYXRzdGlja2Vyc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUNoYXRTdGlja2VyU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ2hhdFN0aWNrZXJTZXQoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVDaGF0U3RpY2tlclNldCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGN1c3RvbSBlbW9qaSBzdGlja2Vycywgd2hpY2ggY2FuIGJlIHVzZWQgYXMgYSBmb3J1bSB0b3BpYyBpY29uIGJ5IGFueSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEFycmF5IG9mIFtTdGlja2VyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0aWNrZXIpIG9iamVjdHNcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Zm9ydW10b3BpY2ljb25zdGlja2Vyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGb3J1bVRvcGljSWNvblN0aWNrZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ydW1Ub3BpY0ljb25TdGlja2VycyhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEZvcnVtVG9waWNJY29uU3RpY2tlcnMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjcmVhdGVkIHRvcGljIGFzIGEgW0ZvcnVtVG9waWNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZm9ydW10b3BpYykgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBUb3BpYyBuYW1lLCAxLTEyOCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZWZvcnVtdG9waWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlRm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZvcnVtVG9waWMoY2hhdElkLCBuYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY3JlYXRlRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBuYW1lIGFuZCBpY29uIG9mIGEgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLCB1bmxlc3MgaXQgaXMgdGhlIGNyZWF0b3Igb2YgdGhlIHRvcGljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0Zm9ydW10b3BpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0Rm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRGb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdEZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsb3NlIGFuIG9wZW4gdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cywgdW5sZXNzIGl0IGlzIHRoZSBjcmVhdG9yIG9mIHRoZSB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2xvc2Vmb3J1bXRvcGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlRm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlRm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfdGhyZWFkX2lkID0gbWVzc2FnZVRocmVhZElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Nsb3NlRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVvcGVuIGEgY2xvc2VkIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMsIHVubGVzcyBpdCBpcyB0aGUgY3JlYXRvciBvZiB0aGUgdG9waWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlb3BlbmZvcnVtdG9waWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVvcGVuRm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlb3BlbkZvcnVtVG9waWMoY2hhdElkLCBtZXNzYWdlVGhyZWFkSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZW9wZW5Gb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBmb3J1bSB0b3BpYyBhbG9uZyB3aXRoIGFsbCBpdHMgbWVzc2FnZXMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fZGVsZXRlX21lc3NhZ2VzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VUaHJlYWRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBtZXNzYWdlIHRocmVhZCBvZiB0aGUgZm9ydW0gdG9waWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVmb3J1bXRvcGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVGb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgcGlubmVkIG1lc3NhZ2VzIGluIGEgZm9ydW0gdG9waWMuXG4gICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fcGluX21lc3NhZ2VzIGFkbWluaXN0cmF0b3IgcmlnaHQgaW4gdGhlIHN1cGVyZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluYWxsZm9ydW10b3BpY21lc3NhZ2VzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucGluQWxsRm9ydW1Ub3BpY01lc3NhZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5waW5BbGxGb3J1bVRvcGljTWVzc2FnZXMoY2hhdElkLCBtZXNzYWdlVGhyZWFkSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bnBpbkFsbEZvcnVtVG9waWNNZXNzYWdlcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IHRoZSBuYW1lIG9mIHRoZSAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICogVGhlIHRvcGljIHdpbGwgYmUgYXV0b21hdGljYWxseSB1bmhpZGRlbiBpZiBpdCB3YXMgaGlkZGVuLlxuICAgICpcbiAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmV3IHRvcGljIG5hbWUsIDEtMTI4IGNoYXJhY3RlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0Z2VuZXJhbGZvcnVtdG9waWNcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0R2VuZXJhbEZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0R2VuZXJhbEZvcnVtVG9waWMoY2hhdElkLCBuYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdEdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsb3NlIGFuIG9wZW4gJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgICAqXG4gICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjbG9zZWdlbmVyYWxmb3J1bXRvcGljXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvc2VHZW5lcmFsRm9ydW1Ub3BpYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjbG9zZUdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlb3BlbiBhIGNsb3NlZCAnR2VuZXJhbCcgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAgICogVGhlIHRvcGljIHdpbGwgYmUgYXV0b21hdGljYWxseSB1bmhpZGRlbiBpZiBpdCB3YXMgaGlkZGVuLlxuICAgICpcbiAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlb3BlbmdlbmVyYWxmb3J1bXRvcGljXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVvcGVuR2VuZXJhbEZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW9wZW5HZW5lcmFsRm9ydW1Ub3BpYyhjaGF0SWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3Jlb3BlbkdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGhpZGUgdGhlICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICAgKiBUaGUgdG9waWMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCBpZiBpdCB3YXMgb3Blbi5cbiAgICAqXG4gICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNoaWRlZ2VuZXJhbGZvcnVtdG9waWNcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlR2VuZXJhbEZvcnVtVG9waWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdoaWRlR2VuZXJhbEZvcnVtVG9waWMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHVuaGlkZSB0aGUgJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAgICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VuaGlkZWdlbmVyYWxmb3J1bXRvcGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuaGlkZUdlbmVyYWxGb3J1bVRvcGljJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5oaWRlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmhpZGVHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgcGlubmVkIG1lc3NhZ2VzIGluIGEgR2VuZXJhbCBmb3J1bSB0b3BpYy5cbiAgICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9waW5fbWVzc2FnZXMgYWRtaW5pc3RyYXRvciByaWdodCBpbiB0aGUgc3VwZXJncm91cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluYWxsZ2VuZXJhbGZvcnVtdG9waWNtZXNzYWdlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bnBpbkFsbEdlbmVyYWxGb3J1bVRvcGljTWVzc2FnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnBpbkFsbEdlbmVyYWxGb3J1bVRvcGljTWVzc2FnZXMoY2hhdElkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmhpZGVHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhbnN3ZXJzIHRvIGNhbGxiYWNrIHF1ZXJpZXMgc2VudCBmcm9tXG4gICAgICogW2lubGluZSBrZXlib2FyZHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cyNpbmxpbmUta2V5Ym9hcmRzLWFuZC1vbi10aGUtZmx5LXVwZGF0aW5nKS5cbiAgICAgKlxuICAgICAqIFRoZSBhbnN3ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYXMgYSBub3RpZmljYXRpb24gYXQgdGhlIHRvcCBvZiB0aGUgY2hhdCBzY3JlZW4gb3IgYXMgYW4gYWxlcnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBoYXMgKipvbGRlciwgY29tcGF0aWJsZSBzaWduYXR1cmVzIChbMV1bYW5zd2VyQ2FsbGJhY2tRdWVyeS12MC4yNy4xXSkoWzJdW2Fuc3dlckNhbGxiYWNrUXVlcnktdjAuMjkuMF0pKipcbiAgICAgKiB0aGF0IGFyZSBiZWluZyBkZXByZWNhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjYWxsYmFja1F1ZXJ5SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeSB0byBiZSBhbnN3ZXJlZFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJjYWxsYmFja3F1ZXJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fuc3dlckNhbGxiYWNrUXVlcnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnN3ZXJDYWxsYmFja1F1ZXJ5KGNhbGxiYWNrUXVlcnlJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSAoaW4vYmVmb3JlIHYwLjI3LjEpIHdhcyBhbnN3ZXJDYWxsYmFja1F1ZXJ5KGNhbGxiYWNrUXVlcnlJZCwgdGV4dCwgc2hvd0FsZXJ0KS5cbiAgICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgICAgaWYgKCh0eXBlb2YgZm9ybSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZm9ybSkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgYW5zd2VyQ2FsbGJhY2tRdWVyeShjYWxsYmFja1F1ZXJ5SWQsIHRleHQsIHNob3dBbGVydCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yNy4xJyk7XG4gICAgICAgIGZvcm0gPSB7XG4gICAgICAgICAgY2FsbGJhY2tfcXVlcnlfaWQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICB0ZXh0OiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgc2hvd19hbGVydDogYXJndW1lbnRzWzJdXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgfVxuICAgICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgKGluL2JlZm9yZSB2MC4yOS4wKSB3YXMgYW5zd2VyQ2FsbGJhY2tRdWVyeShbb3B0aW9uc10pLlxuICAgICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5LiAqL1xuICAgICAgaWYgKCh0eXBlb2YgY2FsbGJhY2tRdWVyeUlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjYWxsYmFja1F1ZXJ5SWQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIGFuc3dlckNhbGxiYWNrUXVlcnkoW29wdGlvbnNdKSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI5LjAnKTtcbiAgICAgICAgZm9ybSA9IGNhbGxiYWNrUXVlcnlJZDtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtLmNhbGxiYWNrX3F1ZXJ5X2lkID0gY2FsbGJhY2tRdWVyeUlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlckNhbGxiYWNrUXVlcnknLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgbGlzdCBvZiBib29zdHMgYWRkZWQgdG8gYSBjaGF0IGJ5IGEgdXNlLlxuICAgICAqIFJlcXVpcmVzIGFkbWluaXN0cmF0b3IgcmlnaHRzIGluIHRoZSBjaGF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcl9pZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIGEgW1VzZXJDaGF0Qm9vc3RzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VzZXJjaGF0Ym9vc3RzKSBvYmplY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dXNlcmNoYXRib29zdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VXNlckNoYXRCb29zdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVc2VyQ2hhdEJvb3N0cyhjaGF0SWQsIHBvbGxJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfaWQgPSBwb2xsSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0VXNlckNoYXRCb29zdHMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29ubmVjdGlvbiBvZiB0aGUgYm90IHdpdGggYSBidXNpbmVzcyBhY2NvdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBidXNpbmVzc0Nvbm5lY3Rpb25JZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cC9jaGFubmVsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgcmV0dXJucyBbQnVzaW5lc3NDb25uZWN0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2J1c2luZXNzY29ubmVjdGlvbikgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGJ1c2luZXNzY29ubmVjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCdXNpbmVzc0Nvbm5lY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCdXNpbmVzc0Nvbm5lY3Rpb24oYnVzaW5lc3NDb25uZWN0aW9uSWQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5idXNpbmVzc19jb25uZWN0aW9uX2lkID0gYnVzaW5lc3NDb25uZWN0aW9uSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0QnVzaW5lc3NDb25uZWN0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cyNjb21tYW5kcyBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IGJvdCBjb21tYW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzICBMaXN0IG9mIGJvdCBjb21tYW5kcyB0byBiZSBzZXQgYXMgdGhlIGxpc3Qgb2YgdGhlIFtib3QncyBjb21tYW5kc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3Rjb21tYW5kKS4gQXQgbW9zdCAxMDAgY29tbWFuZHMgY2FuIGJlIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0bXljb21tYW5kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNeUNvbW1hbmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlDb21tYW5kcyhjb21tYW5kcykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNvbW1hbmRzID0gc3RyaW5naWZ5KGNvbW1hbmRzKTtcblxuICAgICAgaWYgKGZvcm0uc2NvcGUpIHtcbiAgICAgICAgZm9ybS5zY29wZSA9IHN0cmluZ2lmeShmb3JtLnNjb3BlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15Q29tbWFuZHMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSB0aGUgbGlzdCBvZiB0aGUgYm90J3MgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiBzY29wZSBhbmQgdXNlciBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqICBBZnRlciBkZWxldGlvbiwgW2hpZ2hlciBsZXZlbCBjb21tYW5kc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZXRlcm1pbmluZy1saXN0LW9mLWNvbW1hbmRzKSB3aWxsIGJlIHNob3duIHRvIGFmZmVjdGVkIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZW15Y29tbWFuZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlTXlDb21tYW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU15Q29tbWFuZHMoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVNeUNvbW1hbmRzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgbGlzdCBvZiB0aGUgYm90J3MgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiBzY29wZSBhbmQgdXNlciBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEFycmF5IG9mIFtCb3RDb21tYW5kXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdGNvbW1hbmQpIG9uIHN1Y2Nlc3MuIElmIGNvbW1hbmRzIGFyZW4ndCBzZXQsIGFuIGVtcHR5IGxpc3QgaXMgcmV0dXJuZWQuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldG15Y29tbWFuZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TXlDb21tYW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE15Q29tbWFuZHMoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChmb3JtLnNjb3BlKSB7XG4gICAgICAgIGZvcm0uc2NvcGUgPSBzdHJpbmdpZnkoZm9ybS5zY29wZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlDb21tYW5kcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBib3QncyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15bmFtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNeU5hbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNeU5hbWUoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeU5hbWUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBib3QgbmFtZSBmb3IgdGhlIGdpdmVuIHVzZXIgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQm90TmFtZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3RuYW1lKSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldG15bmFtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNeU5hbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNeU5hbWUoKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeU5hbWUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3MgZGVzY3JpcHRpb24sIHdoaWNoIGlzIHNob3duIGluIHRoZSBjaGF0IHdpdGggdGhlIGJvdCBpZiB0aGUgY2hhdCBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15ZGVzY3JpcHRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TXlEZXNjcmlwdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE15RGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeURlc2NyaXB0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgYm90IGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gdXNlciBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgW0JvdERlc2NyaXB0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdGRlc2NyaXB0aW9uKSBvbiBzdWNjZXNzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteWRlc2NyaXB0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE15RGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNeURlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlEZXNjcmlwdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBib3QncyBzaG9ydCBkZXNjcmlwdGlvbiwgd2hpY2ggaXMgc2hvd24gb24gdGhlIGJvdCdzIHByb2ZpbGUgcGFnZVxuICAgICAqIGFuZCBpcyBzZW50IHRvZ2V0aGVyIHdpdGggdGhlIGxpbmsgd2hlbiB1c2VycyBzaGFyZSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15c2hvcnRkZXNjcmlwdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNeVNob3J0RGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNeVNob3J0RGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeVNob3J0RGVzY3JpcHRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBib3Qgc2hvcnQgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiB1c2VyIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBbQm90U2hvcnREZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3RzaG9ydGRlc2NyaXB0aW9uKSBvbiBzdWNjZXNzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteXNob3J0ZGVzY3JpcHRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TXlTaG9ydERlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlTaG9ydERlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlTaG9ydERlc2NyaXB0aW9uJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIG1lbnUgYnV0dG9uIGluIGEgcHJpdmF0ZSBjaGF0LCBvciB0aGUgZGVmYXVsdCBtZW51IGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0bWVudWJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDaGF0TWVudUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENoYXRNZW51QnV0dG9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q2hhdE1lbnVCdXR0b24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgYm90J3MgbWVudSBidXR0b24gaW4gYSBwcml2YXRlIGNoYXQsIG9yIHRoZSBkZWZhdWx0IG1lbnUgYnV0dG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gW01lbnVCdXR0b25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVudWJ1dHRvbikgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0bWVudWJ1dHRvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGF0TWVudUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYXRNZW51QnV0dG9uKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdE1lbnVCdXR0b24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBhZG1pbmlzdHJhdG9yIHJpZ2h0cyByZXF1ZXN0ZWQgYnkgdGhlIGJvdCB3aGVuIGl0J3MgYWRkZWQgYXMgYW4gYWRtaW5pc3RyYXRvciB0byBncm91cHMgb3IgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBUaGVzZSByaWdodHMgd2lsbCBiZSBzdWdnZXN0ZWQgdG8gdXNlcnMsIGJ1dCB0aGV5IGFyZSBhcmUgZnJlZSB0byBtb2RpZnkgdGhlIGxpc3QgYmVmb3JlIGFkZGluZyB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRtZW51YnV0dG9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE15RGVmYXVsdEFkbWluaXN0cmF0b3JSaWdodHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGRlZmF1bHQgYWRtaW5pc3RyYXRvciByaWdodHMgb2YgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFtDaGF0QWRtaW5pc3RyYXRvclJpZ2h0c10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNjaGF0YWRtaW5pc3RyYXRvcnJpZ2h0cykgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteWRlZmF1bHRhZG1pbmlzdHJhdG9ycmlnaHRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE15RGVmYXVsdEFkbWluaXN0cmF0b3JSaWdodHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzKCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0TXlEZWZhdWx0QWRtaW5pc3RyYXRvclJpZ2h0cycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCB0ZXh0IG9yIFtnYW1lXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dhbWVzKSBtZXNzYWdlcyBzZW50IGJ5IHRoZSBib3Qgb3IgdmlhIHRoZSBib3QgKGZvciBpbmxpbmUgYm90cykuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGF0ICoqeW91IG11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQqKiBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgIE5ldyB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zIChwcm92aWRlIGVpdGhlciBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQgaGVyZSlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZXRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdE1lc3NhZ2VUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE1lc3NhZ2VUZXh0KHRleHQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS50ZXh0ID0gdGV4dDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZVRleHQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgY2FwdGlvbnMgb2YgbWVzc2FnZXMgc2VudCBieSB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgICAqXG4gICAgICogTm90ZTogWW91ICoqbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gY2FwdGlvbiAgTmV3IGNhcHRpb24gb2YgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdlY2FwdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlZGl0TWVzc2FnZUNhcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0TWVzc2FnZUNhcHRpb24oY2FwdGlvbikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLmNhcHRpb24gPSBjYXB0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRNZXNzYWdlQ2FwdGlvbicsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBhbmltYXRpb24sIGF1ZGlvLCBkb2N1bWVudCwgcGhvdG8sIG9yIHZpZGVvIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGlzIGEgcGFydCBvZiBhIG1lc3NhZ2UgYWxidW0sIHRoZW4gaXQgY2FuIGJlIGVkaXRlZCBvbmx5IHRvIGEgcGhvdG8gb3IgYSB2aWRlby5cbiAgICAgKlxuICAgICAqIE90aGVyd2lzZSwgbWVzc2FnZSB0eXBlIGNhbiBiZSBjaGFuZ2VkIGFyYml0cmFyaWx5LiBXaGVuIGlubGluZSBtZXNzYWdlIGlzIGVkaXRlZCwgbmV3IGZpbGUgY2FuJ3QgYmUgdXBsb2FkZWQuXG4gICAgICogVXNlIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSB2aWEgaXRzIGZpbGVfaWQgb3Igc3BlY2lmeSBhIFVSTC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFlvdSAqKm11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQqKiBpbiB5b3VyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG1lZGlhICBBIEpTT04tc2VyaWFsaXplZCBvYmplY3QgZm9yIGEgbmV3IG1lZGlhIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdlbWVkaWFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWRpdE1lc3NhZ2VNZWRpYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRNZXNzYWdlTWVkaWEobWVkaWEpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIHJlZ2V4QXR0YWNoID0gL2F0dGFjaDpcXC9cXC8uKy87XG5cbiAgICAgIGlmICh0eXBlb2YgbWVkaWEubWVkaWEgPT09ICdzdHJpbmcnICYmIHJlZ2V4QXR0YWNoLnRlc3QobWVkaWEubWVkaWEpKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHFzOiBmb3JtXG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuXG4gICAgICAgIHZhciBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgbWVkaWEpO1xuICAgICAgICBkZWxldGUgcGF5bG9hZC5tZWRpYTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBhdHRhY2hOYW1lID0gU3RyaW5nKDApO1xuXG4gICAgICAgICAgdmFyIF9mb3JtYXRTZW5kRGF0YTYgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShhdHRhY2hOYW1lLCBtZWRpYS5tZWRpYS5yZXBsYWNlKCdhdHRhY2g6Ly8nLCAnJyksIG1lZGlhLmZpbGVPcHRpb25zKSxcbiAgICAgICAgICAgICAgX2Zvcm1hdFNlbmREYXRhNyA9IF9zbGljZWRUb0FycmF5KF9mb3JtYXRTZW5kRGF0YTYsIDEpLFxuICAgICAgICAgICAgICBmb3JtRGF0YSA9IF9mb3JtYXRTZW5kRGF0YTdbMF07XG5cbiAgICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICAgIG9wdHMuZm9ybURhdGFbYXR0YWNoTmFtZV0gPSBmb3JtRGF0YVthdHRhY2hOYW1lXTtcbiAgICAgICAgICAgIHBheWxvYWQubWVkaWEgPSAnYXR0YWNoOi8vJyArIGF0dGFjaE5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRmF0YWxFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgdGhlIHJlcGxhY2VtZW50IGFjdGlvbiBmb3IgeW91ciAnICsgbWVkaWEudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnFzLm1lZGlhID0gc3RyaW5naWZ5KHBheWxvYWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZU1lZGlhJywgb3B0cyk7XG4gICAgICB9XG5cbiAgICAgIGZvcm0ubWVkaWEgPSBzdHJpbmdpZnkobWVkaWEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VNZWRpYScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBvbmx5IHRoZSByZXBseSBtYXJrdXAgb2YgbWVzc2FnZXMgc2VudCBieSB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgICAqXG4gICAgICogTm90ZTogWW91ICoqbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVwbHlNYXJrdXAgIEEgSlNPTi1zZXJpYWxpemVkIG9iamVjdCBmb3IgYW4gaW5saW5lIGtleWJvYXJkLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2V0ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VkaXRNZXNzYWdlUmVwbHlNYXJrdXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0TWVzc2FnZVJlcGx5TWFya3VwKHJlcGx5TWFya3VwKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0ucmVwbHlfbWFya3VwID0gcmVwbHlNYXJrdXA7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VSZXBseU1hcmt1cCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc3RvcCBhIHBvbGwgd2hpY2ggd2FzIHNlbnQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cC9jaGFubmVsXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwb2xsSWQgSWRlbnRpZmllciBvZiB0aGUgb3JpZ2luYWwgbWVzc2FnZSB3aXRoIHRoZSBwb2xsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHN0b3BwZWQgW1BvbGxdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcG9sbCkgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RvcHBvbGxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RvcFBvbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wUG9sbChjaGF0SWQsIHBvbGxJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLm1lc3NhZ2VfaWQgPSBwb2xsSWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc3RvcFBvbGwnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgc3RhdGljIC5XRUJQLCBbYW5pbWF0ZWRdKGh0dHBzOi8vdGVsZWdyYW0ub3JnL2Jsb2cvYW5pbWF0ZWQtc3RpY2tlcnMpIC5UR1MsXG4gICAgICogb3IgW3ZpZGVvXShodHRwczovL3RlbGVncmFtLm9yZy9ibG9nL3ZpZGVvLXN0aWNrZXJzLWJldHRlci1yZWFjdGlvbnMpIC5XRUJNIHN0aWNrZXJzLlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gc3RpY2tlciBBIGZpbGUgcGF0aCwgU3RyZWFtIG9yIEJ1ZmZlci5cbiAgICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLiBTdGlja2VycyBhcmUgV2ViUCBmb3JtYXQgZmlsZXMuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kc3RpY2tlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kU3RpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRTdGlja2VyKGNoYXRJZCwgc3RpY2tlcikge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3N0aWNrZXInLCBzdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy5zdGlja2VyID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRTdGlja2VyJywgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIHN0aWNrZXIgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHN0aWNrZXIgc2V0XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbU3RpY2tlclNldF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdGlja2Vyc2V0KSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0c3RpY2tlcnNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTdGlja2VyU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RpY2tlclNldChuYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0U3RpY2tlclNldCcsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGN1c3RvbSBlbW9qaSBzdGlja2VycyBieSB0aGVpciBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjdXN0b21fZW1vamlfaWRzIExpc3Qgb2YgY3VzdG9tIGVtb2ppIGlkZW50aWZpZXJzLiBBdCBtb3N0IDIwMCBjdXN0b20gZW1vamkgaWRlbnRpZmllcnMgY2FuIGJlIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBcnJheSBvZiBbU3RpY2tlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdGlja2VyKSBvYmplY3RzLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjdXN0b21lbW9qaXN0aWNrZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEN1c3RvbUVtb2ppU3RpY2tlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXN0b21FbW9qaVN0aWNrZXJzKGN1c3RvbUVtb2ppSWRzKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uY3VzdG9tX2Vtb2ppX2lkcyA9IHN0cmluZ2lmeShjdXN0b21FbW9qaUlkcyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q3VzdG9tRW1vamlTdGlja2VycycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gdXBsb2FkIGEgZmlsZSB3aXRoIGEgc3RpY2tlciBmb3IgbGF0ZXIgdXNlIGluICpjcmVhdGVOZXdTdGlja2VyU2V0KiBhbmQgKmFkZFN0aWNrZXJUb1NldCogbWV0aG9kcyAoY2FuIGJlIHVzZWQgbXVsdGlwbGVcbiAgICAgKiB0aW1lcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVc2VyIGlkZW50aWZpZXIgb2Ygc3RpY2tlciBmaWxlIG93bmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBzdGlja2VyIEEgZmlsZSBwYXRoIG9yIGEgU3RyZWFtIHdpdGggdGhlIHN0aWNrZXIgaW4gLldFQlAsIC5QTkcsIC5UR1MsIG9yIC5XRUJNIGZvcm1hdC4gQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RpY2tlckZvcm1hdCBBbGxvdyB2YWx1ZXM6ICBgc3RhdGljYCwgYGFuaW1hdGVkYCBvciBgdmlkZW9gXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtGaWxlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZpbGUpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1cGxvYWRzdGlja2VyZmlsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGxvYWRTdGlja2VyRmlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZFN0aWNrZXJGaWxlKHVzZXJJZCwgc3RpY2tlcikge1xuICAgICAgdmFyIHN0aWNrZXJGb3JtYXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdzdGF0aWMnO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgdmFyIGZpbGVPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHFzOiBvcHRpb25zXG4gICAgICB9O1xuICAgICAgb3B0cy5xcy51c2VyX2lkID0gdXNlcklkO1xuICAgICAgb3B0cy5xcy5zdGlja2VyX2Zvcm1hdCA9IHN0aWNrZXJGb3JtYXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdzdGlja2VyJywgc3RpY2tlciwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXMuc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1cGxvYWRTdGlja2VyRmlsZScsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgbmV3IHN0aWNrZXIgc2V0IG93bmVkIGJ5IGEgdXNlci5cbiAgICAgKlxuICAgICAqIFRoZSBib3Qgd2lsbCBiZSBhYmxlIHRvIGVkaXQgdGhlIGNyZWF0ZWQgc3RpY2tlciBzZXQuXG4gICAgICpcbiAgICAgKiBZb3UgbXVzdCB1c2UgZXhhY3RseSBvbmUgb2YgdGhlIGZpZWxkcyAqcG5nX3N0aWNrZXIqLCAqdGdzX3N0aWNrZXIqLCBvciAqd2VibV9zdGlja2VyKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVXNlciBpZGVudGlmaWVyIG9mIGNyZWF0ZWQgc3RpY2tlciBzZXQgb3duZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU2hvcnQgbmFtZSBvZiBzdGlja2VyIHNldCwgdG8gYmUgdXNlZCBpbiBgdC5tZS9hZGRzdGlja2Vycy9gIFVSTHMgKGUuZy4sICAgKlwiYW5pbWFsc1wiKikuIENhbiBjb250YWluIG9ubHkgZW5nbGlzaCBsZXR0ZXJzLCBkaWdpdHMgYW5kIHVuZGVyc2NvcmVzLlxuICAgICAqICBNdXN0IGJlZ2luIHdpdGggYSBsZXR0ZXIsIGNhbid0IGNvbnRhaW4gY29uc2VjdXRpdmUgdW5kZXJzY29yZXMgYW5kIG11c3QgZW5kIGluIGBcIl9ieV88Ym90X3VzZXJuYW1lPlwiYC4gYDxib3RfdXNlcm5hbWU+YCBpcyBjYXNlIGluc2Vuc2l0aXZlLiAxLTY0IGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZSBTdGlja2VyIHNldCB0aXRsZSwgMS02NCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBwbmdTdGlja2VyIFBuZyBpbWFnZSB3aXRoIHRoZSBzdGlja2VyLCBtdXN0IGJlIHVwIHRvIDUxMiBraWxvYnl0ZXMgaW4gc2l6ZSxcbiAgICAgKiAgZGltZW5zaW9ucyBtdXN0IG5vdCBleGNlZWQgNTEycHgsIGFuZCBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG11c3QgYmUgZXhhY3RseSA1MTJweC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVtb2ppcyBPbmUgb3IgbW9yZSBlbW9qaSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZW5ld3N0aWNrZXJzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlTmV3U3RpY2tlclNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU5ld1N0aWNrZXJTZXQodXNlcklkLCBuYW1lLCB0aXRsZSwgcG5nU3RpY2tlciwgZW1vamlzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICBvcHRzLnFzLm5hbWUgPSBuYW1lO1xuICAgICAgb3B0cy5xcy50aXRsZSA9IHRpdGxlO1xuICAgICAgb3B0cy5xcy5lbW9qaXMgPSBlbW9qaXM7XG4gICAgICBvcHRzLnFzLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkob3B0aW9ucy5tYXNrX3Bvc2l0aW9uKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdwbmdfc3RpY2tlcicsIHBuZ1N0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLnBuZ19zdGlja2VyID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZU5ld1N0aWNrZXJTZXQnLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYWRkIGEgbmV3IHN0aWNrZXIgdG8gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogWW91IG11c3QgdXNlIGV4YWN0bHkgb25lIG9mIHRoZSBmaWVsZHMgKnBuZ19zdGlja2VyKiwgKnRnc19zdGlja2VyKiwgb3IgKndlYm1fc3RpY2tlcipcbiAgICAgKlxuICAgICAqIEFuaW1hdGVkIHN0aWNrZXJzIGNhbiBiZSBhZGRlZCB0byBhbmltYXRlZCBzdGlja2VyIHNldHMgYW5kIG9ubHkgdG8gdGhlbVxuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiAtIEVtb2ppIHN0aWNrZXIgc2V0cyBjYW4gaGF2ZSB1cCB0byAyMDAgc3RpY2tlclxuICAgICAqIC0gU3RhdGljIG9yIEFuaW1hdGVkIHN0aWNrZXIgc2V0cyBjYW4gaGF2ZSB1cCB0byAxMjAgc3RpY2tlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBzdGlja2VyIHNldCBvd25lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBzdGlja2VyIFBuZyBpbWFnZSB3aXRoIHRoZSBzdGlja2VyIChtdXN0IGJlIHVwIHRvIDUxMiBraWxvYnl0ZXMgaW4gc2l6ZSxcbiAgICAgKiBkaW1lbnNpb25zIG11c3Qgbm90IGV4Y2VlZCA1MTJweCwgYW5kIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbXVzdCBiZSBleGFjdGx5IDUxMnB4LCBbVEdTIGFuaW1hdGlvbl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9zdGlja2VycyNhbmltYXRlZC1zdGlja2VyLXJlcXVpcmVtZW50cylcbiAgICAgKiB3aXRoIHRoZSBzdGlja2VyIG9yIFtXRUJNIHZpZGVvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3N0aWNrZXJzI3ZpZGVvLXN0aWNrZXItcmVxdWlyZW1lbnRzKSB3aXRoIHRoZSBzdGlja2VyLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZW1vamlzIE9uZSBvciBtb3JlIGVtb2ppIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXJUeXBlIEFsbG93IHZhbHVlczogYHBuZ19zdGlja2VyYCwgYHRnc19zdGlja2VyYCwgb3IgYHdlYm1fc3RpY2tlcmAuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2FkZHN0aWNrZXJ0b3NldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTdGlja2VyVG9TZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdGlja2VyVG9TZXQodXNlcklkLCBuYW1lLCBzdGlja2VyLCBlbW9qaXMpIHtcbiAgICAgIHZhciBzdGlja2VyVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ3BuZ19zdGlja2VyJztcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICAgIHZhciBmaWxlT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDoge307XG5cbiAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICBxczogb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIG9wdHMucXMudXNlcl9pZCA9IHVzZXJJZDtcbiAgICAgIG9wdHMucXMubmFtZSA9IG5hbWU7XG4gICAgICBvcHRzLnFzLmVtb2ppcyA9IGVtb2ppcztcbiAgICAgIG9wdHMucXMubWFza19wb3NpdGlvbiA9IHN0cmluZ2lmeShvcHRpb25zLm1hc2tfcG9zaXRpb24pO1xuXG4gICAgICBpZiAodHlwZW9mIHN0aWNrZXJUeXBlICE9PSAnc3RyaW5nJyB8fCBbJ3BuZ19zdGlja2VyJywgJ3Rnc19zdGlja2VyJywgJ3dlYm1fc3RpY2tlciddLmluZGV4T2Yoc3RpY2tlclR5cGUpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzdGlja2VyVHlwZSBtdXN0IGJlIGEgc3RyaW5nIGFuZCB0aGUgYWxsb3cgdHlwZXMgaXM6IHBuZ19zdGlja2VyLCB0Z3Nfc3RpY2tlciwgd2VibV9zdGlja2VyJykpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShzdGlja2VyVHlwZSwgc3RpY2tlciwgZmlsZU9wdGlvbnMpO1xuICAgICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICAgIG9wdHMucXNbc3RpY2tlclR5cGVdID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2FkZFN0aWNrZXJUb1NldCcsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBtb3ZlIGEgc3RpY2tlciBpbiBhIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QgdG8gYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvc2l0aW9uIE5ldyBzdGlja2VyIHBvc2l0aW9uIGluIHRoZSBzZXQsIHplcm8tYmFzZWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcnBvc2l0aW9uaW5zZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RpY2tlclBvc2l0aW9uSW5TZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGlja2VyUG9zaXRpb25JblNldChzdGlja2VyLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgICAgZm9ybS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJQb3NpdGlvbkluU2V0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBzdGlja2VyIGZyb20gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVzdGlja2VyZnJvbXNldFxuICAgICAqIEB0b2RvIEFkZCB0ZXN0cyBmb3IgdGhpcyBtZXRob2QhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVN0aWNrZXJGcm9tU2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU3RpY2tlckZyb21TZXQoc3RpY2tlcikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVN0aWNrZXJGcm9tU2V0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXBsYWNlIGFuIGV4aXN0aW5nIHN0aWNrZXIgaW4gYSBzdGlja2VyIHNldCB3aXRoIGEgbmV3IG9uZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyX2lkIFVzZXIgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlciBzZXQgb3duZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmVwbGFjZXN0aWNrZXJpbnNldFxuICAgICAqIEB0b2RvIEFkZCB0ZXN0cyBmb3IgdGhpcyBtZXRob2QhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2VTdGlja2VySW5TZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlU3RpY2tlckluU2V0KHVzZXJJZCwgbmFtZSwgb2xkU3RpY2tlcikge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgZm9ybS5vbGRfc3RpY2tlciA9IG9sZFN0aWNrZXI7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlU3RpY2tlckZyb21TZXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgbGlzdCBvZiBlbW9qaSBhc3NpZ25lZCB0byBhIHJlZ3VsYXIgb3IgY3VzdG9tIGVtb2ppIHN0aWNrZXIuXG4gICAgICpcbiAgICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0geyBBcnJheSB9IGVtb2ppTGlzdCBBIEpTT04tc2VyaWFsaXplZCBsaXN0IG9mIDEtMjAgZW1vamkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdGlja2VyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJlbW9qaWxpc3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RpY2tlckVtb2ppTGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0aWNrZXJFbW9qaUxpc3Qoc3RpY2tlciwgZW1vamlMaXN0KSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgICBmb3JtLmVtb2ppX2xpc3QgPSBzdHJpbmdpZnkoZW1vamlMaXN0KTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRTdGlja2VyRW1vamlMaXN0JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgZW1vamkgYXNzaWduZWQgdG8gYSBgcmVndWxhcmAgb3IgYGN1c3RvbSBlbW9qaWAgc3RpY2tlci5cbiAgICAgKlxuICAgICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vya2V5d29yZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RpY2tlcktleXdvcmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RpY2tlcktleXdvcmRzKHN0aWNrZXIpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICAgIGlmIChmb3JtLmtleXdvcmRzKSB7XG4gICAgICAgIGZvcm0ua2V5d29yZHMgPSBzdHJpbmdpZnkoZm9ybS5rZXl3b3Jkcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlcktleXdvcmRzJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIFttYXNrIHBvc2l0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21hc2twb3NpdGlvbikgb2YgYSBtYXNrIHN0aWNrZXIuXG4gICAgICpcbiAgICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcm1hc2twb3NpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTdGlja2VyTWFza1Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RpY2tlck1hc2tQb3NpdGlvbihzdGlja2VyKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgICBpZiAoZm9ybS5tYXNrX3Bvc2l0aW9uKSB7XG4gICAgICAgIGZvcm0ubWFza19wb3NpdGlvbiA9IHN0cmluZ2lmeShmb3JtLm1hc2tfcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJNYXNrUG9zaXRpb24nLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgdGl0bGUgb2YgYSBjcmVhdGVkIHN0aWNrZXIgc2V0LlxuICAgICAqXG4gICAgICogVGhlIHN0aWNrZXIgbXVzdCBiZWxvbmcgdG8gYSBzdGlja2VyIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgU3RpY2tlciBzZXQgdGl0bGUsIDEtNjQgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vyc2V0dGl0bGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RpY2tlclNldFRpdGxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RpY2tlclNldFRpdGxlKG5hbWUsIHRpdGxlKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlclNldFRpdGxlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBhZGQgYSB0aHVtYiB0byBhIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBBbmltYXRlZCB0aHVtYm5haWxzIGNhbiBiZSBzZXQgZm9yIGFuaW1hdGVkIHN0aWNrZXIgc2V0cyBvbmx5LiBWaWRlbyB0aHVtYm5haWxzIGNhbiBiZSBzZXQgb25seSBmb3IgdmlkZW8gc3RpY2tlciBzZXRzIG9ubHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBzdGlja2VyIHNldCBvd25lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB0aHVtYm5haWwgQSAuV0VCUCBvciAuUE5HIGltYWdlIHdpdGggdGhlIHRodW1ibmFpbCxcbiAgICAgKiBtdXN0IGJlIHVwIHRvIDEyOCBraWxvYnl0ZXMgaW4gc2l6ZSBhbmQgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IGV4YWN0bHkgMTAwcHgsXG4gICAgICogYSBUR1MgYW5pbWF0aW9uIHdpdGggdGhlIHRodW1ibmFpbCB1cCB0byAzMiBraWxvYnl0ZXMgaW4gc2l6ZSBvciBhIFdFQk0gdmlkZW8gd2l0aCB0aGUgdGh1bWJuYWlsIHVwIHRvIDMyIGtpbG9ieXRlcyBpbiBzaXplLlxuICAgICAqXG4gICAgICogUGFzcyBhIGZpbGVfaWQgYXMgYSBTdHJpbmcgdG8gc2VuZCBhIGZpbGUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgVGVsZWdyYW0gc2VydmVycywgcGFzcyBhbiBIVFRQIFVSTCBhcyBhIFN0cmluZyBmb3IgVGVsZWdyYW1cbiAgICAgKiB0byBnZXQgYSBmaWxlIGZyb20gdGhlIEludGVybmV0LCBvciB1cGxvYWQgYSBuZXcgb25lLiBBbmltYXRlZCBzdGlja2VyIHNldCB0aHVtYm5haWxzIGNhbid0IGJlIHVwbG9hZGVkIHZpYSBIVFRQIFVSTC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vyc2V0dGh1bWJuYWlsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldFN0aWNrZXJTZXRUaHVtYm5haWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGlja2VyU2V0VGh1bWJuYWlsKHVzZXJJZCwgbmFtZSwgdGh1bWJuYWlsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICB2YXIgZmlsZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuXG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgcXM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICBvcHRzLnFzLm5hbWUgPSBuYW1lO1xuICAgICAgb3B0cy5xcy5tYXNrX3Bvc2l0aW9uID0gc3RyaW5naWZ5KG9wdGlvbnMubWFza19wb3NpdGlvbik7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgndGh1bWJuYWlsJywgdGh1bWJuYWlsLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgICAgb3B0cy5xcy50aHVtYm5haWwgPSBzZW5kRGF0YVsxXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlclNldFRodW1ibmFpbCcsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHRodW1ibmFpbCBvZiBhIGN1c3RvbSBlbW9qaSBzdGlja2VyIHNldC5cbiAgICAgKlxuICAgICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y3VzdG9tZW1vamlzdGlja2Vyc2V0dGh1bWJuYWlsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldEN1c3RvbUVtb2ppU3RpY2tlclNldFRodW1ibmFpbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1c3RvbUVtb2ppU3RpY2tlclNldFRodW1ibmFpbChuYW1lKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q3VzdG9tRW1vamlTdGlja2VyU2V0VGh1bWJuYWlsJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBzdGlja2VyIHNldCB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAgICpcbiAgICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZXN0aWNrZXJzZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlU3RpY2tlclNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVN0aWNrZXJTZXQobmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVN0aWNrZXJTZXQnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhbnN3ZXJzIHRvIGFuIGlubGluZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIE5vdGU6IE5vIG1vcmUgdGhhbiA1MCByZXN1bHRzIHBlciBxdWVyeSBhcmUgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaW5saW5lUXVlcnlJZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgcXVlcnlcbiAgICAgKiBAcGFyYW0gIHtJbmxpbmVRdWVyeVJlc3VsdFtdfSByZXN1bHRzIEFuIGFycmF5IG9mIHJlc3VsdHMgZm9yIHRoZSBpbmxpbmUgcXVlcnlcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBUcnVlIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcmlubGluZXF1ZXJ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Fuc3dlcklubGluZVF1ZXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5zd2VySW5saW5lUXVlcnkoaW5saW5lUXVlcnlJZCwgcmVzdWx0cykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmlubGluZV9xdWVyeV9pZCA9IGlubGluZVF1ZXJ5SWQ7XG4gICAgICBmb3JtLnJlc3VsdHMgPSBzdHJpbmdpZnkocmVzdWx0cyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VySW5saW5lUXVlcnknLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgcmVzdWx0IG9mIGFuIGludGVyYWN0aW9uIHdpdGggYSBbV2ViIEFwcF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL3dlYmFwcHMpXG4gICAgICogYW5kIHNlbmQgYSBjb3JyZXNwb25kaW5nIG1lc3NhZ2Ugb24gYmVoYWxmIG9mIHRoZSB1c2VyIHRvIHRoZSBjaGF0IGZyb20gd2hpY2ggdGhlIHF1ZXJ5IG9yaWdpbmF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHdlYkFwcFF1ZXJ5SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeSB0byBiZSBhbnN3ZXJlZFxuICAgICAqIEBwYXJhbSAge0lubGluZVF1ZXJ5UmVzdWx0fSByZXN1bHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBvbmUgcmVzdWx0IG9mIGFuIGlubGluZSBxdWVyeVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGEgW1NlbnRXZWJBcHBNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbnR3ZWJhcHBtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2Vyd2ViYXBwcXVlcnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYW5zd2VyV2ViQXBwUXVlcnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbnN3ZXJXZWJBcHBRdWVyeSh3ZWJBcHBRdWVyeUlkLCByZXN1bHQpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS53ZWJfYXBwX3F1ZXJ5X2lkID0gd2ViQXBwUXVlcnlJZDtcbiAgICAgIGZvcm0ucmVzdWx0ID0gc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VyV2ViQXBwUXVlcnknLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYW4gaW52b2ljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgUHJvZHVjdCBuYW1lLCAxLTMyIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFByb2R1Y3QgZGVzY3JpcHRpb24sIDEtMjU1IGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBheWxvYWQgQm90IGRlZmluZWQgaW52b2ljZSBwYXlsb2FkLCAxLTEyOCBieXRlcy4gVGhpcyB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIsIHVzZSBmb3IgeW91ciBpbnRlcm5hbCBwcm9jZXNzZXMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwcm92aWRlclRva2VuIFBheW1lbnRzIHByb3ZpZGVyIHRva2VuLCBvYnRhaW5lZCB2aWEgYEBCb3RGYXRoZXJgXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjdXJyZW5jeSBUaHJlZS1sZXR0ZXIgSVNPIDQyMTcgY3VycmVuY3kgY29kZVxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwcmljZXMgQnJlYWtkb3duIG9mIHByaWNlc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRpbnZvaWNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbmRJbnZvaWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEludm9pY2UoY2hhdElkLCB0aXRsZSwgZGVzY3JpcHRpb24sIHBheWxvYWQsIHByb3ZpZGVyVG9rZW4sIGN1cnJlbmN5LCBwcmljZXMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS50aXRsZSA9IHRpdGxlO1xuICAgICAgZm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgZm9ybS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgIGZvcm0ucHJvdmlkZXJfdG9rZW4gPSBwcm92aWRlclRva2VuO1xuICAgICAgZm9ybS5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgZm9ybS5wcmljZXMgPSBzdHJpbmdpZnkocHJpY2VzKTtcbiAgICAgIGZvcm0ucHJvdmlkZXJfZGF0YSA9IHN0cmluZ2lmeShmb3JtLnByb3ZpZGVyX2RhdGEpO1xuICAgICAgaWYgKGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzKSB7XG4gICAgICAgIGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzID0gc3RyaW5naWZ5KGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kSW52b2ljZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYSBsaW5rIGZvciBhbiBpbnZvaWNlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSBQcm9kdWN0IG5hbWUsIDEtMzIgY2hhcmFjdGVyc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFByb2R1Y3QgZGVzY3JpcHRpb24sIDEtMjU1IGNoYXJhY3RlcnNcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkIEJvdCBkZWZpbmVkIGludm9pY2UgcGF5bG9hZFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3ZpZGVyVG9rZW4gUGF5bWVudCBwcm92aWRlciB0b2tlblxuICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbmN5IFRocmVlLWxldHRlciBJU08gNDIxNyBjdXJyZW5jeSBjb2RlXG4gICAgKiBAcGFyYW0ge0FycmF5fSBwcmljZXMgQnJlYWtkb3duIG9mIHByaWNlc1xuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgY3JlYXRlZCBpbnZvaWNlIGxpbmsgYXMgU3RyaW5nIG9uIHN1Y2Nlc3MuXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY3JlYXRlaW52b2ljZWxpbmtcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVJbnZvaWNlTGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUludm9pY2VMaW5rKHRpdGxlLCBkZXNjcmlwdGlvbiwgcGF5bG9hZCwgcHJvdmlkZXJUb2tlbiwgY3VycmVuY3ksIHByaWNlcykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuXG4gICAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgICBmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICBmb3JtLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgZm9ybS5wcm92aWRlcl90b2tlbiA9IHByb3ZpZGVyVG9rZW47XG4gICAgICBmb3JtLmN1cnJlbmN5ID0gY3VycmVuY3k7XG4gICAgICBmb3JtLnByaWNlcyA9IHN0cmluZ2lmeShwcmljZXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZUludm9pY2VMaW5rJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlcGx5IHRvIHNoaXBwaW5nIHF1ZXJpZXMuXG4gICAgKlxuICAgICogSWYgeW91IHNlbnQgYW4gaW52b2ljZSByZXF1ZXN0aW5nIGEgc2hpcHBpbmcgYWRkcmVzcyBhbmQgdGhlIHBhcmFtZXRlciBpc19mbGV4aWJsZSB3YXMgc3BlY2lmaWVkLFxuICAgICogdGhlIEJvdCBBUEkgd2lsbCBzZW5kIGFuIFtVcGRhdGVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBkYXRlKSB3aXRoIGEgc2hpcHBpbmdfcXVlcnkgZmllbGQgdG8gdGhlIGJvdFxuICAgICpcbiAgICAqIEBwYXJhbSAge1N0cmluZ30gc2hpcHBpbmdRdWVyeUlkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHF1ZXJ5IHRvIGJlIGFuc3dlcmVkXG4gICAgKiBAcGFyYW0gIHtCb29sZWFufSBvayBTcGVjaWZ5IGlmIGRlbGl2ZXJ5IG9mIHRoZSBwcm9kdWN0IGlzIHBvc3NpYmxlXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIFRydWUgaXMgcmV0dXJuZWRcbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJzaGlwcGluZ3F1ZXJ5XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYW5zd2VyU2hpcHBpbmdRdWVyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuc3dlclNoaXBwaW5nUXVlcnkoc2hpcHBpbmdRdWVyeUlkLCBvaykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLnNoaXBwaW5nX3F1ZXJ5X2lkID0gc2hpcHBpbmdRdWVyeUlkO1xuICAgICAgZm9ybS5vayA9IG9rO1xuICAgICAgZm9ybS5zaGlwcGluZ19vcHRpb25zID0gc3RyaW5naWZ5KGZvcm0uc2hpcHBpbmdfb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYW5zd2VyU2hpcHBpbmdRdWVyeScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVzcG9uZCB0byBzdWNoIHByZS1jaGVja291dCBxdWVyaWVzXG4gICAgICpcbiAgICAgKiBPbmNlIHRoZSB1c2VyIGhhcyBjb25maXJtZWQgdGhlaXIgcGF5bWVudCBhbmQgc2hpcHBpbmcgZGV0YWlscywgdGhlIEJvdCBBUEkgc2VuZHMgdGhlIGZpbmFsIGNvbmZpcm1hdGlvbiBpbiB0aGUgZm9ybSBvZlxuICAgICAqIGFuIFtVcGRhdGVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBkYXRlKSB3aXRoIHRoZSBmaWVsZCAqcHJlX2NoZWNrb3V0X3F1ZXJ5Ki5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgQm90IEFQSSBtdXN0IHJlY2VpdmUgYW4gYW5zd2VyIHdpdGhpbiAxMCBzZWNvbmRzIGFmdGVyIHRoZSBwcmUtY2hlY2tvdXQgcXVlcnkgd2FzIHNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByZUNoZWNrb3V0UXVlcnlJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeSB0byBiZSBhbnN3ZXJlZFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9rIFNwZWNpZnkgaWYgZXZlcnkgb3JkZXIgZGV0YWlscyBhcmUgb2tcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBUcnVlIGlzIHJldHVybmVkXG4gICAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcnByZWNoZWNrb3V0cXVlcnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYW5zd2VyUHJlQ2hlY2tvdXRRdWVyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuc3dlclByZUNoZWNrb3V0UXVlcnkocHJlQ2hlY2tvdXRRdWVyeUlkLCBvaykge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLnByZV9jaGVja291dF9xdWVyeV9pZCA9IHByZUNoZWNrb3V0UXVlcnlJZDtcbiAgICAgIGZvcm0ub2sgPSBvaztcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJQcmVDaGVja291dFF1ZXJ5JywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGEgZ2FtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBnYW1lU2hvcnROYW1lIG5hbWUgb2YgdGhlIGdhbWUgdG8gYmUgc2VudC4gU2V0IHVwIHlvdXIgZ2FtZXMgdmlhIGBAQm90RmF0aGVyYC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kZ2FtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZW5kR2FtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRHYW1lKGNoYXRJZCwgZ2FtZVNob3J0TmFtZSkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgICBmb3JtLmdhbWVfc2hvcnRfbmFtZSA9IGdhbWVTaG9ydE5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZEdhbWUnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgc2NvcmUgb2YgdGhlIHNwZWNpZmllZCB1c2VyIGluIGEgZ2FtZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NvcmUgTmV3IHNjb3JlIHZhbHVlLCBtdXN0IGJlIG5vbi1uZWdhdGl2ZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRnYW1lc2NvcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0R2FtZVNjb3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R2FtZVNjb3JlKHVzZXJJZCwgc2NvcmUpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgICAgZm9ybS5zY29yZSA9IHNjb3JlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldEdhbWVTY29yZScsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGRhdGEgZm9yIGhpZ2ggc2NvcmUgdGFibGVzLlxuICAgICAqXG4gICAgICogV2lsbCByZXR1cm4gdGhlIHNjb3JlIG9mIHRoZSBzcGVjaWZpZWQgdXNlciBhbmQgc2V2ZXJhbCBvZiB0aGVpciBuZWlnaGJvcnMgaW4gYSBnYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHJldHVybnMgYW4gQXJyYXkgb2YgW0dhbWVIaWdoU2NvcmVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2FtZWhpZ2hzY29yZSkgb2JqZWN0c1xuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRnYW1laGlnaHNjb3Jlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRHYW1lSGlnaFNjb3JlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdhbWVIaWdoU2NvcmVzKHVzZXJJZCkge1xuICAgICAgdmFyIGZvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0R2FtZUhpZ2hTY29yZXMnLCB7IGZvcm06IGZvcm0gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgbWVzc2FnZSwgaW5jbHVkaW5nIHNlcnZpY2UgbWVzc2FnZXMsIHdpdGggdGhlIGZvbGxvd2luZyBsaW1pdGF0aW9uczpcbiAgICAqIC0gQSBtZXNzYWdlIGNhbiBvbmx5IGJlIGRlbGV0ZWQgaWYgaXQgd2FzIHNlbnQgbGVzcyB0aGFuIDQ4IGhvdXJzIGFnby5cbiAgICAqIC0gQSBkaWNlIG1lc3NhZ2UgY2FuIG9ubHkgYmUgZGVsZXRlZCBpZiBpdCB3YXMgc2VudCBtb3JlIHRoYW4gMjQgaG91cnMgYWdvLlxuICAgICogLSBCb3RzIGNhbiBkZWxldGUgb3V0Z29pbmcgbWVzc2FnZXMgaW4gZ3JvdXBzIGFuZCBzdXBlcmdyb3Vwcy5cbiAgICAqIC0gQm90cyBjYW4gZGVsZXRlIGluY29taW5nIG1lc3NhZ2VzIGluIGdyb3Vwcywgc3VwZXJncm91cHMgYW5kIGNoYW5uZWxzLlxuICAgICogLSBCb3RzIGdyYW50ZWQgYGNhbl9wb3N0X21lc3NhZ2VzYCBwZXJtaXNzaW9ucyBjYW4gZGVsZXRlIG91dGdvaW5nIG1lc3NhZ2VzIGluIGNoYW5uZWxzLlxuICAgICogLSBJZiB0aGUgYm90IGlzIGFuIGFkbWluaXN0cmF0b3Igb2YgYSBncm91cCwgaXQgY2FuIGRlbGV0ZSBhbnkgbWVzc2FnZSB0aGVyZS5cbiAgICAqIC0gSWYgdGhlIGJvdCBoYXMgYGNhbl9kZWxldGVfbWVzc2FnZXNgIHBlcm1pc3Npb24gaW4gYSBzdXBlcmdyb3VwLCBpdCBjYW4gZGVsZXRlIGFueSBtZXNzYWdlIHRoZXJlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgQGNoYW5uZWx1c2VybmFtZSlcbiAgICAqIEBwYXJhbSAge051bWJlcn0gbWVzc2FnZUlkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IG1lc3NhZ2VcbiAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlbWVzc2FnZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZU1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVNZXNzYWdlKGNoYXRJZCwgbWVzc2FnZUlkKSB7XG4gICAgICB2YXIgZm9ybSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVNZXNzYWdlJywgeyBmb3JtOiBmb3JtIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgbXVsdGlwbGUgbWVzc2FnZXMgc2ltdWx0YW5lb3VzbHkuIElmIHNvbWUgb2YgdGhlIHNwZWNpZmllZCBtZXNzYWdlcyBjYW4ndCBiZSBmb3VuZCwgdGhleSBhcmUgc2tpcHBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgQGNoYW5uZWx1c2VybmFtZSlcbiAgICAgKiBAcGFyYW0gIHtBcnJheTxOdW1iZXJ8U3RyaW5nPn0gbWVzc2FnZUlkcyAgSWRlbnRpZmllcnMgb2YgMS0xMDAgbWVzc2FnZXMgdG8gZGVsZXRlLiBTZWUgZGVsZXRlTWVzc2FnZSBmb3IgbGltaXRhdGlvbnMgb24gd2hpY2ggbWVzc2FnZXMgY2FuIGJlIGRlbGV0ZWRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW4+fSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlbWVzc2FnZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlTWVzc2FnZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVNZXNzYWdlcyhjaGF0SWQsIG1lc3NhZ2VJZHMpIHtcbiAgICAgIHZhciBmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgICAgZm9ybS5tZXNzYWdlX2lkcyA9IHN0cmluZ2lmeShtZXNzYWdlSWRzKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVNZXNzYWdlcycsIHsgZm9ybTogZm9ybSB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGVsZWdyYW1Cb3Q7XG59KEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gVGVsZWdyYW1Cb3Q7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegram.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegramPolling.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\").deprecate);\nvar ANOTHER_WEB_HOOK_USED = 409;\n\nvar TelegramBotPolling = function () {\n  /**\n   * Handles polling against the Telegram servers.\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  function TelegramBotPolling(bot) {\n    _classCallCheck(this, TelegramBotPolling);\n\n    this.bot = bot;\n    this.options = typeof bot.options.polling === 'boolean' ? {} : bot.options.polling;\n    this.options.interval = typeof this.options.interval === 'number' ? this.options.interval : 300;\n    this.options.params = _typeof(this.options.params) === 'object' ? this.options.params : {};\n    this.options.params.offset = typeof this.options.params.offset === 'number' ? this.options.params.offset : 0;\n    this.options.params.timeout = typeof this.options.params.timeout === 'number' ? this.options.params.timeout : 10;\n    if (typeof this.options.timeout === 'number') {\n      deprecate('`options.polling.timeout` is deprecated. Use `options.polling.params` instead.');\n      this.options.params.timeout = this.options.timeout;\n    }\n    this._lastUpdate = 0;\n    this._lastRequest = null;\n    this._abort = false;\n    this._pollingTimeout = null;\n  }\n\n  /**\n   * Start polling\n   * @param  {Object} [options]\n   * @param  {Object} [options.restart]\n   * @return {Promise}\n   */\n\n\n  _createClass(TelegramBotPolling, [{\n    key: 'start',\n    value: function start() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._lastRequest) {\n        if (!options.restart) {\n          return Promise.resolve();\n        }\n        return this.stop({\n          cancel: true,\n          reason: 'Polling restart'\n        }).then(function () {\n          return _this._polling();\n        });\n      }\n      return this._polling();\n    }\n\n    /**\n     * Stop polling\n     * @param  {Object} [options] Options\n     * @param  {Boolean} [options.cancel] Cancel current request\n     * @param  {String} [options.reason] Reason for stopping polling\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._lastRequest) {\n        return Promise.resolve();\n      }\n      var lastRequest = this._lastRequest;\n      this._lastRequest = null;\n      clearTimeout(this._pollingTimeout);\n      if (options.cancel) {\n        var reason = options.reason || 'Polling stop';\n        lastRequest.cancel(reason);\n        return Promise.resolve();\n      }\n      this._abort = true;\n      return lastRequest.finally(function () {\n        _this2._abort = false;\n      });\n    }\n\n    /**\n     * Return `true` if is polling. Otherwise, `false`.\n     */\n\n  }, {\n    key: 'isPolling',\n    value: function isPolling() {\n      return !!this._lastRequest;\n    }\n\n    /**\n     * Handle error thrown during polling.\n     * @private\n     * @param  {Error} error\n     */\n\n  }, {\n    key: '_error',\n    value: function _error(error) {\n      if (!this.bot.listeners('polling_error').length) {\n        return console.error('error: [polling_error] %j', error); // eslint-disable-line no-console\n      }\n      return this.bot.emit('polling_error', error);\n    }\n\n    /**\n     * Invokes polling (with recursion!)\n     * @return {Promise} promise of the current request\n     * @private\n     */\n\n  }, {\n    key: '_polling',\n    value: function _polling() {\n      var _this3 = this;\n\n      this._lastRequest = this._getUpdates().then(function (updates) {\n        _this3._lastUpdate = Date.now();\n        debug('polling data %j', updates);\n        updates.forEach(function (update) {\n          _this3.options.params.offset = update.update_id + 1;\n          debug('updated offset: %s', _this3.options.params.offset);\n          try {\n            _this3.bot.processUpdate(update);\n          } catch (err) {\n            err._processing = true;\n            throw err;\n          }\n        });\n        return null;\n      }).catch(function (err) {\n        debug('polling error: %s', err.message);\n        if (!err._processing) {\n          return _this3._error(err);\n        }\n        delete err._processing;\n        /*\n         * An error occured while processing the items,\n         * i.e. in `this.bot.processUpdate()` above.\n         * We need to mark the already-processed items\n         * to avoid fetching them again once the application\n         * is restarted, or moves to next polling interval\n         * (in cases where unhandled rejections do not terminate\n         * the process).\n         * See https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067\n         */\n        if (!_this3.bot.options.badRejection) {\n          return _this3._error(err);\n        }\n        var opts = {\n          offset: _this3.options.params.offset,\n          limit: 1,\n          timeout: 0\n        };\n        return _this3.bot.getUpdates(opts).then(function () {\n          return _this3._error(err);\n        }).catch(function (requestErr) {\n          /*\n           * We have been unable to handle this error.\n           * We have to log this to stderr to ensure devops\n           * understands that they may receive already-processed items\n           * on app restart.\n           * We simply can not rescue this situation, emit \"error\"\n           * event, with the hope that the application exits.\n           */\n          /* eslint-disable no-console */\n          var bugUrl = 'https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067';\n          console.error('error: Internal handling of The Offset Infinite Loop failed');\n          console.error('error: Due to error \\'' + requestErr + '\\'');\n          console.error('error: You may receive already-processed updates on app restart');\n          console.error('error: Please see ' + bugUrl + ' for more information');\n          /* eslint-enable no-console */\n          return _this3.bot.emit('error', new errors.FatalError(err));\n        });\n      }).finally(function () {\n        if (_this3._abort) {\n          debug('Polling is aborted!');\n        } else {\n          debug('setTimeout for %s miliseconds', _this3.options.interval);\n          _this3._pollingTimeout = setTimeout(function () {\n            return _this3._polling();\n          }, _this3.options.interval);\n        }\n      });\n      return this._lastRequest;\n    }\n\n    /**\n     * Unset current webhook. Used when we detect that a webhook has been set\n     * and we are trying to poll. Polling and WebHook are mutually exclusive.\n     * @see https://core.telegram.org/bots/api#getting-updates\n     * @private\n     */\n\n  }, {\n    key: '_unsetWebHook',\n    value: function _unsetWebHook() {\n      debug('unsetting webhook');\n      return this.bot._request('setWebHook');\n    }\n\n    /**\n     * Retrieve updates\n     */\n\n  }, {\n    key: '_getUpdates',\n    value: function _getUpdates() {\n      var _this4 = this;\n\n      debug('polling with options: %j', this.options.params);\n      return this.bot.getUpdates(this.options.params).catch(function (err) {\n        if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {\n          return _this4._unsetWebHook().then(function () {\n            return _this4.bot.getUpdates(_this4.options.params);\n          });\n        }\n        throw err;\n      });\n    }\n  }]);\n\n  return TelegramBotPolling;\n}();\n\nmodule.exports = TelegramBotPolling;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbVBvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUdBQXFHLHFCQUFxQixtQkFBbUI7O0FBRTdJLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsYUFBYSxtQkFBTyxDQUFDLDBFQUFVO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx5RkFBTztBQUMzQixnQkFBZ0IseUdBQTRCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxsaWJcXHRlbGVncmFtUG9sbGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdub2RlLXRlbGVncmFtLWJvdC1hcGknKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVwcmVjYXRlO1xudmFyIEFOT1RIRVJfV0VCX0hPT0tfVVNFRCA9IDQwOTtcblxudmFyIFRlbGVncmFtQm90UG9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEhhbmRsZXMgcG9sbGluZyBhZ2FpbnN0IHRoZSBUZWxlZ3JhbSBzZXJ2ZXJzLlxuICAgKiBAcGFyYW0gIHtUZWxlZ3JhbUJvdH0gYm90XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR0aW5nLXVwZGF0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIFRlbGVncmFtQm90UG9sbGluZyhib3QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVsZWdyYW1Cb3RQb2xsaW5nKTtcblxuICAgIHRoaXMuYm90ID0gYm90O1xuICAgIHRoaXMub3B0aW9ucyA9IHR5cGVvZiBib3Qub3B0aW9ucy5wb2xsaW5nID09PSAnYm9vbGVhbicgPyB7fSA6IGJvdC5vcHRpb25zLnBvbGxpbmc7XG4gICAgdGhpcy5vcHRpb25zLmludGVydmFsID0gdHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbCA9PT0gJ251bWJlcicgPyB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgOiAzMDA7XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcyA9IF90eXBlb2YodGhpcy5vcHRpb25zLnBhcmFtcykgPT09ICdvYmplY3QnID8gdGhpcy5vcHRpb25zLnBhcmFtcyA6IHt9O1xuICAgIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID09PSAnbnVtYmVyJyA/IHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0IDogMDtcbiAgICB0aGlzLm9wdGlvbnMucGFyYW1zLnRpbWVvdXQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA6IDEwO1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICBkZXByZWNhdGUoJ2BvcHRpb25zLnBvbGxpbmcudGltZW91dGAgaXMgZGVwcmVjYXRlZC4gVXNlIGBvcHRpb25zLnBvbGxpbmcucGFyYW1zYCBpbnN0ZWFkLicpO1xuICAgICAgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSAwO1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9hYm9ydCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvbGxpbmdUaW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwb2xsaW5nXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMucmVzdGFydF1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGVsZWdyYW1Cb3RQb2xsaW5nLCBbe1xuICAgIGtleTogJ3N0YXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmICh0aGlzLl9sYXN0UmVxdWVzdCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVzdGFydCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9wKHtcbiAgICAgICAgICBjYW5jZWw6IHRydWUsXG4gICAgICAgICAgcmVhc29uOiAnUG9sbGluZyByZXN0YXJ0J1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX3BvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcG9sbGluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZ1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxdIENhbmNlbCBjdXJyZW50IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBzdG9wcGluZyBwb2xsaW5nXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAoIXRoaXMuX2xhc3RSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0UmVxdWVzdCA9IHRoaXMuX2xhc3RSZXF1ZXN0O1xuICAgICAgdGhpcy5fbGFzdFJlcXVlc3QgPSBudWxsO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3BvbGxpbmdUaW1lb3V0KTtcbiAgICAgIGlmIChvcHRpb25zLmNhbmNlbCkge1xuICAgICAgICB2YXIgcmVhc29uID0gb3B0aW9ucy5yZWFzb24gfHwgJ1BvbGxpbmcgc3RvcCc7XG4gICAgICAgIGxhc3RSZXF1ZXN0LmNhbmNlbChyZWFzb24pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hYm9ydCA9IHRydWU7XG4gICAgICByZXR1cm4gbGFzdFJlcXVlc3QuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5fYWJvcnQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgaXMgcG9sbGluZy4gT3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1BvbGxpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BvbGxpbmcoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9sYXN0UmVxdWVzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZXJyb3IgdGhyb3duIGR1cmluZyBwb2xsaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7RXJyb3J9IGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19lcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lcnJvcihlcnJvcikge1xuICAgICAgaWYgKCF0aGlzLmJvdC5saXN0ZW5lcnMoJ3BvbGxpbmdfZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBbcG9sbGluZ19lcnJvcl0gJWonLCBlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYm90LmVtaXQoJ3BvbGxpbmdfZXJyb3InLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBwb2xsaW5nICh3aXRoIHJlY3Vyc2lvbiEpXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSBvZiB0aGUgY3VycmVudCByZXF1ZXN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3BvbGxpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9sbGluZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IHRoaXMuX2dldFVwZGF0ZXMoKS50aGVuKGZ1bmN0aW9uICh1cGRhdGVzKSB7XG4gICAgICAgIF90aGlzMy5fbGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIGRlYnVnKCdwb2xsaW5nIGRhdGEgJWonLCB1cGRhdGVzKTtcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID0gdXBkYXRlLnVwZGF0ZV9pZCArIDE7XG4gICAgICAgICAgZGVidWcoJ3VwZGF0ZWQgb2Zmc2V0OiAlcycsIF90aGlzMy5vcHRpb25zLnBhcmFtcy5vZmZzZXQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdGhpczMuYm90LnByb2Nlc3NVcGRhdGUodXBkYXRlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5fcHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdwb2xsaW5nIGVycm9yOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKCFlcnIuX3Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBlcnIuX3Byb2Nlc3Npbmc7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgaXRlbXMsXG4gICAgICAgICAqIGkuZS4gaW4gYHRoaXMuYm90LnByb2Nlc3NVcGRhdGUoKWAgYWJvdmUuXG4gICAgICAgICAqIFdlIG5lZWQgdG8gbWFyayB0aGUgYWxyZWFkeS1wcm9jZXNzZWQgaXRlbXNcbiAgICAgICAgICogdG8gYXZvaWQgZmV0Y2hpbmcgdGhlbSBhZ2FpbiBvbmNlIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgKiBpcyByZXN0YXJ0ZWQsIG9yIG1vdmVzIHRvIG5leHQgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgKiAoaW4gY2FzZXMgd2hlcmUgdW5oYW5kbGVkIHJlamVjdGlvbnMgZG8gbm90IHRlcm1pbmF0ZVxuICAgICAgICAgKiB0aGUgcHJvY2VzcykuXG4gICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2lzc3Vlcy8zNiNpc3N1ZWNvbW1lbnQtMjY4NTMyMDY3XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIV90aGlzMy5ib3Qub3B0aW9ucy5iYWRSZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIG9mZnNldDogX3RoaXMzLm9wdGlvbnMucGFyYW1zLm9mZnNldCxcbiAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICB0aW1lb3V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpczMuYm90LmdldFVwZGF0ZXMob3B0cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlcXVlc3RFcnIpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFdlIGhhdmUgYmVlbiB1bmFibGUgdG8gaGFuZGxlIHRoaXMgZXJyb3IuXG4gICAgICAgICAgICogV2UgaGF2ZSB0byBsb2cgdGhpcyB0byBzdGRlcnIgdG8gZW5zdXJlIGRldm9wc1xuICAgICAgICAgICAqIHVuZGVyc3RhbmRzIHRoYXQgdGhleSBtYXkgcmVjZWl2ZSBhbHJlYWR5LXByb2Nlc3NlZCBpdGVtc1xuICAgICAgICAgICAqIG9uIGFwcCByZXN0YXJ0LlxuICAgICAgICAgICAqIFdlIHNpbXBseSBjYW4gbm90IHJlc2N1ZSB0aGlzIHNpdHVhdGlvbiwgZW1pdCBcImVycm9yXCJcbiAgICAgICAgICAgKiBldmVudCwgd2l0aCB0aGUgaG9wZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBleGl0cy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgdmFyIGJ1Z1VybCA9ICdodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2lzc3Vlcy8zNiNpc3N1ZWNvbW1lbnQtMjY4NTMyMDY3JztcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogSW50ZXJuYWwgaGFuZGxpbmcgb2YgVGhlIE9mZnNldCBJbmZpbml0ZSBMb29wIGZhaWxlZCcpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBEdWUgdG8gZXJyb3IgXFwnJyArIHJlcXVlc3RFcnIgKyAnXFwnJyk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IFlvdSBtYXkgcmVjZWl2ZSBhbHJlYWR5LXByb2Nlc3NlZCB1cGRhdGVzIG9uIGFwcCByZXN0YXJ0Jyk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IFBsZWFzZSBzZWUgJyArIGJ1Z1VybCArICcgZm9yIG1vcmUgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmJvdC5lbWl0KCdlcnJvcicsIG5ldyBlcnJvcnMuRmF0YWxFcnJvcihlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5fYWJvcnQpIHtcbiAgICAgICAgICBkZWJ1ZygnUG9sbGluZyBpcyBhYm9ydGVkIScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdzZXRUaW1lb3V0IGZvciAlcyBtaWxpc2Vjb25kcycsIF90aGlzMy5vcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgICBfdGhpczMuX3BvbGxpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9wb2xsaW5nKCk7XG4gICAgICAgICAgfSwgX3RoaXMzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0UmVxdWVzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnNldCBjdXJyZW50IHdlYmhvb2suIFVzZWQgd2hlbiB3ZSBkZXRlY3QgdGhhdCBhIHdlYmhvb2sgaGFzIGJlZW4gc2V0XG4gICAgICogYW5kIHdlIGFyZSB0cnlpbmcgdG8gcG9sbC4gUG9sbGluZyBhbmQgV2ViSG9vayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR0aW5nLXVwZGF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfdW5zZXRXZWJIb29rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2V0V2ViSG9vaygpIHtcbiAgICAgIGRlYnVnKCd1bnNldHRpbmcgd2ViaG9vaycpO1xuICAgICAgcmV0dXJuIHRoaXMuYm90Ll9yZXF1ZXN0KCdzZXRXZWJIb29rJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdXBkYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0VXBkYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRVcGRhdGVzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGRlYnVnKCdwb2xsaW5nIHdpdGggb3B0aW9uczogJWonLCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgIHJldHVybiB0aGlzLmJvdC5nZXRVcGRhdGVzKHRoaXMub3B0aW9ucy5wYXJhbXMpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gQU5PVEhFUl9XRUJfSE9PS19VU0VEKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5fdW5zZXRXZWJIb29rKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LmJvdC5nZXRVcGRhdGVzKF90aGlzNC5vcHRpb25zLnBhcmFtcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRlbGVncmFtQm90UG9sbGluZztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZWxlZ3JhbUJvdFBvbGxpbmc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegramPolling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/telegramWebHook.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/lib/errors.js\");\nvar debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar bl = __webpack_require__(/*! bl */ \"(rsc)/./node_modules/bl/bl.js\");\n\nvar TelegramBotWebHook = function () {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  function TelegramBotWebHook(bot) {\n    _classCallCheck(this, TelegramBotWebHook);\n\n    this.bot = bot;\n    this.options = typeof bot.options.webHook === 'boolean' ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n\n\n  _createClass(TelegramBotWebHook, [{\n    key: 'open',\n    value: function open() {\n      var _this = this;\n\n      if (this.isOpen()) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve, reject) {\n        _this._webServer.listen(_this.options.port, _this.options.host, function () {\n          debug('WebHook listening on port %s', _this.options.port);\n          _this._open = true;\n          return resolve();\n        });\n\n        _this._webServer.once('error', function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * Close the webHook\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      var _this2 = this;\n\n      if (!this.isOpen()) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve, reject) {\n        _this2._webServer.close(function (error) {\n          if (error) return reject(error);\n          _this2._open = false;\n          return resolve();\n        });\n      });\n    }\n\n    /**\n     * Return `true` if server is listening. Otherwise, `false`.\n     */\n\n  }, {\n    key: 'isOpen',\n    value: function isOpen() {\n      // NOTE: Since `http.Server.listening` was added in v5.7.0\n      // and we still need to support Node v4,\n      // we are going to fallback to 'this._open'.\n      // The following LOC would suffice for newer versions of Node.js\n      // return this._webServer.listening;\n      return this._open;\n    }\n\n    /**\n     * Handle error thrown during processing of webhook request.\n     * @private\n     * @param  {Error} error\n     */\n\n  }, {\n    key: '_error',\n    value: function _error(error) {\n      if (!this.bot.listeners('webhook_error').length) {\n        return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n      }\n      return this.bot.emit('webhook_error', error);\n    }\n\n    /**\n     * Handle request body by passing it to 'callback'\n     * @private\n     */\n\n  }, {\n    key: '_parseBody',\n    value: function _parseBody(error, body) {\n      if (error) {\n        return this._error(new errors.FatalError(error));\n      }\n\n      var data = void 0;\n      try {\n        data = JSON.parse(body.toString());\n      } catch (parseError) {\n        return this._error(new errors.ParseError(parseError.message));\n      }\n\n      return this.bot.processUpdate(data);\n    }\n\n    /**\n     * Listener for 'request' event on server\n     * @private\n     * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n     * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n     */\n\n  }, {\n    key: '_requestListener',\n    value: function _requestListener(req, res) {\n      debug('WebHook request URL: %s', req.url);\n      debug('WebHook request headers: %j', req.headers);\n\n      if (req.url.indexOf(this.bot.token) !== -1) {\n        if (req.method !== 'POST') {\n          debug('WebHook request isn\\'t a POST');\n          res.statusCode = 418; // I'm a teabot!\n          res.end();\n        } else {\n          req.pipe(bl(this._parseBody)).on('finish', function () {\n            return res.end('OK');\n          });\n        }\n      } else if (this._healthRegex.test(req.url)) {\n        debug('WebHook health check passed');\n        res.statusCode = 200;\n        res.end('OK');\n      } else {\n        debug('WebHook request unauthorized');\n        res.statusCode = 401;\n        res.end();\n      }\n    }\n  }]);\n\n  return TelegramBotWebHook;\n}();\n\nmodule.exports = TelegramBotWebHook;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi90ZWxlZ3JhbVdlYkhvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RixhQUFhLG1CQUFPLENBQUMsMEVBQVU7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHlGQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsU0FBUyxtQkFBTyxDQUFDLHlDQUFJOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxsaWJcXHRlbGVncmFtV2ViSG9vay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGJsID0gcmVxdWlyZSgnYmwnKTtcblxudmFyIFRlbGVncmFtQm90V2ViSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFNldHMgdXAgYSB3ZWJob29rIHRvIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBAcGFyYW0gIHtUZWxlZ3JhbUJvdH0gYm90XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR0aW5nLXVwZGF0ZXNcbiAgICovXG4gIGZ1bmN0aW9uIFRlbGVncmFtQm90V2ViSG9vayhib3QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVsZWdyYW1Cb3RXZWJIb29rKTtcblxuICAgIHRoaXMuYm90ID0gYm90O1xuICAgIHRoaXMub3B0aW9ucyA9IHR5cGVvZiBib3Qub3B0aW9ucy53ZWJIb29rID09PSAnYm9vbGVhbicgPyB7fSA6IGJvdC5vcHRpb25zLndlYkhvb2s7XG4gICAgdGhpcy5vcHRpb25zLmhvc3QgPSB0aGlzLm9wdGlvbnMuaG9zdCB8fCAnMC4wLjAuMCc7XG4gICAgdGhpcy5vcHRpb25zLnBvcnQgPSB0aGlzLm9wdGlvbnMucG9ydCB8fCA4NDQzO1xuICAgIHRoaXMub3B0aW9ucy5odHRwcyA9IHRoaXMub3B0aW9ucy5odHRwcyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMuaGVhbHRoRW5kcG9pbnQgPSB0aGlzLm9wdGlvbnMuaGVhbHRoRW5kcG9pbnQgfHwgJy9oZWFsdGh6JztcbiAgICB0aGlzLl9oZWFsdGhSZWdleCA9IG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLmhlYWx0aEVuZHBvaW50KTtcbiAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIgPSB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wYXJzZUJvZHkgPSB0aGlzLl9wYXJzZUJvZHkuYmluZCh0aGlzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua2V5ICYmIHRoaXMub3B0aW9ucy5jZXJ0KSB7XG4gICAgICBkZWJ1ZygnSFRUUFMgV2ViSG9vayBlbmFibGVkIChieSBrZXkvY2VydCknKTtcbiAgICAgIHRoaXMub3B0aW9ucy5odHRwcy5rZXkgPSBmcy5yZWFkRmlsZVN5bmModGhpcy5vcHRpb25zLmtleSk7XG4gICAgICB0aGlzLm9wdGlvbnMuaHR0cHMuY2VydCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLm9wdGlvbnMuY2VydCk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwcy5jcmVhdGVTZXJ2ZXIodGhpcy5vcHRpb25zLmh0dHBzLCB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBmeCkge1xuICAgICAgZGVidWcoJ0hUVFBTIFdlYkhvb2sgZW5hYmxlZCAoYnkgcGZ4KScpO1xuICAgICAgdGhpcy5vcHRpb25zLmh0dHBzLnBmeCA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLm9wdGlvbnMucGZ4KTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHBzLmNyZWF0ZVNlcnZlcih0aGlzLm9wdGlvbnMuaHR0cHMsIHRoaXMuX3JlcXVlc3RMaXN0ZW5lcik7XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuaHR0cHMpLmxlbmd0aCkge1xuICAgICAgZGVidWcoJ0hUVFBTIFdlYkhvb2sgZW5hYmxlZCBieSAoaHR0cHMpJyk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwcy5jcmVhdGVTZXJ2ZXIodGhpcy5vcHRpb25zLmh0dHBzLCB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnSFRUUCBXZWJIb29rIGVuYWJsZWQnKTtcbiAgICAgIHRoaXMuX3dlYlNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKHRoaXMuX3JlcXVlc3RMaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gV2ViSG9vayBieSBsaXN0ZW5pbmcgb24gdGhlIHBvcnRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVGVsZWdyYW1Cb3RXZWJIb29rLCBbe1xuICAgIGtleTogJ29wZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3dlYlNlcnZlci5saXN0ZW4oX3RoaXMub3B0aW9ucy5wb3J0LCBfdGhpcy5vcHRpb25zLmhvc3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZygnV2ViSG9vayBsaXN0ZW5pbmcgb24gcG9ydCAlcycsIF90aGlzLm9wdGlvbnMucG9ydCk7XG4gICAgICAgICAgX3RoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLl93ZWJTZXJ2ZXIub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIHdlYkhvb2tcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpczIuX3dlYlNlcnZlci5jbG9zZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIF90aGlzMi5fb3BlbiA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiBzZXJ2ZXIgaXMgbGlzdGVuaW5nLiBPdGhlcndpc2UsIGBmYWxzZWAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzT3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgIC8vIE5PVEU6IFNpbmNlIGBodHRwLlNlcnZlci5saXN0ZW5pbmdgIHdhcyBhZGRlZCBpbiB2NS43LjBcbiAgICAgIC8vIGFuZCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgTm9kZSB2NCxcbiAgICAgIC8vIHdlIGFyZSBnb2luZyB0byBmYWxsYmFjayB0byAndGhpcy5fb3BlbicuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIExPQyB3b3VsZCBzdWZmaWNlIGZvciBuZXdlciB2ZXJzaW9ucyBvZiBOb2RlLmpzXG4gICAgICAvLyByZXR1cm4gdGhpcy5fd2ViU2VydmVyLmxpc3RlbmluZztcbiAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBlcnJvciB0aHJvd24gZHVyaW5nIHByb2Nlc3Npbmcgb2Ygd2ViaG9vayByZXF1ZXN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7RXJyb3J9IGVycm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19lcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lcnJvcihlcnJvcikge1xuICAgICAgaWYgKCF0aGlzLmJvdC5saXN0ZW5lcnMoJ3dlYmhvb2tfZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBbd2ViaG9va19lcnJvcl0gJWonLCBlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYm90LmVtaXQoJ3dlYmhvb2tfZXJyb3InLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJlcXVlc3QgYm9keSBieSBwYXNzaW5nIGl0IHRvICdjYWxsYmFjaydcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VCb2R5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlQm9keShlcnJvciwgYm9keSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyb3IpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShib2R5LnRvU3RyaW5nKCkpO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IobmV3IGVycm9ycy5QYXJzZUVycm9yKHBhcnNlRXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ib3QucHJvY2Vzc1VwZGF0ZShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5lciBmb3IgJ3JlcXVlc3QnIGV2ZW50IG9uIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2h0dHAuaHRtbCNodHRwX2h0dHBfY3JlYXRlc2VydmVyX3JlcXVlc3RsaXN0ZW5lclxuICAgICAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9odHRwcy5odG1sI2h0dHBzX2h0dHBzX2NyZWF0ZXNlcnZlcl9vcHRpb25zX3JlcXVlc3RsaXN0ZW5lclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVxdWVzdExpc3RlbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RMaXN0ZW5lcihyZXEsIHJlcykge1xuICAgICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCBVUkw6ICVzJywgcmVxLnVybCk7XG4gICAgICBkZWJ1ZygnV2ViSG9vayByZXF1ZXN0IGhlYWRlcnM6ICVqJywgcmVxLmhlYWRlcnMpO1xuXG4gICAgICBpZiAocmVxLnVybC5pbmRleE9mKHRoaXMuYm90LnRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgICAgIGRlYnVnKCdXZWJIb29rIHJlcXVlc3QgaXNuXFwndCBhIFBPU1QnKTtcbiAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IDQxODsgLy8gSSdtIGEgdGVhYm90IVxuICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXEucGlwZShibCh0aGlzLl9wYXJzZUJvZHkpKS5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5lbmQoJ09LJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faGVhbHRoUmVnZXgudGVzdChyZXEudXJsKSkge1xuICAgICAgICBkZWJ1ZygnV2ViSG9vayBoZWFsdGggY2hlY2sgcGFzc2VkJyk7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjAwO1xuICAgICAgICByZXMuZW5kKCdPSycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCB1bmF1dGhvcml6ZWQnKTtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDE7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGVsZWdyYW1Cb3RXZWJIb29rO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVncmFtQm90V2ViSG9vazsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/telegramWebHook.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/lib/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\n// Native deprecation warning\nexports.deprecate = function (msg) {\n  return util.deprecate(function () {}, msg, 'node-telegram-bot-api')();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxsaWJcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4vLyBOYXRpdmUgZGVwcmVjYXRpb24gd2FybmluZ1xuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbiAobXNnKSB7XG4gIHJldHVybiB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7fSwgbXNnLCAnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJykoKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0IsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUV6VTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsNkZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcbm9kZV9tb2R1bGVzXFxkZWJ1Z1xcc3JjXFxicm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblxuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXG5cbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCAvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG59XG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTsgLy8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICh0eXBlb2YgY29uc29sZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnNvbGUpKSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS5sb2cgJiYgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcblxuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3dcbiAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblxuXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICAvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG4gICAgLy8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG52YXIgZm9ybWF0dGVycyA9IG1vZHVsZS5leHBvcnRzLmZvcm1hdHRlcnM7XG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZGFyc2hcXE9uZURyaXZlXFxEZXNrdG9wXFxDb2RlXFxNRVJOIFdlYiBEZXZcXEdyYXBoaVxcbm9kZV9tb2R1bGVzXFxub2RlLXRlbGVncmFtLWJvdC1hcGlcXG5vZGVfbW9kdWxlc1xcZGVidWdcXHNyY1xcY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsS0FBZTtBQUNwRixFQUFFLHdJQUF3QztBQUMxQyxFQUFFO0FBQ0YsRUFBRSxrSUFBcUM7QUFDdkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZGFyc2hcXE9uZURyaXZlXFxEZXNrdG9wXFxDb2RlXFxNRVJOIFdlYiBEZXZcXEdyYXBoaVxcbm9kZV9tb2R1bGVzXFxub2RlLXRlbGVncmFtLWJvdC1hcGlcXG5vZGVfbW9kdWxlc1xcZGVidWdcXHNyY1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Module dependencies.\n */\nvar tty = __webpack_require__(/*! tty */ \"tty\");\n\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n\n  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n  }\n} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // Camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  }); // Coerce string value into JS value\n\n  var val = process.env[key];\n\n  if (/^(yes|on|true|enabled)$/i.test(val)) {\n    val = true;\n  } else if (/^(no|off|false|disabled)$/i.test(val)) {\n    val = false;\n  } else if (val === 'null') {\n    val = null;\n  } else {\n    val = Number(val);\n  }\n\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var name = this.namespace,\n      useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = \"\\x1B[3\" + (c < 8 ? c : '8;5;' + c);\n    var prefix = \"  \".concat(colorCode, \";1m\").concat(name, \" \\x1B[0m\");\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + \"\\x1B[0m\");\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  }\n\n  return new Date().toISOString() + ' ';\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (namespaces) {\n    process.env.DEBUG = namespaces;\n  } else {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n')\n    .map(function (str) { return str.trim(); })\n    .join(' ');\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nformatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QjtBQUNBO0FBQ0E7OztBQUdBLFlBQVk7QUFDWixXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFnQjs7QUFFOUM7QUFDQSxJQUFJLGNBQWM7QUFDbEI7QUFDQSxFQUFFLGlCQUFpQiw0REFBNEQ7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQjtBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDZGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcbm9kZV9tb2R1bGVzXFxkZWJ1Z1xcc3JjXFxub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcbiAgLy8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuICB2YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cbiAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFsyMCwgMjEsIDI2LCAyNywgMzIsIDMzLCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDU2LCA1NywgNjIsIDYzLCA2OCwgNjksIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLCA4MSwgOTIsIDkzLCA5OCwgOTksIDExMiwgMTEzLCAxMjgsIDEyOSwgMTM0LCAxMzUsIDE0OCwgMTQ5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc4LCAxNzksIDE4NCwgMTg1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjE0LCAyMTUsIDIyMCwgMjIxXTtcbiAgfVxufSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gQ2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleS5zdWJzdHJpbmcoNikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykge1xuICAgIHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG4gIH0pOyAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcblxuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuICAgIHZhbCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG4gICAgdmFsID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgfVxuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgcmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6IHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlLFxuICAgICAgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgaWYgKHVzZUNvbG9ycykge1xuICAgIHZhciBjID0gdGhpcy5jb2xvcjtcbiAgICB2YXIgY29sb3JDb2RlID0gXCJcXHgxQlszXCIgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG4gICAgdmFyIHByZWZpeCA9IFwiICBcIi5jb25jYXQoY29sb3JDb2RlLCBcIjsxbVwiKS5jb25jYXQobmFtZSwgXCIgXFx4MUJbMG1cIik7XG4gICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuICAgIGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArIFwiXFx4MUJbMG1cIik7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG4gIGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbn1cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobmFtZXNwYWNlcykge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIudHJpbSgpOyB9KVxuICAgIC5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/node_modules/eventemitter3/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/node_modules/eventemitter3/index.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxub2RlX21vZHVsZXNcXGV2ZW50ZW1pdHRlcjNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.BaseError = class BaseError extends Error {\n  /**\n   * @class BaseError\n   * @constructor\n   * @private\n   * @param  {String} code Error code\n   * @param  {String} message Error message\n   */\n  constructor(code, message) {\n    super(`${code}: ${message}`);\n    this.code = code;\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      message: this.message,\n    };\n  }\n};\n\n\nexports.FatalError = class FatalError extends exports.BaseError {\n  /**\n   * Fatal Error. Error code is `\"EFATAL\"`.\n   * @class FatalError\n   * @constructor\n   * @param  {String|Error} data Error object or message\n   */\n  constructor(data) {\n    const error = (typeof data === 'string') ? null : data;\n    const message = error ? error.message : data;\n    super('EFATAL', message);\n    if (error) this.stack = error.stack;\n  }\n};\n\n\nexports.ParseError = class ParseError extends exports.BaseError {\n  /**\n   * Error during parsing. Error code is `\"EPARSE\"`.\n   * @class ParseError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  constructor(message, response) {\n    super('EPARSE', message);\n    this.response = response;\n  }\n};\n\n\nexports.TelegramError = class TelegramError extends exports.BaseError {\n  /**\n   * Error returned from Telegram. Error code is `\"ETELEGRAM\"`.\n   * @class TelegramError\n   * @constructor\n   * @param  {String} message Error message\n   * @param  {http.IncomingMessage} response Server response\n   */\n  constructor(message, response) {\n    super('ETELEGRAM', message);\n    this.response = response;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxLQUFLLElBQUksUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxzcmNcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLkJhc2VFcnJvciA9IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEBjbGFzcyBCYXNlRXJyb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY29kZSBFcnJvciBjb2RlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIoYCR7Y29kZX06ICR7bWVzc2FnZX1gKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgIH07XG4gIH1cbn07XG5cblxuZXhwb3J0cy5GYXRhbEVycm9yID0gY2xhc3MgRmF0YWxFcnJvciBleHRlbmRzIGV4cG9ydHMuQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEZhdGFsIEVycm9yLiBFcnJvciBjb2RlIGlzIGBcIkVGQVRBTFwiYC5cbiAgICogQGNsYXNzIEZhdGFsRXJyb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ3xFcnJvcn0gZGF0YSBFcnJvciBvYmplY3Qgb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGNvbnN0IGVycm9yID0gKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgPyBudWxsIDogZGF0YTtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZGF0YTtcbiAgICBzdXBlcignRUZBVEFMJywgbWVzc2FnZSk7XG4gICAgaWYgKGVycm9yKSB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5QYXJzZUVycm9yID0gY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIGV4cG9ydHMuQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGR1cmluZyBwYXJzaW5nLiBFcnJvciBjb2RlIGlzIGBcIkVQQVJTRVwiYC5cbiAgICogQGNsYXNzIFBhcnNlRXJyb3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSAge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXNwb25zZSBTZXJ2ZXIgcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoJ0VQQVJTRScsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgfVxufTtcblxuXG5leHBvcnRzLlRlbGVncmFtRXJyb3IgPSBjbGFzcyBUZWxlZ3JhbUVycm9yIGV4dGVuZHMgZXhwb3J0cy5CYXNlRXJyb3Ige1xuICAvKipcbiAgICogRXJyb3IgcmV0dXJuZWQgZnJvbSBUZWxlZ3JhbS4gRXJyb3IgY29kZSBpcyBgXCJFVEVMRUdSQU1cImAuXG4gICAqIEBjbGFzcyBUZWxlZ3JhbUVycm9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgU2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgIHN1cGVyKCdFVEVMRUdSQU0nLCBtZXNzYWdlKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js":
/*!************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegram.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// shims\n(__webpack_require__(/*! array.prototype.findindex */ \"(rsc)/./node_modules/array.prototype.findindex/index.js\").shim)(); // for Node.js v0.x\n\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst TelegramBotWebHook = __webpack_require__(/*! ./telegramWebHook */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js\");\nconst TelegramBotPolling = __webpack_require__(/*! ./telegramPolling */ \"(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/eventemitter3/index.js\");\nconst fileType = __webpack_require__(/*! file-type */ \"(rsc)/./node_modules/file-type/index.js\");\nconst request = __webpack_require__(/*! @cypress/request-promise */ \"(rsc)/./node_modules/@cypress/request-promise/lib/rp.js\");\nconst streamedRequest = __webpack_require__(/*! @cypress/request */ \"(rsc)/./node_modules/@cypress/request/index.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst mime = __webpack_require__(/*! mime */ \"(rsc)/./node_modules/mime/mime.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst URL = __webpack_require__(/*! url */ \"url\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\");\nconst deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\n\nconst _messageTypes = [\n  'text',\n  'animation',\n  'audio',\n  'channel_chat_created',\n  'contact',\n  'delete_chat_photo',\n  'dice',\n  'document',\n  'game',\n  'group_chat_created',\n  'invoice',\n  'left_chat_member',\n  'location',\n  'migrate_from_chat_id',\n  'migrate_to_chat_id',\n  'new_chat_members',\n  'new_chat_photo',\n  'new_chat_title',\n  'passport_data',\n  'photo',\n  'pinned_message',\n  'poll',\n  'sticker',\n  'successful_payment',\n  'supergroup_chat_created',\n  'video',\n  'video_note',\n  'voice',\n  'video_chat_started',\n  'video_chat_ended',\n  'video_chat_participants_invited',\n  'video_chat_scheduled',\n  'message_auto_delete_timer_changed',\n  'chat_invite_link',\n  'chat_member_updated',\n  'web_app_data',\n  'message_reaction'\n];\n\nconst _deprecatedMessageTypes = [\n  'new_chat_participant', 'left_chat_participant'\n];\n\n/**\n * JSON-serialize data. If the provided data is already a String,\n * return it as is.\n * @private\n * @param  {*} data\n * @return {String}\n */\nfunction stringify(data) {\n  if (typeof data === 'string') {\n    return data;\n  }\n  return JSON.stringify(data);\n}\n\n\nclass TelegramBot extends EventEmitter {\n  /**\n   * The different errors the library uses.\n   * @type {Object}\n   */\n  static get errors() {\n    return errors;\n  }\n\n  /**\n   * The types of message updates the library handles.\n   * @type {String[]}\n   */\n  static get messageTypes() {\n    return _messageTypes;\n  }\n\n  /**\n   * Add listener for the specified [event](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events).\n   * This is the usual `emitter.on()` method.\n   * @param  {String} event\n   * @param  {Function} listener\n   * @see {@link https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events|Available events}\n   * @see https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\n   */\n  on(event, listener) {\n    if (_deprecatedMessageTypes.indexOf(event) !== -1) {\n      const url = 'https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events';\n      deprecate(`Events ${_deprecatedMessageTypes.join(',')} are deprecated. See the updated list of events: ${url}`);\n    }\n    super.on(event, listener);\n  }\n\n  /**\n   * Both request method to obtain messages are implemented. To use standard polling, set `polling: true`\n   * on `options`. Notice that [webHook](https://core.telegram.org/bots/api#setwebhook) will need a SSL certificate.\n   * Emits `message` when a message arrives.\n   *\n   * @class TelegramBot\n   * @constructor\n   * @param {String} token Bot Token\n   * @param {Object} [options]\n   * @param {Boolean|Object} [options.polling=false] Set true to enable polling or set options.\n   *  If a WebHook has been set, it will be deleted automatically.\n   * @param {String|Number} [options.polling.timeout=10] *Deprecated. Use `options.polling.params` instead*.\n   *  Timeout in seconds for long polling.\n   * @param {Boolean} [options.testEnvironment=false] Set true to  work with test enviroment.\n   * When working with the test environment, you may use HTTP links without TLS to test your Web App.\n   * @param {String|Number} [options.polling.interval=300] Interval between requests in miliseconds\n   * @param {Boolean} [options.polling.autoStart=true] Start polling immediately\n   * @param {Object} [options.polling.params] Parameters to be used in polling API requests.\n   *  See https://core.telegram.org/bots/api#getupdates for more information.\n   * @param  {Number} [options.polling.params.timeout=10] Timeout in seconds for long polling.\n   * @param {Boolean|Object} [options.webHook=false] Set true to enable WebHook or set options\n   * @param {String} [options.webHook.host=\"0.0.0.0\"] Host to bind to\n   * @param {Number} [options.webHook.port=8443] Port to bind to\n   * @param {String} [options.webHook.key] Path to file with PEM private key for webHook server.\n   *  The file is read **synchronously**!\n   * @param {String} [options.webHook.cert] Path to file with PEM certificate (public) for webHook server.\n   *  The file is read **synchronously**!\n   * @param {String} [options.webHook.pfx] Path to file with PFX private key and certificate chain for webHook server.\n   *  The file is read **synchronously**!\n   * @param {Boolean} [options.webHook.autoOpen=true] Open webHook immediately\n   * @param {Object} [options.webHook.https] Options to be passed to `https.createServer()`.\n   *  Note that `options.webHook.key`, `options.webHook.cert` and `options.webHook.pfx`, if provided, will be\n   *  used to override `key`, `cert` and `pfx` in this object, respectively.\n   *  See https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener for more information.\n   * @param {String} [options.webHook.healthEndpoint=\"/healthz\"] An endpoint for health checks that always responds with 200 OK\n   * @param {Boolean} [options.onlyFirstMatch=false] Set to true to stop after first match. Otherwise, all regexps are executed\n   * @param {Object} [options.request] Options which will be added for all requests to telegram api.\n   *  See https://github.com/request/request#requestoptions-callback for more information.\n   * @param {String} [options.baseApiUrl=\"https://api.telegram.org\"] API Base URl; useful for proxying and testing\n   * @param {Boolean} [options.filepath=true] Allow passing file-paths as arguments when sending files,\n   *  such as photos using `TelegramBot#sendPhoto()`. See [usage information][usage-sending-files-performance]\n   *  for more information on this option and its consequences.\n   * @param {Boolean} [options.badRejection=false] Set to `true`\n   *  **if and only if** the Node.js version you're using terminates the\n   *  process on unhandled rejections. This option is only for\n   *  *forward-compatibility purposes*.\n   * @see https://core.telegram.org/bots/api\n   */\n  constructor(token, options = {}) {\n    super();\n    this.token = token;\n    this.options = options;\n    this.options.polling = (typeof options.polling === 'undefined') ? false : options.polling;\n    this.options.webHook = (typeof options.webHook === 'undefined') ? false : options.webHook;\n    this.options.baseApiUrl = options.baseApiUrl || 'https://api.telegram.org';\n    this.options.filepath = (typeof options.filepath === 'undefined') ? true : options.filepath;\n    this.options.badRejection = (typeof options.badRejection === 'undefined') ? false : options.badRejection;\n    this._textRegexpCallbacks = [];\n    this._replyListenerId = 0;\n    this._replyListeners = [];\n    this._polling = null;\n    this._webHook = null;\n\n    if (options.polling) {\n      const autoStart = options.polling.autoStart;\n      if (typeof autoStart === 'undefined' || autoStart === true) {\n        this.startPolling();\n      }\n    }\n\n    if (options.webHook) {\n      const autoOpen = options.webHook.autoOpen;\n      if (typeof autoOpen === 'undefined' || autoOpen === true) {\n        this.openWebHook();\n      }\n    }\n  }\n\n  /**\n   * Generates url with bot token and provided path/method you want to be got/executed by bot\n   * @param  {String} path\n   * @return {String} url\n   * @private\n   * @see https://core.telegram.org/bots/api#making-requests\n   */\n  _buildURL(_path) {\n    return `${this.options.baseApiUrl}/bot${this.token}${this.options.testEnvironment ? '/test' : ''}/${_path}`;\n  }\n\n  /**\n   * Fix 'reply_markup' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object; either 'form' or 'qs'\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  _fixReplyMarkup(obj) {\n    const replyMarkup = obj.reply_markup;\n    if (replyMarkup && typeof replyMarkup !== 'string') {\n      obj.reply_markup = stringify(replyMarkup);\n    }\n  }\n\n  /**\n   * Fix 'entities' or 'caption_entities' or 'explanation_entities' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object;\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   * @see https://core.telegram.org/bots/api#copymessage\n   * @see https://core.telegram.org/bots/api#sendpoll\n   */\n  _fixEntitiesField(obj) {\n    const entities = obj.entities;\n    const captionEntities = obj.caption_entities;\n    const explanationEntities = obj.explanation_entities;\n    if (entities && typeof entities !== 'string') {\n      obj.entities = stringify(entities);\n    }\n\n    if (captionEntities && typeof captionEntities !== 'string') {\n      obj.caption_entities = stringify(captionEntities);\n    }\n\n    if (explanationEntities && typeof explanationEntities !== 'string') {\n      obj.explanation_entities = stringify(explanationEntities);\n    }\n  }\n\n  _fixAddFileThumbnail(options, opts) {\n    if (options.thumb) {\n      if (opts.formData === null) {\n        opts.formData = {};\n      }\n\n      const attachName = 'photo';\n      const [formData] = this._formatSendData(attachName, options.thumb.replace('attach://', ''));\n\n      if (formData) {\n        opts.formData[attachName] = formData[attachName];\n        opts.qs.thumbnail = `attach://${attachName}`;\n      }\n    }\n  }\n\n  /**\n   * Fix 'reply_parameters' parameter by making it JSON-serialized, as\n   * required by the Telegram Bot API\n   * @param {Object} obj Object; either 'form' or 'qs'\n   * @private\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  _fixReplyParameters(obj) {\n    if (obj.hasOwnProperty('reply_parameters') && typeof obj.reply_parameters !== 'string') {\n      obj.reply_parameters = stringify(obj.reply_parameters);\n    }\n  }\n\n  /**\n   * Make request against the API\n   * @param  {String} _path API endpoint\n   * @param  {Object} [options]\n   * @private\n   * @return {Promise}\n   */\n  _request(_path, options = {}) {\n    if (!this.token) {\n      return Promise.reject(new errors.FatalError('Telegram Bot Token not provided!'));\n    }\n\n    if (this.options.request) {\n      Object.assign(options, this.options.request);\n    }\n\n    if (options.form) {\n      this._fixReplyMarkup(options.form);\n      this._fixEntitiesField(options.form);\n      this._fixReplyParameters(options.form);\n    }\n    if (options.qs) {\n      this._fixReplyMarkup(options.qs);\n      this._fixReplyParameters(options.qs);\n    }\n\n    options.method = 'POST';\n    options.url = this._buildURL(_path);\n    options.simple = false;\n    options.resolveWithFullResponse = true;\n    options.forever = true;\n    debug('HTTP request: %j', options);\n    return request(options)\n      .then(resp => {\n        let data;\n        try {\n          data = resp.body = JSON.parse(resp.body);\n        } catch (err) {\n          throw new errors.ParseError(`Error parsing response: ${resp.body}`, resp);\n        }\n\n        if (data.ok) {\n          return data.result;\n        }\n\n        throw new errors.TelegramError(`${data.error_code} ${data.description}`, resp);\n      }).catch(error => {\n        // TODO: why can't we do `error instanceof errors.BaseError`?\n        if (error.response) throw error;\n        throw new errors.FatalError(error);\n      });\n  }\n\n  /**\n   * Format data to be uploaded; handles file paths, streams and buffers\n   * @param  {String} type\n   * @param  {String|stream.Stream|Buffer} data\n   * @param  {Object} fileOptions File options\n   * @param  {String} [fileOptions.filename] File name\n   * @param  {String} [fileOptions.contentType] Content type (i.e. MIME)\n   * @return {Array} formatted\n   * @return {Object} formatted[0] formData\n   * @return {String} formatted[1] fileId\n   * @throws Error if Buffer file type is not supported.\n   * @see https://npmjs.com/package/file-type\n   * @private\n   */\n  _formatSendData(type, data, fileOptions = {}) {\n    const deprecationMessage =\n      'See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files' +\n      ' for more information on how sending files has been improved and' +\n      ' on how to disable this deprecation message altogether.';\n    let filedata = data;\n    let filename = fileOptions.filename;\n    let contentType = fileOptions.contentType;\n\n    if (data instanceof stream.Stream) {\n      if (!filename && data.path) {\n        // Will be 'null' if could not be parsed.\n        // For example, 'data.path' === '/?id=123' from 'request(\"https://example.com/?id=123\")'\n        const url = URL.parse(path.basename(data.path.toString()));\n        if (url.pathname) {\n          filename = qs.unescape(url.pathname);\n        }\n      }\n    } else if (Buffer.isBuffer(data)) {\n      if (!filename && !process.env.NTBA_FIX_350) {\n        deprecate(`Buffers will have their filenames default to \"filename\" instead of \"data\". ${deprecationMessage}`);\n        filename = 'data';\n      }\n      if (!contentType) {\n        const filetype = fileType(data);\n        if (filetype) {\n          contentType = filetype.mime;\n          const ext = filetype.ext;\n          if (ext && !process.env.NTBA_FIX_350) {\n            filename = `${filename}.${ext}`;\n          }\n        } else if (!process.env.NTBA_FIX_350) {\n          deprecate(`An error will no longer be thrown if file-type of buffer could not be detected. ${deprecationMessage}`);\n          throw new errors.FatalError('Unsupported Buffer file-type');\n        }\n      }\n    } else if (data) {\n      if (this.options.filepath && fs.existsSync(data)) {\n        filedata = fs.createReadStream(data);\n        if (!filename) {\n          filename = path.basename(data);\n        }\n      } else {\n        return [null, data];\n      }\n    } else {\n      return [null, data];\n    }\n\n    filename = filename || 'filename';\n    contentType = contentType || mime.lookup(filename);\n    if (process.env.NTBA_FIX_350) {\n      contentType = contentType || 'application/octet-stream';\n    } else {\n      deprecate(`In the future, content-type of files you send will default to \"application/octet-stream\". ${deprecationMessage}`);\n    }\n\n    // TODO: Add missing file extension.\n\n    return [{\n      [type]: {\n        value: filedata,\n        options: {\n          filename,\n          contentType,\n        },\n      },\n    }, null];\n  }\n\n  /**\n   * Start polling.\n   * Rejects returned promise if a WebHook is being used by this instance.\n   * @param  {Object} [options]\n   * @param  {Boolean} [options.restart=true] Consecutive calls to this method causes polling to be restarted\n   * @return {Promise}\n   */\n  startPolling(options = {}) {\n    if (this.hasOpenWebHook()) {\n      return Promise.reject(new errors.FatalError('Polling and WebHook are mutually exclusive'));\n    }\n    options.restart = typeof options.restart === 'undefined' ? true : options.restart;\n    if (!this._polling) {\n      this._polling = new TelegramBotPolling(this);\n    }\n    return this._polling.start(options);\n  }\n\n  /**\n   * Alias of `TelegramBot#startPolling()`. This is **deprecated**.\n   * @param  {Object} [options]\n   * @return {Promise}\n   * @deprecated\n   */\n  initPolling() {\n    deprecate('TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.');\n    return this.startPolling();\n  }\n\n  /**\n   * Stops polling after the last polling request resolves.\n   * Multiple invocations do nothing if polling is already stopped.\n   * Returning the promise of the last polling request is **deprecated**.\n   * @param  {Object} [options] Options\n   * @param  {Boolean} [options.cancel] Cancel current request\n   * @param  {String} [options.reason] Reason for stopping polling\n   * @return {Promise}\n   */\n  stopPolling(options) {\n    if (!this._polling) {\n      return Promise.resolve();\n    }\n    return this._polling.stop(options);\n  }\n\n  /**\n   * Get link for file.\n   * Use this method to get link for file for subsequent use.\n   * Attention: link will be valid for 1 hour.\n   *\n   * This method is a sugar extension of the (getFile)[#getfilefileid] method,\n   * which returns just path to file on remote server (you will have to manually build full uri after that).\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Promise which will have  *fileURI* in resolve callback\n   * @see https://core.telegram.org/bots/api#getfile\n   */\n  getFileLink(fileId, form = {}) {\n    return this.getFile(fileId, form)\n      .then(resp => `${this.options.baseApiUrl}/file/bot${this.token}/${resp.file_path}`);\n  }\n\n  /**\n   * Return a readable stream for file.\n   *\n   * `fileStream.path` is the specified file ID i.e. `fileId`.\n   * `fileStream` emits event `info` passing a single argument i.e.\n   * `info` with the interface `{ uri }` where `uri` is the URI of the\n   * file on Telegram servers.\n   *\n   * This method is a sugar extension of the [getFileLink](#TelegramBot+getFileLink) method,\n   * which returns the full URI to the file on remote server.\n   *\n   * @param  {String} fileId File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {stream.Readable} fileStream\n   */\n  getFileStream(fileId, form = {}) {\n    const fileStream = new stream.PassThrough();\n    fileStream.path = fileId;\n    this.getFileLink(fileId, form)\n      .then((fileURI) => {\n        fileStream.emit('info', {\n          uri: fileURI,\n        });\n        pump(streamedRequest(Object.assign({ uri: fileURI }, this.options.request)), fileStream);\n      })\n      .catch((error) => {\n        fileStream.emit('error', error);\n      });\n    return fileStream;\n  }\n\n  /**\n   * Downloads file in the specified folder.\n   *\n   * This method is a sugar extension of the [getFileStream](#TelegramBot+getFileStream) method,\n   * which returns a readable file stream.\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {String} downloadDir Absolute path to the folder in which file will be saved\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Promise, which will have *filePath* of downloaded file in resolve callback\n   */\n  downloadFile(fileId, downloadDir, form = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((a, b) => {\n      resolve = a;\n      reject = b;\n    });\n    const fileStream = this.getFileStream(fileId, form);\n    fileStream.on('info', (info) => {\n      const fileName = info.uri.slice(info.uri.lastIndexOf('/') + 1);\n      // TODO: Ensure fileName doesn't contains slashes\n      const filePath = path.join(downloadDir, fileName);\n      pump(fileStream, fs.createWriteStream(filePath), (error) => {\n        if (error) { return reject(error); }\n        return resolve(filePath);\n      });\n    });\n    fileStream.on('error', (err) => {\n      reject(err);\n    });\n    return promise;\n  }\n\n  /**\n   * Register a RegExp to test against an incomming text message.\n   * @param  {RegExp}   regexpRexecuted with `exec`.\n   * @param  {Function} callback     Callback will be called with 2 parameters,\n   * the `msg` and the result of executing `regexp.exec` on message text.\n   */\n  onText(regexp, callback) {\n    this._textRegexpCallbacks.push({ regexp, callback });\n  }\n\n  /**\n   * Remove a listener registered with `onText()`.\n   * @param  {RegExp} regexp RegExp used previously in `onText()`\n   * @return {Object} deletedListener The removed reply listener if\n   *   found. This object has `regexp` and `callback`\n   *   properties. If not found, returns `null`.\n   */\n  removeTextListener(regexp) {\n    const index = this._textRegexpCallbacks.findIndex((textListener) => {\n      return String(textListener.regexp) === String(regexp);\n    });\n    if (index === -1) {\n      return null;\n    }\n    return this._textRegexpCallbacks.splice(index, 1)[0];\n  }\n\n  /**\n   * Remove all listeners registered with `onText()`.\n   */\n  clearTextListeners() {\n    this._textRegexpCallbacks = [];\n  }\n\n  /**\n   * Register a reply to wait for a message response.\n   *\n   * @param  {Number|String} chatId The chat id where the message cames from.\n   * @param  {Number|String} messageId The message id to be replied.\n   * @param  {Function} callback Callback will be called with the reply\n   *  message.\n   * @return {Number} id The ID of the inserted reply listener.\n   */\n  onReplyToMessage(chatId, messageId, callback) {\n    const id = ++this._replyListenerId;\n    this._replyListeners.push({\n      id,\n      chatId,\n      messageId,\n      callback\n    });\n    return id;\n  }\n\n  /**\n   * Removes a reply that has been prev. registered for a message response.\n   * @param   {Number} replyListenerId The ID of the reply listener.\n   * @return  {Object} deletedListener The removed reply listener if\n   *   found. This object has `id`, `chatId`, `messageId` and `callback`\n   *   properties. If not found, returns `null`.\n   */\n  removeReplyListener(replyListenerId) {\n    const index = this._replyListeners.findIndex((replyListener) => {\n      return replyListener.id === replyListenerId;\n    });\n    if (index === -1) {\n      return null;\n    }\n    return this._replyListeners.splice(index, 1)[0];\n  }\n\n  /**\n   * Removes all replies that have been prev. registered for a message response.\n   *\n   * @return  {Array} deletedListeners An array of removed listeners.\n   */\n  clearReplyListeners() {\n    this._replyListeners = [];\n  }\n\n  /**\n   * Return true if polling. Otherwise, false.\n   *\n   * @return {Boolean}\n   */\n  isPolling() {\n    return this._polling ? this._polling.isPolling() : false;\n  }\n\n  /**\n   * Open webhook.\n   * Multiple invocations do nothing if webhook is already open.\n   * Rejects returned promise if Polling is being used by this instance.\n   *\n   * @return {Promise}\n   */\n  openWebHook() {\n    if (this.isPolling()) {\n      return Promise.reject(new errors.FatalError('WebHook and Polling are mutually exclusive'));\n    }\n    if (!this._webHook) {\n      this._webHook = new TelegramBotWebHook(this);\n    }\n    return this._webHook.open();\n  }\n\n  /**\n   * Close webhook after closing all current connections.\n   * Multiple invocations do nothing if webhook is already closed.\n   *\n   * @return {Promise} Promise\n   */\n  closeWebHook() {\n    if (!this._webHook) {\n      return Promise.resolve();\n    }\n    return this._webHook.close();\n  }\n\n  /**\n   * Return true if using webhook and it is open i.e. accepts connections.\n   * Otherwise, false.\n   *\n   * @return {Boolean}\n   */\n  hasOpenWebHook() {\n    return this._webHook ? this._webHook.isOpen() : false;\n  }\n\n\n  /**\n   * Process an update; emitting the proper events and executing regexp\n   * callbacks. This method is useful should you be using a different\n   * way to fetch updates, other than those provided by TelegramBot.\n   *\n   * @param  {Object} update\n   * @see https://core.telegram.org/bots/api#update\n   */\n  processUpdate(update) {\n    debug('Process Update %j', update);\n    const message = update.message;\n    const editedMessage = update.edited_message;\n    const channelPost = update.channel_post;\n    const editedChannelPost = update.edited_channel_post;\n    const businessConnection = update.business_connection;\n    const businesssMessage = update.business_message;\n    const editedBusinessMessage = update.edited_business_message;\n    const deletedBusinessMessage = update.deleted_business_messages;\n    const messageReaction = update.message_reaction;\n    const messageReactionCount = update.message_reaction_count;\n    const inlineQuery = update.inline_query;\n    const chosenInlineResult = update.chosen_inline_result;\n    const callbackQuery = update.callback_query;\n    const shippingQuery = update.shipping_query;\n    const preCheckoutQuery = update.pre_checkout_query;\n    const poll = update.poll;\n    const pollAnswer = update.poll_answer;\n    const myChatMember = update.my_chat_member;\n    const chatMember = update.chat_member;\n    const chatJoinRequest = update.chat_join_request;\n    const chatBoost = update.chat_boost;\n    const removedChatBoost = update.removed_chat_boost;\n\n\n    if (message) {\n      debug('Process Update message %j', message);\n      const metadata = {};\n      metadata.type = TelegramBot.messageTypes.find((messageType) => {\n        return message[messageType];\n      });\n      this.emit('message', message, metadata);\n      if (metadata.type) {\n        debug('Emitting %s: %j', metadata.type, message);\n        this.emit(metadata.type, message, metadata);\n      }\n      if (message.text) {\n        debug('Text message');\n        this._textRegexpCallbacks.some(reg => {\n          debug('Matching %s with %s', message.text, reg.regexp);\n\n          if (!(reg.regexp instanceof RegExp)) {\n            reg.regexp = new RegExp(reg.regexp);\n          }\n\n          const result = reg.regexp.exec(message.text);\n          if (!result) {\n            return false;\n          }\n          // reset index so we start at the beginning of the regex each time\n          reg.regexp.lastIndex = 0;\n          debug('Matches %s', reg.regexp);\n          reg.callback(message, result);\n          // returning truthy value exits .some\n          return this.options.onlyFirstMatch;\n        });\n      }\n      if (message.reply_to_message) {\n        // Only callbacks waiting for this message\n        this._replyListeners.forEach(reply => {\n          // Message from the same chat\n          if (reply.chatId === message.chat.id) {\n            // Responding to that message\n            if (reply.messageId === message.reply_to_message.message_id) {\n              // Resolve the promise\n              reply.callback(message);\n            }\n          }\n        });\n      }\n    } else if (editedMessage) {\n      debug('Process Update edited_message %j', editedMessage);\n      this.emit('edited_message', editedMessage);\n      if (editedMessage.text) {\n        this.emit('edited_message_text', editedMessage);\n      }\n      if (editedMessage.caption) {\n        this.emit('edited_message_caption', editedMessage);\n      }\n    } else if (channelPost) {\n      debug('Process Update channel_post %j', channelPost);\n      this.emit('channel_post', channelPost);\n    } else if (editedChannelPost) {\n      debug('Process Update edited_channel_post %j', editedChannelPost);\n      this.emit('edited_channel_post', editedChannelPost);\n      if (editedChannelPost.text) {\n        this.emit('edited_channel_post_text', editedChannelPost);\n      }\n      if (editedChannelPost.caption) {\n        this.emit('edited_channel_post_caption', editedChannelPost);\n      }\n    } else if (businessConnection) {\n      debug('Process Update business_connection %j', businessConnection);\n      this.emit('business_connection', businessConnection);\n    } else if (businesssMessage) {\n      debug('Process Update business_message %j', businesssMessage);\n      this.emit('business_message', businesssMessage);\n    } else if (editedBusinessMessage) {\n      debug('Process Update edited_business_message %j', editedBusinessMessage);\n      this.emit('edited_business_message', editedBusinessMessage);\n    } else if (deletedBusinessMessage) {\n      debug('Process Update deleted_business_messages %j', deletedBusinessMessage);\n      this.emit('deleted_business_messages', deletedBusinessMessage);\n    } else if (messageReaction) {\n      debug('Process Update message_reaction %j', messageReaction);\n      this.emit('message_reaction', messageReaction);\n    } else if (messageReactionCount) {\n      debug('Process Update message_reaction_count %j', messageReactionCount);\n      this.emit('message_reaction_count', messageReactionCount);\n    } else if (inlineQuery) {\n      debug('Process Update inline_query %j', inlineQuery);\n      this.emit('inline_query', inlineQuery);\n    } else if (chosenInlineResult) {\n      debug('Process Update chosen_inline_result %j', chosenInlineResult);\n      this.emit('chosen_inline_result', chosenInlineResult);\n    } else if (callbackQuery) {\n      debug('Process Update callback_query %j', callbackQuery);\n      this.emit('callback_query', callbackQuery);\n    } else if (shippingQuery) {\n      debug('Process Update shipping_query %j', shippingQuery);\n      this.emit('shipping_query', shippingQuery);\n    } else if (preCheckoutQuery) {\n      debug('Process Update pre_checkout_query %j', preCheckoutQuery);\n      this.emit('pre_checkout_query', preCheckoutQuery);\n    } else if (poll) {\n      debug('Process Update poll %j', poll);\n      this.emit('poll', poll);\n    } else if (pollAnswer) {\n      debug('Process Update poll_answer %j', pollAnswer);\n      this.emit('poll_answer', pollAnswer);\n    } else if (chatMember) {\n      debug('Process Update chat_member %j', chatMember);\n      this.emit('chat_member', chatMember);\n    } else if (myChatMember) {\n      debug('Process Update my_chat_member %j', myChatMember);\n      this.emit('my_chat_member', myChatMember);\n    } else if (chatJoinRequest) {\n      debug('Process Update my_chat_member %j', chatJoinRequest);\n      this.emit('chat_join_request', chatJoinRequest);\n    } else if (chatBoost) {\n      debug('Process Update chat_boost %j', chatBoost);\n      this.emit('chat_boost', chatBoost);\n    } else if (removedChatBoost) {\n      debug('Process Update removed_chat_boost %j', removedChatBoost);\n      this.emit('removed_chat_boost', removedChatBoost);\n    }\n  }\n\n  /** Start Telegram Bot API methods */\n\n  /**\n  * Use this method to receive incoming updates using long polling.\n  * This method has an [older, compatible signature][getUpdates-v0.25.0]\n  * that is being deprecated.\n  *\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise}\n  * @see https://core.telegram.org/bots/api#getupdates\n  */\n  getUpdates(form = {}) {\n    /* The older method signature was getUpdates(timeout, limit, offset).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0');\n      form = {\n        timeout: arguments[0],\n        limit: arguments[1],\n        offset: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n\n    return this._request('getUpdates', { form });\n  }\n\n  /**\n   * Specify an url to receive incoming updates via an outgoing webHook.\n   * This method has an [older, compatible signature][setWebHook-v0.25.0]\n   * that is being deprecated.\n   *\n   * @param  {String} url URL where Telegram will make HTTP Post. Leave empty to\n   * delete webHook.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {String|stream.Stream} [options.certificate] PEM certificate key (public).\n   * @param  {String} [options.secret_token] Optional secret token to be sent in a header `X-Telegram-Bot-Api-Secret-Token` in every webhook request.\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#setwebhook\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  setWebHook(url, options = {}, fileOptions = {}) {\n    /* The older method signature was setWebHook(url, cert).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    let cert;\n    // Note: 'options' could be an object, if a stream was provided (in place of 'cert')\n    if (typeof options !== 'object' || options instanceof stream.Stream) {\n      deprecate('The method signature setWebHook(url, cert) has been deprecated since v0.25.0');\n      cert = options;\n      options = {}; // eslint-disable-line no-param-reassign\n    } else {\n      cert = options.certificate;\n    }\n\n    const opts = {\n      qs: options,\n    };\n    opts.qs.url = url;\n\n    if (cert) {\n      try {\n        const sendData = this._formatSendData('certificate', cert, fileOptions);\n        opts.formData = sendData[0];\n        opts.qs.certificate = sendData[1];\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n    }\n\n    return this._request('setWebHook', opts);\n  }\n\n  /**\n   * Use this method to remove webhook integration if you decide to\n   * switch back to getUpdates. Returns True on success.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#deletewebhook\n   */\n  deleteWebHook(form = {}) {\n    return this._request('deleteWebhook', { form });\n  }\n\n  /**\n   * Use this method to get current webhook status.\n   * On success, returns a [WebhookInfo](https://core.telegram.org/bots/api#webhookinfo) object.\n   * If the bot is using getUpdates, will return an object with the\n   * url field empty.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#getwebhookinfo\n   */\n  getWebHookInfo(form = {}) {\n    return this._request('getWebhookInfo', { form });\n  }\n\n  /**\n   * A simple method for testing your bot's authentication token. Requires no parameters.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} basic information about the bot in form of a [User](https://core.telegram.org/bots/api#user) object.\n   * @see https://core.telegram.org/bots/api#getme\n   */\n  getMe(form = {}) {\n    return this._request('getMe', { form });\n  }\n\n  /**\n   * This method log out your bot from the cloud Bot API server before launching the bot locally.\n   * You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates.\n   * After a successful call, you will not be able to log in again using the same token for 10 minutes.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#logout\n   */\n  logOut(form = {}) {\n    return this._request('logOut', { form });\n  }\n\n  /**\n   * This method close the bot instance before moving it from one local server to another.\n   * This method will return error 429 in the first 10 minutes after the bot is launched.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#close\n   */\n  close(form = {}) {\n    return this._request('close', { form });\n  }\n\n  /**\n   * Send text message.\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} text Text of the message to be sent\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendmessage\n   */\n  sendMessage(chatId, text, form = {}) {\n    form.chat_id = chatId;\n    form.text = text;\n    return this._request('sendMessage', { form });\n  }\n\n  /**\n   * Forward messages of any kind.\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent (or channel username in the format `@channelusername`)\n   * @param  {Number|String} messageId  Unique message identifier in the chat specified in fromChatId\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}\n   * @see https://core.telegram.org/bots/api#forwardmessage\n   */\n  forwardMessage(chatId, fromChatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_id = messageId;\n    return this._request('forwardMessage', { form });\n  }\n\n  /**\n   * Use this method to forward multiple messages of any kind.\n   * If some of the specified messages can't be found or forwarded, they are skipped.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent (or channel username in the format `@channelusername`)\n   * @param  {Array<Number|String>} messageIds Identifiers of 1-100 messages in the chat from_chat_id to forward.\n   * The identifiers must be specified in a strictly increasing order.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} An array of MessageId of the sent messages on success\n   * @see https://core.telegram.org/bots/api#forwardmessages\n   */\n  forwardMessages(chatId, fromChatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_ids = messageIds;\n    return this._request('forwardMessages', { form });\n  }\n\n  /**\n   * Copy messages of any kind. **Service messages and invoice messages can't be copied.**\n   * The method is analogous to the method forwardMessages, but the copied message doesn't\n   * have a link to the original message.\n   * Returns the MessageId of the sent message on success.\n   * @param  {Number|String} chatId     Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent\n   * @param  {Number|String} messageId  Unique message identifier\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The [MessageId](https://core.telegram.org/bots/api#messageid) of the sent message on success\n   * @see https://core.telegram.org/bots/api#copymessage\n   */\n  copyMessage(chatId, fromChatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_id = messageId;\n    return this._request('copyMessage', { form });\n  }\n\n  /**\n   * Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped.\n   * Service messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.\n   * Returns the MessageId of the sent message on success.\n   * @param  {Number|String} chatId Unique identifier for the target chat\n   * @param  {Number|String} fromChatId Unique identifier for the chat where the\n   * original message was sent\n   * @param  {Array} messageIds  Identifiers of 1-100 messages in the chat from_chat_id to copy.\n   * The identifiers must be specified in a strictly increasing order.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} An array of MessageId of the sent messages\n   * @see https://core.telegram.org/bots/api#copymessages\n   */\n  copyMessages(chatId, fromChatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.from_chat_id = fromChatId;\n    form.message_ids = stringify(messageIds);\n    return this._request('copyMessages', { form });\n  }\n\n  /**\n   * Send photo\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} photo A file path or a Stream. Can\n   * also be a `file_id` previously uploaded\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendphoto\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendPhoto(chatId, photo, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('photo', photo, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.photo = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendPhoto', opts);\n  }\n\n  /**\n  * Send audio\n  *\n  * **Your audio must be in the .MP3 or .M4A format.**\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {String|stream.Stream|Buffer} audio A file path, Stream or Buffer.\n  * Can also be a `file_id` previously uploaded.\n  * @param  {Object} [options] Additional Telegram query options\n  * @param  {Object} [fileOptions] Optional file related meta-data\n  * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n  * @see https://core.telegram.org/bots/api#sendaudio\n  * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendAudio(chatId, audio, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n\n    opts.qs.chat_id = chatId;\n\n    try {\n      const sendData = this._formatSendData('audio', audio, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.audio = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    return this._request('sendAudio', opts);\n  }\n\n  /**\n  * Send Document\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {String|stream.Stream|Buffer} doc A file path, Stream or Buffer.\n  * Can also be a `file_id` previously uploaded.\n  * @param  {Object} [options] Additional Telegram query options\n  * @param  {Object} [fileOptions] Optional file related meta-data\n  * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n  * @see https://core.telegram.org/bots/api#sendDocument\n  * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendDocument(chatId, doc, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('document', doc, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.document = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    return this._request('sendDocument', opts);\n  }\n\n  /**\n   * Use this method to send video files, **Telegram clients support mp4 videos** (other formats may be sent as Document).\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} video A file path or Stream.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendvideo\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendVideo(chatId, video, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('video', video, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.video = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVideo', opts);\n  }\n\n  /**\n   * Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} animation A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendanimation\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendAnimation(chatId, animation, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('animation', animation, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.animation = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendAnimation', opts);\n  }\n\n  /**\n   * Send voice\n   *\n   * **Your audio must be in an .OGG file encoded with OPUS**, or in .MP3 format, or in .M4A format (other formats may be sent as Audio or Document)\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} voice A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendvoice\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendVoice(chatId, voice, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('voice', voice, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.voice = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVoice', opts);\n  }\n\n  /**\n   * Use this method to send video messages\n   * Telegram clients support **rounded square MPEG4 videos** of up to 1 minute long.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} videoNote A file path or Stream.\n   * Can also be a `file_id` previously uploaded.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @info The length parameter is actually optional. However, the API (at time of writing) requires you to always provide it until it is fixed.\n   * @see https://core.telegram.org/bots/api#sendvideonote\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n  */\n  sendVideoNote(chatId, videoNote, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('video_note', videoNote, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.video_note = sendData[1];\n      this._fixAddFileThumbnail(options, opts);\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendVideoNote', opts);\n  }\n\n  /**\n   * Use this method to send a group of photos or videos as an album.\n   *\n   * **Documents and audio files can be only grouped in an album with messages of the same type**\n   *\n   * If you wish to [specify file options](https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files),\n   * add a `fileOptions` property to the target input in `media`.\n   *\n   * @param  {String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Array} media A JSON-serialized array describing photos and videos to be sent, must include 2–10 items\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, an array of the sent [Messages](https://core.telegram.org/bots/api#message)\n   * is returned.\n   * @see https://core.telegram.org/bots/api#sendmediagroup\n   * @see https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files\n   */\n  sendMediaGroup(chatId, media, options = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n\n    opts.formData = {};\n    const inputMedia = [];\n    let index = 0;\n    for (const input of media) {\n      const payload = Object.assign({}, input);\n      delete payload.media;\n      delete payload.fileOptions;\n      try {\n        const attachName = String(index);\n        const [formData, fileId] = this._formatSendData(attachName, input.media, input.fileOptions);\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          payload.media = `attach://${attachName}`;\n        } else {\n          payload.media = fileId;\n        }\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n      inputMedia.push(payload);\n      index++;\n    }\n    opts.qs.media = stringify(inputMedia);\n\n    return this._request('sendMediaGroup', opts);\n  }\n\n\n  /**\n   * Send location.\n   * Use this method to send point on the map.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendlocation\n   */\n  sendLocation(chatId, latitude, longitude, form = {}) {\n    form.chat_id = chatId;\n    form.latitude = latitude;\n    form.longitude = longitude;\n    return this._request('sendLocation', { form });\n  }\n\n  /**\n   * Use this method to edit live location messages sent by\n   * the bot or via the bot (for inline bots).\n   *\n   *  A location **can be edited until its live_period expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api#stopmessagelivelocation)**\n   *\n   * Note that you must provide one of chat_id, message_id, or\n   * inline_message_id in your request.\n   *\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n   * @see https://core.telegram.org/bots/api#editmessagelivelocation\n   */\n  editMessageLiveLocation(latitude, longitude, form = {}) {\n    form.latitude = latitude;\n    form.longitude = longitude;\n    return this._request('editMessageLiveLocation', { form });\n  }\n\n  /**\n   * Use this method to stop updating a live location message sent by\n   * the bot or via the bot (for inline bots) before live_period expires.\n   *\n   * Note that you must provide one of chat_id, message_id, or\n   * inline_message_id in your request.\n   *\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned.\n   * @see https://core.telegram.org/bots/api#stopmessagelivelocation\n   */\n  stopMessageLiveLocation(form = {}) {\n    return this._request('stopMessageLiveLocation', { form });\n  }\n\n  /**\n   * Send venue.\n   * Use this method to send information about a venue.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Float} latitude Latitude of location\n   * @param  {Float} longitude Longitude of location\n   * @param  {String} title Name of the venue\n   * @param  {String} address Address of the venue\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned.\n   * @see https://core.telegram.org/bots/api#sendvenue\n   */\n  sendVenue(chatId, latitude, longitude, title, address, form = {}) {\n    form.chat_id = chatId;\n    form.latitude = latitude;\n    form.longitude = longitude;\n    form.title = title;\n    form.address = address;\n    return this._request('sendVenue', { form });\n  }\n\n  /**\n   * Send contact.\n   * Use this method to send phone contacts.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} phoneNumber Contact's phone number\n   * @param  {String} firstName Contact's first name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendcontact\n   */\n  sendContact(chatId, phoneNumber, firstName, form = {}) {\n    form.chat_id = chatId;\n    form.phone_number = phoneNumber;\n    form.first_name = firstName;\n    return this._request('sendContact', { form });\n  }\n\n  /**\n   * Send poll.\n   * Use this method to send a native poll.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {String} question Poll question, 1-300 characters\n   * @param  {Array} pollOptions Poll options, between 2-10 options (only 1-100 characters each)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#sendpoll\n   */\n  sendPoll(chatId, question, pollOptions, form = {}) {\n    form.chat_id = chatId;\n    form.question = question;\n    form.options = stringify(pollOptions);\n    return this._request('sendPoll', { form });\n  }\n\n  /**\n   * Send Dice\n   * Use this method to send an animated emoji that will display a random value.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  On success, the sent [Message](https://core.telegram.org/bots/api#message) object is returned\n   * @see https://core.telegram.org/bots/api#senddice\n   */\n  sendDice(chatId, options = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('dice');\n      opts.formData = sendData[0];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendDice', opts);\n  }\n\n\n  /**\n   * Send chat action.\n   *\n   * Use this method when you need to tell the user that something is happening on the bot's side.\n   * **The status is set for 5 seconds or less** (when a message arrives from your bot, Telegram clients clear its typing status).\n   *\n   *  Action `typing` for [text messages](https://core.telegram.org/bots/api#sendmessage),\n   * `upload_photo` for [photos](https://core.telegram.org/bots/api#sendphoto), `record_video` or `upload_video` for [videos](https://core.telegram.org/bots/api#sendvideo),\n   * `record_voice` or `upload_voice` for [voice notes](https://core.telegram.org/bots/api#sendvoice), `upload_document` for [general files](https://core.telegram.org/bots/api#senddocument),\n   * `choose_sticker` for [stickers](https://core.telegram.org/bots/api#sendsticker), `find_location` for [location data](https://core.telegram.org/bots/api#sendlocation),\n   * `record_video_note` or `upload_video_note` for [video notes](https://core.telegram.org/bots/api#sendvideonote).\n   *\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} action Type of action to broadcast.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#sendchataction\n   */\n  sendChatAction(chatId, action, form = {}) {\n    form.chat_id = chatId;\n    form.action = action;\n    return this._request('sendChatAction', { form });\n  }\n\n  /**\n   * Use this method to change the chosen reactions on a message.\n   * - Service messages can't be reacted to.\n   * - Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel.\n   * - In albums, bots must react to the first message.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n   * @param  {Number} messageId  Unique identifier of the target message\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise<Boolean>} True on success\n   * @see https://core.telegram.org/bots/api#setmessagereaction\n   */\n  setMessageReaction(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    if (form.reaction) {\n      form.reaction = stringify(form.reaction);\n    }\n    return this._request('setMessageReaction', { form });\n  }\n\n  /**\n   * Use this method to get a list of profile pictures for a user.\n   * Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object.\n   * This method has an [older, compatible signature][getUserProfilePhotos-v0.25.0]\n   * that is being deprecated.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise}  Returns a [UserProfilePhotos](https://core.telegram.org/bots/api#userprofilephotos) object\n   * @see https://core.telegram.org/bots/api#getuserprofilephotos\n   */\n  getUserProfilePhotos(userId, form = {}) {\n    /* The older method signature was getUserProfilePhotos(userId, offset, limit).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0');\n      form = {\n        offset: arguments[1],\n        limit: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n    form.user_id = userId;\n    return this._request('getUserProfilePhotos', { form });\n  }\n\n  /**\n   * Get file.\n   * Use this method to get basic info about a file and prepare it for downloading.\n   *\n   * Attention: **link will be valid for 1 hour.**\n   *\n   * @param  {String} fileId  File identifier to get info about\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n   * @see https://core.telegram.org/bots/api#getfile\n   */\n  getFile(fileId, form = {}) {\n    form.file_id = fileId;\n    return this._request('getFile', { form });\n  }\n\n  /**\n    * Use this method to ban a user in a group, a supergroup or a channel.\n    * In the case of supergroups and channels, the user will not be able to\n    * return to the chat on their own using invite links, etc., unless unbanned first..\n    *\n    * The **bot must be an administrator in the group, supergroup or a channel** for this to work.\n    *\n    *\n    * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n    * @param  {Number} userId  Unique identifier of the target user\n    * @param  {Object} [options] Additional Telegram query options\n    * @return {Promise} True on success.\n    * @see https://core.telegram.org/bots/api#banchatmember\n    */\n  banChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('banChatMember', { form });\n  }\n\n  /**\n  * Use this method to unban a previously kicked user in a supergroup.\n  * The user will not return to the group automatically, but will be\n  * able to join via link, etc.\n  *\n  * The **bot must be an administrator** in the supergroup or channel for this to work.\n  *\n  * **By default**, this method guarantees that after the call the user is not a member of the chat, but will be able to join it.\n  * So **if the user is a member of the chat they will also be removed from the chat**. If you don't want this, use the parameter *only_if_banned*\n  *\n  * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} userId  Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unbanchatmember\n  */\n  unbanChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('unbanChatMember', { form });\n  }\n\n  /**\n  * Use this method to restrict a user in a supergroup.\n  * The bot **must be an administrator in the supergroup** for this to work\n  * and must have the appropriate admin rights. Pass True for all boolean parameters\n  * to lift restrictions from a user. Returns True on success.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} userId Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#restrictchatmember\n  */\n  restrictChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('restrictChatMember', { form });\n  }\n\n  /**\n   * Use this method to promote or demote a user in a supergroup or a channel.\n   * The bot **must be an administrator** in the chat for this to work\n   * and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success.\n   * @see https://core.telegram.org/bots/api#promotechatmember\n   */\n  promoteChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('promoteChatMember', { form });\n  }\n\n  /**\n   * Use this method to set a custom title for an administrator in a supergroup promoted by the bot.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId Unique identifier of the target user\n   * @param  {String} customTitle New custom title for the administrator; 0-16 characters, emoji are not allowed\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n   */\n  setChatAdministratorCustomTitle(chatId, userId, customTitle, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    form.custom_title = customTitle;\n    return this._request('setChatAdministratorCustomTitle', { form });\n  }\n\n\n  /**\n   * Use this method to ban a channel chat in a supergroup or a channel.\n   *\n   * Until the chat is [unbanned](https://core.telegram.org/bots/api#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of any of their channels.\n   * The bot **must be an administrator in the supergroup or channel** for this to work and must have the appropriate administrator rights\n   *\n   * @param  {Number|String} chatId   Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} senderChatId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success.\n   * @see https://core.telegram.org/bots/api#banchatsenderchat\n   */\n  banChatSenderChat(chatId, senderChatId, form = {}) {\n    form.chat_id = chatId;\n    form.sender_chat_id = senderChatId;\n    return this._request('banChatSenderChat', { form });\n  }\n\n  /**\n  * Use this method to unban a previously banned channel chat in a supergroup or channel.\n  *\n  * The bot **must be an administrator** for this to work and must have the appropriate administrator rights.\n  *\n  * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Number} senderChatId Unique identifier of the target user\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unbanchatsenderchat\n  */\n  unbanChatSenderChat(chatId, senderChatId, form = {}) {\n    form.chat_id = chatId;\n    form.sender_chat_id = senderChatId;\n    return this._request('unbanChatSenderChat', { form });\n  }\n\n  /**\n   * Use this method to set default chat permissions for all members.\n   *\n   * The bot **must be an administrator in the group or a supergroup** for this to\n   * work and **must have the `can_restrict_members` admin rights.**\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Array} chatPermissions New default chat permissions\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatpermissions\n   */\n  setChatPermissions(chatId, chatPermissions, form = {}) {\n    form.chat_id = chatId;\n    form.permissions = stringify(chatPermissions);\n    return this._request('setChatPermissions', { form });\n  }\n\n  /**\n   * Use this method to generate a new primary invite link for a chat. **Any previously generated primary link is revoked**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Exported invite link as String on success.\n   * @see https://core.telegram.org/bots/api#exportchatinvitelink\n   */\n  exportChatInviteLink(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('exportChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to create an additional invite link for a chat.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * The link generated with this method can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api#revokechatinvitelink)\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Object} The new invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#createchatinvitelink\n   */\n  createChatInviteLink(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('createChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to edit a non-primary invite link created by the bot.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} inviteLink Text with the invite link to edit\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#editchatinvitelink\n   */\n  editChatInviteLink(chatId, inviteLink, form = {}) {\n    form.chat_id = chatId;\n    form.invite_link = inviteLink;\n    return this._request('editChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to revoke an invite link created by the bot.\n   * Note: If the primary link is revoked, a new link is automatically generated\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} inviteLink The invite link to revoke\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} The revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api#chatinvitelink) object\n   * @see https://core.telegram.org/bots/api#revokechatinvitelink\n   */\n  revokeChatInviteLink(chatId, inviteLink, form = {}) {\n    form.chat_id = chatId;\n    form.invite_link = inviteLink;\n    return this._request('revokeChatInviteLink', { form });\n  }\n\n  /**\n   * Use this method to approve a chat join request.\n   *\n   * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right.**\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#approvechatjoinrequest\n   */\n  approveChatJoinRequest(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('approveChatJoinRequest', { form });\n  }\n\n  /**\n   * Use this method to decline a chat join request.\n   *\n   * The bot **must be an administrator in the chat** for this to work and **must have the `can_invite_users` administrator right**.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#declinechatjoinrequest\n   */\n  declineChatJoinRequest(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('declineChatJoinRequest', { form });\n  }\n\n  /**\n   * Use this method to set a new profile photo for the chat. **Photos can't be changed for private chats**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {stream.Stream|Buffer} photo A file path or a Stream.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatphoto\n   */\n  setChatPhoto(chatId, photo, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('photo', photo, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.photo = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('setChatPhoto', opts);\n  }\n\n  /**\n  * Use this method to delete a chat photo. **Photos can't be changed for private chats**.\n  *\n  * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#deletechatphoto\n  */\n  deleteChatPhoto(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('deleteChatPhoto', { form });\n  }\n\n  /**\n   * Use this method to change the title of a chat. **Titles can't be changed for private chats**.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} title New chat title, 1-255 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchattitle\n   */\n  setChatTitle(chatId, title, form = {}) {\n    form.chat_id = chatId;\n    form.title = title;\n    return this._request('setChatTitle', { form });\n  }\n\n  /**\n   * Use this method to change the description of a group, a supergroup or a channel.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate admin rights.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} description New chat title, 0-255 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatdescription\n   */\n  setChatDescription(chatId, description, form = {}) {\n    form.chat_id = chatId;\n    form.description = description;\n    return this._request('setChatDescription', { form });\n  }\n\n  /**\n   * Use this method to pin a message in a supergroup.\n   *\n   * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n   * right in a supergroup or `can_edit_messages` administrator right in a channel.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Number} messageId Identifier of a message to pin\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#pinchatmessage\n   */\n  pinChatMessage(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    return this._request('pinChatMessage', { form });\n  }\n\n  /**\n   * Use this method to remove a message from the list of pinned messages in a chat\n   *\n   * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n   * right in a supergroup or `can_edit_messages` administrator right in a channel.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinchatmessage\n   */\n  unpinChatMessage(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unpinChatMessage', { form });\n  }\n\n  /**\n  * Use this method to clear the list of pinned messages in a chat.\n  *\n  * If the chat is not a private chat, the **bot must be an administrator in the chat** for this to work and must have the `can_pin_messages` administrator\n  * right in a supergroup or `can_edit_messages` administrator right in a channel.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#unpinallchatmessages\n  */\n  unpinAllChatMessages(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unpinAllChatMessages', { form });\n  }\n\n  /**\n   * Use this method for your bot to leave a group, supergroup or channel\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#leavechat\n   */\n  leaveChat(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('leaveChat', { form });\n  }\n\n  /**\n   * Use this method to get up to date information about the chat\n   * (current name of the user for one-on-one conversations, current\n   * username of a user, group or channel, etc.).\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`) or channel\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatFullInfo](https://core.telegram.org/bots/api#chatfullinfo) object on success\n   * @see https://core.telegram.org/bots/api#getchat\n   */\n  getChat(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChat', { form });\n  }\n\n  /**\n   * Use this method to get a list of administrators in a chat\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns an Array of [ChatMember](https://core.telegram.org/bots/api#chatmember) objects that contains information about all chat administrators except other bots.\n   * If the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned\n   * @see https://core.telegram.org/bots/api#getchatadministrators\n   */\n  getChatAdministrators(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChatAdministrators', { form });\n  }\n\n  /**\n  * Use this method to get the number of members in a chat.\n  *\n  * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} Int on success\n  * @see https://core.telegram.org/bots/api#getchatmembercount\n  */\n  getChatMemberCount(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getChatMemberCount', { form });\n  }\n\n  /**\n   * Use this method to get information about a member of a chat.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target group or username of the target supergroup\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatMember](https://core.telegram.org/bots/api#chatmember) object on success\n   * @see https://core.telegram.org/bots/api#getchatmember\n   */\n  getChatMember(chatId, userId, form = {}) {\n    form.chat_id = chatId;\n    form.user_id = userId;\n    return this._request('getChatMember', { form });\n  }\n\n  /**\n   * Use this method to set a new group sticker set for a supergroup.\n   *\n   * The bot **must be an administrator in the chat** for this to work and must have the appropriate administrator rights.\n   *\n   * **Note:** Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {String} stickerSetName Name of the sticker set to be set as the group sticker set\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatstickerset\n   */\n  setChatStickerSet(chatId, stickerSetName, form = {}) {\n    form.chat_id = chatId;\n    form.sticker_set_name = stickerSetName;\n    return this._request('setChatStickerSet', { form });\n  }\n\n\n  /**\n   * Use this method to delete a group sticker set from a supergroup.\n   *\n   * Use the field `can_set_sticker_set` optionally returned in [getChat](https://core.telegram.org/bots/api#getchat) requests to check if the bot can use this method.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletechatstickerset\n   */\n  deleteChatStickerSet(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('deleteChatStickerSet', { form });\n  }\n\n  /**\n   * Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects\n   * @see https://core.telegram.org/bots/api#getforumtopiciconstickers\n   */\n  getForumTopicIconStickers(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('getForumTopicIconStickers', { form });\n  }\n\n  /**\n   * Use this method to create a topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n   *\n   * Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api#forumtopic) object.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param  {String} name Topic name, 1-128 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @see https://core.telegram.org/bots/api#createforumtopic\n   */\n  createForumTopic(chatId, name, form = {}) {\n    form.chat_id = chatId;\n    form.name = name;\n    return this._request('createForumTopic', { form });\n  }\n\n  /**\n   * Use this method to edit name and icon of a topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#editforumtopic\n   */\n  editForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('editForumTopic', { form });\n  }\n\n  /**\n   * Use this method to close an open topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#closeforumtopic\n   */\n  closeForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('closeForumTopic', { form });\n  }\n\n  /**\n   * Use this method to reopen a closed topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#reopenforumtopic\n   */\n  reopenForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('reopenForumTopic', { form });\n  }\n\n  /**\n   * Use this method to delete a forum topic along with all its messages in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deleteforumtopic\n   */\n  deleteForumTopic(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('deleteForumTopic', { form });\n  }\n\n  /**\n   * Use this method to clear the list of pinned messages in a forum topic.\n   * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Number} messageThreadId Unique identifier for the target message thread of the forum topic\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinallforumtopicmessages\n   */\n  unpinAllForumTopicMessages(chatId, messageThreadId, form = {}) {\n    form.chat_id = chatId;\n    form.message_thread_id = messageThreadId;\n    return this._request('unpinAllForumTopicMessages', { form });\n  }\n\n  /**\n  * Use this method to edit the name of the 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {String} name New topic name, 1-128 characters\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#editgeneralforumtopic\n  */\n  editGeneralForumTopic(chatId, name, form = {}) {\n    form.chat_id = chatId;\n    form.name = name;\n    return this._request('editGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to close an open 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#closegeneralforumtopic\n  */\n  closeGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('closeGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to reopen a closed 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically unhidden if it was hidden.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#reopengeneralforumtopic\n  */\n  reopenGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('reopenGeneralForumTopic', { form });\n  }\n\n  /**\n  * Use this method to hide the 'General' topic in a forum supergroup chat.\n  * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.\n  * The topic will be automatically closed if it was open.\n  *\n  * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n  * @param {Object} [options] Additional Telegram query options\n  * @return {Promise} True on success\n  * @see https://core.telegram.org/bots/api#hidegeneralforumtopic\n  */\n  hideGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('hideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to unhide the 'General' topic in a forum supergroup chat.\n   * The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unhidegeneralforumtopic\n   */\n  unhideGeneralForumTopic(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unhideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to clear the list of pinned messages in a General forum topic.\n   * The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.\n   *\n   * @param {Number|String} chatId Unique identifier for the target group or username of the target supergroup (in the format @supergroupusername)\n   * @param {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages\n   */\n  unpinAllGeneralForumTopicMessages(chatId, form = {}) {\n    form.chat_id = chatId;\n    return this._request('unhideGeneralForumTopic', { form });\n  }\n\n  /**\n   * Use this method to send answers to callback queries sent from\n   * [inline keyboards](https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating).\n   *\n   * The answer will be displayed to the user as a notification at the top of the chat screen or as an alert.\n   *\n   * This method has **older, compatible signatures ([1][answerCallbackQuery-v0.27.1])([2][answerCallbackQuery-v0.29.0])**\n   * that are being deprecated.\n   *\n   * @param  {String} callbackQueryId Unique identifier for the query to be answered\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#answercallbackquery\n   */\n  answerCallbackQuery(callbackQueryId, form = {}) {\n    /* The older method signature (in/before v0.27.1) was answerCallbackQuery(callbackQueryId, text, showAlert).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library */\n    if (typeof form !== 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1');\n      form = {\n        callback_query_id: arguments[0],\n        text: arguments[1],\n        show_alert: arguments[2],\n      };\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    }\n    /* The older method signature (in/before v0.29.0) was answerCallbackQuery([options]).\n     * We need to ensure backwards-compatibility while maintaining\n     * consistency of the method signatures throughout the library. */\n    if (typeof callbackQueryId === 'object') {\n      /* eslint-disable no-param-reassign, prefer-rest-params */\n      deprecate('The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0');\n      form = callbackQueryId;\n      /* eslint-enable no-param-reassign, prefer-rest-params */\n    } else {\n      form.callback_query_id = callbackQueryId;\n    }\n    return this._request('answerCallbackQuery', { form });\n  }\n\n  /**\n   * Use this method to get the list of boosts added to a chat by a use.\n   * Requires administrator rights in the chat\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {Number} user_id Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns a [UserChatBoosts](https://core.telegram.org/bots/api#userchatboosts) object\n   * @see https://core.telegram.org/bots/api#getuserchatboosts\n   */\n  getUserChatBoosts(chatId, pollId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = pollId;\n    return this._request('getUserChatBoosts', { form });\n  }\n\n  /**\n   * Use this method to get information about the connection of the bot with a business account\n   *\n   * @param  {Number|String} businessConnectionId  Unique identifier for the group/channel\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns [BusinessConnection](https://core.telegram.org/bots/api#businessconnection) object\n   * @see https://core.telegram.org/bots/api#getbusinessconnection\n   */\n  getBusinessConnection(businessConnectionId, form = {}) {\n    form.business_connection_id = businessConnectionId;\n    return this._request('getBusinessConnection', { form });\n  }\n\n  /**\n   * Use this method to change the list of the bot's commands.\n   *\n   * See https://core.telegram.org/bots#commands for more details about bot commands\n   *\n   * @param  {Array} commands  List of bot commands to be set as the list of the [bot's commands](https://core.telegram.org/bots/api#botcommand). At most 100 commands can be specified.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmycommands\n   */\n  setMyCommands(commands, form = {}) {\n    form.commands = stringify(commands);\n\n    if (form.scope) {\n      form.scope = stringify(form.scope);\n    }\n\n    return this._request('setMyCommands', { form });\n  }\n\n  /**\n   * Use this method to delete the list of the bot's commands for the given scope and user language.\n   *\n   *  After deletion, [higher level commands](https://core.telegram.org/bots/api#determining-list-of-commands) will be shown to affected users.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletemycommands\n   */\n  deleteMyCommands(form = {}) {\n    return this._request('deleteMyCommands', { form });\n  }\n\n\n  /**\n   * Use this method to get the current list of the bot's commands for the given scope and user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [BotCommand](https://core.telegram.org/bots/api#botcommand) on success. If commands aren't set, an empty list is returned.\n   * @see https://core.telegram.org/bots/api#getmycommands\n   */\n  getMyCommands(form = {}) {\n    if (form.scope) {\n      form.scope = stringify(form.scope);\n    }\n    return this._request('getMyCommands', { form });\n  }\n\n  /**\n   * Use this method to change the bot's name.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmyname\n   */\n  setMyName(form = {}) {\n    return this._request('setMyName', { form });\n  }\n\n  /**\n   * Use this method to get the current bot name for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [BotName](https://core.telegram.org/bots/api#botname) on success\n   * @see https://core.telegram.org/bots/api#getmyname\n   */\n  getMyName(form = {}) {\n    return this._request('getMyName', { form });\n  }\n\n  /**\n   * Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty.\n   *\n   * Returns True on success.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setmydescription\n   */\n  setMyDescription(form = {}) {\n    return this._request('setMyDescription', { form });\n  }\n\n  /**\n   * Use this method to get the current bot description for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns [BotDescription](https://core.telegram.org/bots/api#botdescription) on success.\n   * @see https://core.telegram.org/bots/api#getmydescription\n   */\n  getMyDescription(form = {}) {\n    return this._request('getMyDescription', { form });\n  }\n\n  /**\n   * Use this method to change the bot's short description, which is shown on the bot's profile page\n   * and is sent together with the link when users share the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns True on success.\n   * @see https://core.telegram.org/bots/api#setmyshortdescription\n   */\n  setMyShortDescription(form = {}) {\n    return this._request('setMyShortDescription', { form });\n  }\n\n  /**\n   * Use this method to get the current bot short description for the given user language.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Returns [BotShortDescription](https://core.telegram.org/bots/api#botshortdescription) on success.\n   * @see https://core.telegram.org/bots/api#getmyshortdescription\n   */\n  getMyShortDescription(form = {}) {\n    return this._request('getMyShortDescription', { form });\n  }\n\n  /**\n   * Use this method to change the bot's menu button in a private chat, or the default menu button.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setchatmenubutton\n   */\n  setChatMenuButton(form = {}) {\n    return this._request('setChatMenuButton', { form });\n  }\n\n  /**\n   * Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [MenuButton](https://core.telegram.org/bots/api#menubutton) on success\n   * @see https://core.telegram.org/bots/api#getchatmenubutton\n   */\n  getChatMenuButton(form = {}) {\n    return this._request('getChatMenuButton', { form });\n  }\n\n  /**\n   * Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels.\n   *\n   * These rights will be suggested to users, but they are are free to modify the list before adding the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#getchatmenubutton\n   */\n  setMyDefaultAdministratorRights(form = {}) {\n    return this._request('setMyDefaultAdministratorRights', { form });\n  }\n\n  /**\n   * Use this method to get the current default administrator rights of the bot.\n   *\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} [ChatAdministratorRights](https://core.telegram.org/bots/api#chatadministratorrights) on success\n   * @see https://core.telegram.org/bots/api#getmydefaultadministratorrights\n   */\n  getMyDefaultAdministratorRights(form = {}) {\n    return this._request('getMyDefaultAdministratorRights', { form });\n  }\n\n  /**\n   * Use this method to edit text or [game](https://core.telegram.org/bots/api#games) messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: that **you must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {String} text  New text of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagetext\n   */\n  editMessageText(text, form = {}) {\n    form.text = text;\n    return this._request('editMessageText', { form });\n  }\n\n  /**\n   * Use this method to edit captions of messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {String} caption  New caption of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagecaption\n   */\n  editMessageCaption(caption, form = {}) {\n    form.caption = caption;\n    return this._request('editMessageCaption', { form });\n  }\n\n  /**\n   * Use this method to edit animation, audio, document, photo, or video messages.\n   *\n   * If a message is a part of a message album, then it can be edited only to a photo or a video.\n   *\n   * Otherwise, message type can be changed arbitrarily. When inline message is edited, new file can't be uploaded.\n   * Use previously uploaded file via its file_id or specify a URL.\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {Object} media  A JSON-serialized object for a new media content of the message\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagemedia\n   */\n  editMessageMedia(media, form = {}) {\n    const regexAttach = /attach:\\/\\/.+/;\n\n    if (typeof media.media === 'string' && regexAttach.test(media.media)) {\n      const opts = {\n        qs: form,\n      };\n\n      opts.formData = {};\n\n      const payload = Object.assign({}, media);\n      delete payload.media;\n\n      try {\n        const attachName = String(0);\n        const [formData] = this._formatSendData(\n          attachName,\n          media.media.replace('attach://', ''),\n          media.fileOptions\n        );\n\n        if (formData) {\n          opts.formData[attachName] = formData[attachName];\n          payload.media = `attach://${attachName}`;\n        } else {\n          throw new errors.FatalError(`Failed to process the replacement action for your ${media.type}`);\n        }\n      } catch (ex) {\n        return Promise.reject(ex);\n      }\n\n      opts.qs.media = stringify(payload);\n\n      return this._request('editMessageMedia', opts);\n    }\n\n    form.media = stringify(media);\n\n    return this._request('editMessageMedia', { form });\n  }\n\n  /**\n   * Use this method to edit only the reply markup of messages sent by the bot or via the bot (for inline bots).\n   *\n   * Note: You **must provide one of chat_id, message_id, or inline_message_id** in your request.\n   *\n   * @param  {Object} replyMarkup  A JSON-serialized object for an inline keyboard.\n   * @param  {Object} [options] Additional Telegram query options (provide either one of chat_id, message_id, or inline_message_id here)\n   * @return {Promise} On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#editmessagetext\n   */\n  editMessageReplyMarkup(replyMarkup, form = {}) {\n    form.reply_markup = replyMarkup;\n    return this._request('editMessageReplyMarkup', { form });\n  }\n\n\n  /**\n   * Use this method to stop a poll which was sent by the bot.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the group/channel\n   * @param  {Number} pollId Identifier of the original message with the poll\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the stopped [Poll](https://core.telegram.org/bots/api#poll) is returned\n   * @see https://core.telegram.org/bots/api#stoppoll\n   */\n  stopPoll(chatId, pollId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = pollId;\n    return this._request('stopPoll', { form });\n  }\n\n  /**\n   * Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS,\n   * or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers.\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String|stream.Stream|Buffer} sticker A file path, Stream or Buffer.\n   * Can also be a `file_id` previously uploaded. Stickers are WebP format files.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendsticker\n   */\n  sendSticker(chatId, sticker, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options\n    };\n    opts.qs.chat_id = chatId;\n    try {\n      const sendData = this._formatSendData('sticker', sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('sendSticker', opts);\n  }\n\n  /**\n   * Use this method to get a sticker set.\n   *\n   * @param  {String} name Name of the sticker set\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [StickerSet](https://core.telegram.org/bots/api#stickerset) object is returned\n   * @see https://core.telegram.org/bots/api#getstickerset\n   */\n  getStickerSet(name, form = {}) {\n    form.name = name;\n    return this._request('getStickerSet', { form });\n  }\n\n  /**\n   * Use this method to get information about custom emoji stickers by their identifiers.\n   *\n   * @param  {Array} custom_emoji_ids List of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} Array of [Sticker](https://core.telegram.org/bots/api#sticker) objects.\n   * @see https://core.telegram.org/bots/api#getcustomemojistickers\n   */\n  getCustomEmojiStickers(customEmojiIds, form = {}) {\n    form.custom_emoji_ids = stringify(customEmojiIds);\n    return this._request('getCustomEmojiStickers', { form });\n  }\n\n  /**\n   * Use this method to upload a file with a sticker for later use in *createNewStickerSet* and *addStickerToSet* methods (can be used multiple\n   * times).\n   *\n   * @param  {Number} userId User identifier of sticker file owner\n   * @param  {String|stream.Stream|Buffer} sticker A file path or a Stream with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. Can also be a `file_id` previously uploaded.\n   * @param {String} stickerFormat Allow values:  `static`, `animated` or `video`\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} On success, a [File](https://core.telegram.org/bots/api#file) object is returned\n   * @see https://core.telegram.org/bots/api#uploadstickerfile\n   */\n  uploadStickerFile(userId, sticker, stickerFormat = 'static', options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.sticker_format = stickerFormat;\n\n    try {\n      const sendData = this._formatSendData('sticker', sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('uploadStickerFile', opts);\n  }\n\n  /**\n   * Use this method to create new sticker set owned by a user.\n   *\n   * The bot will be able to edit the created sticker set.\n   *\n   * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n   *\n   * @param  {Number} userId User identifier of created sticker set owner\n   * @param  {String} name Short name of sticker set, to be used in `t.me/addstickers/` URLs (e.g.,   *\"animals\"*). Can contain only english letters, digits and underscores.\n   *  Must begin with a letter, can't contain consecutive underscores and must end in `\"_by_<bot_username>\"`. `<bot_username>` is case insensitive. 1-64 characters.\n   * @param  {String} title Sticker set title, 1-64 characters\n   * @param  {String|stream.Stream|Buffer} pngSticker Png image with the sticker, must be up to 512 kilobytes in size,\n   *  dimensions must not exceed 512px, and either width or height must be exactly 512px.\n   * @param  {String} emojis One or more emoji corresponding to the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#createnewstickerset\n   */\n  createNewStickerSet(userId, name, title, pngSticker, emojis, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.title = title;\n    opts.qs.emojis = emojis;\n    opts.qs.mask_position = stringify(options.mask_position);\n    try {\n      const sendData = this._formatSendData('png_sticker', pngSticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.png_sticker = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('createNewStickerSet', opts);\n  }\n\n  /**\n   * Use this method to add a new sticker to a set created by the bot.\n   *\n   * You must use exactly one of the fields *png_sticker*, *tgs_sticker*, or *webm_sticker*\n   *\n   * Animated stickers can be added to animated sticker sets and only to them\n   *\n   * Note:\n   * - Emoji sticker sets can have up to 200 sticker\n   * - Static or Animated sticker sets can have up to 120 stickers\n   *\n   * @param  {Number} userId User identifier of sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String|stream.Stream|Buffer} sticker Png image with the sticker (must be up to 512 kilobytes in size,\n   * dimensions must not exceed 512px, and either width or height must be exactly 512px, [TGS animation](https://core.telegram.org/stickers#animated-sticker-requirements)\n   * with the sticker or [WEBM video](https://core.telegram.org/stickers#video-sticker-requirements) with the sticker.\n   * @param  {String} emojis One or more emoji corresponding to the sticker\n   * @param  {String} stickerType Allow values: `png_sticker`, `tgs_sticker`, or `webm_sticker`.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise}  True on success\n   * @see https://core.telegram.org/bots/api#addstickertoset\n   */\n  addStickerToSet(userId, name, sticker, emojis, stickerType = 'png_sticker', options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.emojis = emojis;\n    opts.qs.mask_position = stringify(options.mask_position);\n\n    if (typeof stickerType !== 'string' || ['png_sticker', 'tgs_sticker', 'webm_sticker'].indexOf(stickerType) === -1) {\n      return Promise.reject(new Error('stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker'));\n    }\n\n    try {\n      const sendData = this._formatSendData(stickerType, sticker, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs[stickerType] = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('addStickerToSet', opts);\n  }\n\n  /**\n   * Use this method to move a sticker in a set created by the bot to a specific position.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Number} position New sticker position in the set, zero-based\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickerpositioninset\n   */\n  setStickerPositionInSet(sticker, position, form = {}) {\n    form.sticker = sticker;\n    form.position = position;\n    return this._request('setStickerPositionInSet', { form });\n  }\n\n  /**\n   * Use this method to delete a sticker from a set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletestickerfromset\n   * @todo Add tests for this method!\n   */\n  deleteStickerFromSet(sticker, form = {}) {\n    form.sticker = sticker;\n    return this._request('deleteStickerFromSet', { form });\n  }\n\n  /**\n   * Use this method to replace an existing sticker in a sticker set with a new one\n   *\n   * @param  {Number} user_id User identifier of the sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#replacestickerinset\n   * @todo Add tests for this method!\n   */\n  replaceStickerInSet(userId, name, oldSticker, form = {}) {\n    form.user_id = userId;\n    form.name = name;\n    form.old_sticker = oldSticker;\n    return this._request('deleteStickerFromSet', { form });\n  }\n\n\n  /**\n   * Use this method to change the list of emoji assigned to a regular or custom emoji sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param { Array } emojiList A JSON-serialized list of 1-20 emoji associated with the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickeremojilist\n   */\n  setStickerEmojiList(sticker, emojiList, form = {}) {\n    form.sticker = sticker;\n    form.emoji_list = stringify(emojiList);\n    return this._request('setStickerEmojiList', { form });\n  }\n\n  /**\n   * Use this method to change the list of emoji assigned to a `regular` or `custom emoji` sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickerkeywords\n   */\n  setStickerKeywords(sticker, form = {}) {\n    form.sticker = sticker;\n    if (form.keywords) {\n      form.keywords = stringify(form.keywords);\n    }\n    return this._request('setStickerKeywords', { form });\n  }\n\n  /**\n   * Use this method to change the [mask position](https://core.telegram.org/bots/api#maskposition) of a mask sticker.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} sticker File identifier of the sticker\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickermaskposition\n   */\n  setStickerMaskPosition(sticker, form = {}) {\n    form.sticker = sticker;\n    if (form.mask_position) {\n      form.mask_position = stringify(form.mask_position);\n    }\n    return this._request('setStickerMaskPosition', { form });\n  }\n\n  /**\n   * Use this method to set the title of a created sticker set.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {String} title Sticker set title, 1-64 characters\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickersettitle\n   */\n  setStickerSetTitle(name, title, form = {}) {\n    form.name = name;\n    form.title = title;\n    return this._request('setStickerSetTitle', { form });\n  }\n\n  /**\n   * Use this method to add a thumb to a set created by the bot.\n   *\n   * Animated thumbnails can be set for animated sticker sets only. Video thumbnails can be set only for video sticker sets only\n   *\n   * @param  {Number} userId User identifier of sticker set owner\n   * @param  {String} name Sticker set name\n   * @param  {String|stream.Stream|Buffer} thumbnail A .WEBP or .PNG image with the thumbnail,\n   * must be up to 128 kilobytes in size and have width and height exactly 100px,\n   * a TGS animation with the thumbnail up to 32 kilobytes in size or a WEBM video with the thumbnail up to 32 kilobytes in size.\n   *\n   * Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram\n   * to get a file from the Internet, or upload a new one. Animated sticker set thumbnails can't be uploaded via HTTP URL.\n   * @param  {Object} [options] Additional Telegram query options\n   * @param  {Object} [fileOptions] Optional file related meta-data\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setstickersetthumbnail\n   */\n  setStickerSetThumbnail(userId, name, thumbnail, options = {}, fileOptions = {}) {\n    const opts = {\n      qs: options,\n    };\n    opts.qs.user_id = userId;\n    opts.qs.name = name;\n    opts.qs.mask_position = stringify(options.mask_position);\n    try {\n      const sendData = this._formatSendData('thumbnail', thumbnail, fileOptions);\n      opts.formData = sendData[0];\n      opts.qs.thumbnail = sendData[1];\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n    return this._request('setStickerSetThumbnail', opts);\n  }\n\n\n  /**\n   * Use this method to set the thumbnail of a custom emoji sticker set.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail\n   */\n  setCustomEmojiStickerSetThumbnail(name, form = {}) {\n    form.name = name;\n    return this._request('setCustomEmojiStickerSetThumbnail', { form });\n  }\n\n  /**\n   * Use this method to delete a sticker set that was created by the bot.\n   *\n   * The sticker must belong to a sticker set created by the bot.\n   *\n   * @param  {String} name Sticker set name\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} True on success\n   * @see https://core.telegram.org/bots/api#deletestickerset\n   */\n  deleteStickerSet(name, form = {}) {\n    form.name = name;\n    return this._request('deleteStickerSet', { form });\n  }\n\n  /**\n   * Send answers to an inline query.\n   *\n   * Note: No more than 50 results per query are allowed.\n   *\n   * @param  {String} inlineQueryId Unique identifier of the query\n   * @param  {InlineQueryResult[]} results An array of results for the inline query\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, True is returned\n   * @see https://core.telegram.org/bots/api#answerinlinequery\n   */\n  answerInlineQuery(inlineQueryId, results, form = {}) {\n    form.inline_query_id = inlineQueryId;\n    form.results = stringify(results);\n    return this._request('answerInlineQuery', { form });\n  }\n\n  /**\n   * Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps)\n   * and send a corresponding message on behalf of the user to the chat from which the query originated.\n   *\n   * @param  {String} webAppQueryId Unique identifier for the query to be answered\n   * @param  {InlineQueryResult} result object that represents one result of an inline query\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, a [SentWebAppMessage](https://core.telegram.org/bots/api#sentwebappmessage) object is returned\n   * @see https://core.telegram.org/bots/api#answerwebappquery\n   */\n  answerWebAppQuery(webAppQueryId, result, form = {}) {\n    form.web_app_query_id = webAppQueryId;\n    form.result = stringify(result);\n    return this._request('answerWebAppQuery', { form });\n  }\n\n  /**\n   * Use this method to send an invoice.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} title Product name, 1-32 characters\n   * @param  {String} description Product description, 1-255 characters\n   * @param  {String} payload Bot defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.\n   * @param  {String} providerToken Payments provider token, obtained via `@BotFather`\n   * @param  {String} currency Three-letter ISO 4217 currency code\n   * @param  {Array} prices Breakdown of prices\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendinvoice\n   */\n  sendInvoice(chatId, title, description, payload, providerToken, currency, prices, form = {}) {\n    form.chat_id = chatId;\n    form.title = title;\n    form.description = description;\n    form.payload = payload;\n    form.provider_token = providerToken;\n    form.currency = currency;\n    form.prices = stringify(prices);\n    form.provider_data = stringify(form.provider_data);\n    if (form.suggested_tip_amounts) {\n      form.suggested_tip_amounts = stringify(form.suggested_tip_amounts);\n    }\n    return this._request('sendInvoice', { form });\n  }\n\n  /**\n  * Use this method to create a link for an invoice.\n  *\n  * @param {String} title Product name, 1-32 characters\n  * @param {String} description Product description, 1-255 characters\n  * @param {String} payload Bot defined invoice payload\n  * @param {String} providerToken Payment provider token\n  * @param {String} currency Three-letter ISO 4217 currency code\n  * @param {Array} prices Breakdown of prices\n  * @param {Object} [options] Additional Telegram query options\n  * @returns {Promise} The created invoice link as String on success.\n  * @see https://core.telegram.org/bots/api#createinvoicelink\n  */\n  createInvoiceLink(title, description, payload, providerToken, currency, prices, form = {}) {\n    form.title = title;\n    form.description = description;\n    form.payload = payload;\n    form.provider_token = providerToken;\n    form.currency = currency;\n    form.prices = stringify(prices);\n    return this._request('createInvoiceLink', { form });\n  }\n\n  /**\n  * Use this method to reply to shipping queries.\n  *\n  * If you sent an invoice requesting a shipping address and the parameter is_flexible was specified,\n  * the Bot API will send an [Update](https://core.telegram.org/bots/api#update) with a shipping_query field to the bot\n  *\n  * @param  {String} shippingQueryId  Unique identifier for the query to be answered\n  * @param  {Boolean} ok Specify if delivery of the product is possible\n  * @param  {Object} [options] Additional Telegram query options\n  * @return {Promise} On success, True is returned\n  * @see https://core.telegram.org/bots/api#answershippingquery\n  */\n  answerShippingQuery(shippingQueryId, ok, form = {}) {\n    form.shipping_query_id = shippingQueryId;\n    form.ok = ok;\n    form.shipping_options = stringify(form.shipping_options);\n    return this._request('answerShippingQuery', { form });\n  }\n\n  /**\n   * Use this method to respond to such pre-checkout queries\n   *\n   * Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of\n   * an [Update](https://core.telegram.org/bots/api#update) with the field *pre_checkout_query*.\n   *\n   * **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.\n   *\n   * @param  {String} preCheckoutQueryId  Unique identifier for the query to be answered\n   * @param  {Boolean} ok Specify if every order details are ok\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, True is returned\n   * @see https://core.telegram.org/bots/api#answerprecheckoutquery\n   */\n  answerPreCheckoutQuery(preCheckoutQueryId, ok, form = {}) {\n    form.pre_checkout_query_id = preCheckoutQueryId;\n    form.ok = ok;\n    return this._request('answerPreCheckoutQuery', { form });\n  }\n\n  /**\n   * Use this method to send a game.\n   *\n   * @param  {Number|String} chatId Unique identifier for the target chat or username of the target channel (in the format `@channelusername`)\n   * @param  {String} gameShortName name of the game to be sent. Set up your games via `@BotFather`.\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, the sent [Message](https://core.telegram.org/bots/api#message) is returned\n   * @see https://core.telegram.org/bots/api#sendgame\n   */\n  sendGame(chatId, gameShortName, form = {}) {\n    form.chat_id = chatId;\n    form.game_short_name = gameShortName;\n    return this._request('sendGame', { form });\n  }\n\n  /**\n   * Use this method to set the score of the specified user in a game message.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Number} score New score value, must be non-negative\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api#message) is returned, otherwise True is returned\n   * @see https://core.telegram.org/bots/api#setgamescore\n   */\n  setGameScore(userId, score, form = {}) {\n    form.user_id = userId;\n    form.score = score;\n    return this._request('setGameScore', { form });\n  }\n\n  /**\n   * Use this method to get data for high score tables.\n   *\n   * Will return the score of the specified user and several of their neighbors in a game.\n   *\n   * @param  {Number} userId  Unique identifier of the target user\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise} On success, returns an Array of [GameHighScore](https://core.telegram.org/bots/api#gamehighscore) objects\n   * @see https://core.telegram.org/bots/api#getgamehighscores\n   */\n  getGameHighScores(userId, form = {}) {\n    form.user_id = userId;\n    return this._request('getGameHighScores', { form });\n  }\n\n\n  /**\n * Use this method to delete a message, including service messages, with the following limitations:\n * - A message can only be deleted if it was sent less than 48 hours ago.\n * - A dice message can only be deleted if it was sent more than 24 hours ago.\n * - Bots can delete outgoing messages in groups and supergroups.\n * - Bots can delete incoming messages in groups, supergroups and channels.\n * - Bots granted `can_post_messages` permissions can delete outgoing messages in channels.\n * - If the bot is an administrator of a group, it can delete any message there.\n * - If the bot has `can_delete_messages` permission in a supergroup, it can delete any message there.\n *\n * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n * @param  {Number} messageId  Unique identifier of the target message\n * @param  {Object} [options] Additional Telegram query options\n * @return {Promise} True on success\n * @see https://core.telegram.org/bots/api#deletemessage\n */\n  deleteMessage(chatId, messageId, form = {}) {\n    form.chat_id = chatId;\n    form.message_id = messageId;\n    return this._request('deleteMessage', { form });\n  }\n\n  /**\n   * Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped.\n   *\n   * @param  {Number|String} chatId  Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n   * @param  {Array<Number|String>} messageIds  Identifiers of 1-100 messages to delete. See deleteMessage for limitations on which messages can be deleted\n   * @param  {Object} [options] Additional Telegram query options\n   * @return {Promise<Boolean>} True on success\n   * @see https://core.telegram.org/bots/api#deletemessages\n   */\n  deleteMessages(chatId, messageIds, form = {}) {\n    form.chat_id = chatId;\n    form.message_ids = stringify(messageIds);\n    return this._request('deleteMessages', { form });\n  }\n\n}\n\nmodule.exports = TelegramBot;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNIQUF5QyxJQUFJOztBQUU3QyxlQUFlLG1CQUFPLENBQUMsMEVBQVU7QUFDakMsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLDRGQUFtQjtBQUN0RCxjQUFjLG1CQUFPLENBQUMseUZBQU87QUFDN0IscUJBQXFCLG1CQUFPLENBQUMscUdBQWU7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUZBQTBCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFrQjtBQUNsRCxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywrQ0FBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxnREFBTTtBQUMzQixrQkFBa0IseUdBQTRCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFD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QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcc3JjXFx0ZWxlZ3JhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltc1xucmVxdWlyZSgnYXJyYXkucHJvdG90eXBlLmZpbmRpbmRleCcpLnNoaW0oKTsgLy8gZm9yIE5vZGUuanMgdjAueFxuXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgVGVsZWdyYW1Cb3RXZWJIb29rID0gcmVxdWlyZSgnLi90ZWxlZ3JhbVdlYkhvb2snKTtcbmNvbnN0IFRlbGVncmFtQm90UG9sbGluZyA9IHJlcXVpcmUoJy4vdGVsZWdyYW1Qb2xsaW5nJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuY29uc3QgZmlsZVR5cGUgPSByZXF1aXJlKCdmaWxlLXR5cGUnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCdAY3lwcmVzcy9yZXF1ZXN0LXByb21pc2UnKTtcbmNvbnN0IHN0cmVhbWVkUmVxdWVzdCA9IHJlcXVpcmUoJ0BjeXByZXNzL3JlcXVlc3QnKTtcbmNvbnN0IHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgbWltZSA9IHJlcXVpcmUoJ21pbWUnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHB1bXAgPSByZXF1aXJlKCdwdW1wJyk7XG5jb25zdCBkZXByZWNhdGUgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVwcmVjYXRlO1xuXG5jb25zdCBfbWVzc2FnZVR5cGVzID0gW1xuICAndGV4dCcsXG4gICdhbmltYXRpb24nLFxuICAnYXVkaW8nLFxuICAnY2hhbm5lbF9jaGF0X2NyZWF0ZWQnLFxuICAnY29udGFjdCcsXG4gICdkZWxldGVfY2hhdF9waG90bycsXG4gICdkaWNlJyxcbiAgJ2RvY3VtZW50JyxcbiAgJ2dhbWUnLFxuICAnZ3JvdXBfY2hhdF9jcmVhdGVkJyxcbiAgJ2ludm9pY2UnLFxuICAnbGVmdF9jaGF0X21lbWJlcicsXG4gICdsb2NhdGlvbicsXG4gICdtaWdyYXRlX2Zyb21fY2hhdF9pZCcsXG4gICdtaWdyYXRlX3RvX2NoYXRfaWQnLFxuICAnbmV3X2NoYXRfbWVtYmVycycsXG4gICduZXdfY2hhdF9waG90bycsXG4gICduZXdfY2hhdF90aXRsZScsXG4gICdwYXNzcG9ydF9kYXRhJyxcbiAgJ3Bob3RvJyxcbiAgJ3Bpbm5lZF9tZXNzYWdlJyxcbiAgJ3BvbGwnLFxuICAnc3RpY2tlcicsXG4gICdzdWNjZXNzZnVsX3BheW1lbnQnLFxuICAnc3VwZXJncm91cF9jaGF0X2NyZWF0ZWQnLFxuICAndmlkZW8nLFxuICAndmlkZW9fbm90ZScsXG4gICd2b2ljZScsXG4gICd2aWRlb19jaGF0X3N0YXJ0ZWQnLFxuICAndmlkZW9fY2hhdF9lbmRlZCcsXG4gICd2aWRlb19jaGF0X3BhcnRpY2lwYW50c19pbnZpdGVkJyxcbiAgJ3ZpZGVvX2NoYXRfc2NoZWR1bGVkJyxcbiAgJ21lc3NhZ2VfYXV0b19kZWxldGVfdGltZXJfY2hhbmdlZCcsXG4gICdjaGF0X2ludml0ZV9saW5rJyxcbiAgJ2NoYXRfbWVtYmVyX3VwZGF0ZWQnLFxuICAnd2ViX2FwcF9kYXRhJyxcbiAgJ21lc3NhZ2VfcmVhY3Rpb24nXG5dO1xuXG5jb25zdCBfZGVwcmVjYXRlZE1lc3NhZ2VUeXBlcyA9IFtcbiAgJ25ld19jaGF0X3BhcnRpY2lwYW50JywgJ2xlZnRfY2hhdF9wYXJ0aWNpcGFudCdcbl07XG5cbi8qKlxuICogSlNPTi1zZXJpYWxpemUgZGF0YS4gSWYgdGhlIHByb3ZpZGVkIGRhdGEgaXMgYWxyZWFkeSBhIFN0cmluZyxcbiAqIHJldHVybiBpdCBhcyBpcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHsqfSBkYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG5cblxuY2xhc3MgVGVsZWdyYW1Cb3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogVGhlIGRpZmZlcmVudCBlcnJvcnMgdGhlIGxpYnJhcnkgdXNlcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgZXJyb3JzKCkge1xuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHR5cGVzIG9mIG1lc3NhZ2UgdXBkYXRlcyB0aGUgbGlicmFyeSBoYW5kbGVzLlxuICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0IG1lc3NhZ2VUeXBlcygpIHtcbiAgICByZXR1cm4gX21lc3NhZ2VUeXBlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgW2V2ZW50XShodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNldmVudHMpLlxuICAgKiBUaGlzIGlzIHRoZSB1c3VhbCBgZW1pdHRlci5vbigpYCBtZXRob2QuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI2V2ZW50c3xBdmFpbGFibGUgZXZlbnRzfVxuICAgKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2VtaXR0ZXJfb25fZXZlbnRuYW1lX2xpc3RlbmVyXG4gICAqL1xuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAoX2RlcHJlY2F0ZWRNZXNzYWdlVHlwZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjZXZlbnRzJztcbiAgICAgIGRlcHJlY2F0ZShgRXZlbnRzICR7X2RlcHJlY2F0ZWRNZXNzYWdlVHlwZXMuam9pbignLCcpfSBhcmUgZGVwcmVjYXRlZC4gU2VlIHRoZSB1cGRhdGVkIGxpc3Qgb2YgZXZlbnRzOiAke3VybH1gKTtcbiAgICB9XG4gICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3RoIHJlcXVlc3QgbWV0aG9kIHRvIG9idGFpbiBtZXNzYWdlcyBhcmUgaW1wbGVtZW50ZWQuIFRvIHVzZSBzdGFuZGFyZCBwb2xsaW5nLCBzZXQgYHBvbGxpbmc6IHRydWVgXG4gICAqIG9uIGBvcHRpb25zYC4gTm90aWNlIHRoYXQgW3dlYkhvb2tdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0d2ViaG9vaykgd2lsbCBuZWVkIGEgU1NMIGNlcnRpZmljYXRlLlxuICAgKiBFbWl0cyBgbWVzc2FnZWAgd2hlbiBhIG1lc3NhZ2UgYXJyaXZlcy5cbiAgICpcbiAgICogQGNsYXNzIFRlbGVncmFtQm90XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gQm90IFRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gW29wdGlvbnMucG9sbGluZz1mYWxzZV0gU2V0IHRydWUgdG8gZW5hYmxlIHBvbGxpbmcgb3Igc2V0IG9wdGlvbnMuXG4gICAqICBJZiBhIFdlYkhvb2sgaGFzIGJlZW4gc2V0LCBpdCB3aWxsIGJlIGRlbGV0ZWQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5wb2xsaW5nLnRpbWVvdXQ9MTBdICpEZXByZWNhdGVkLiBVc2UgYG9wdGlvbnMucG9sbGluZy5wYXJhbXNgIGluc3RlYWQqLlxuICAgKiAgVGltZW91dCBpbiBzZWNvbmRzIGZvciBsb25nIHBvbGxpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGVzdEVudmlyb25tZW50PWZhbHNlXSBTZXQgdHJ1ZSB0byAgd29yayB3aXRoIHRlc3QgZW52aXJvbWVudC5cbiAgICogV2hlbiB3b3JraW5nIHdpdGggdGhlIHRlc3QgZW52aXJvbm1lbnQsIHlvdSBtYXkgdXNlIEhUVFAgbGlua3Mgd2l0aG91dCBUTFMgdG8gdGVzdCB5b3VyIFdlYiBBcHAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucG9sbGluZy5pbnRlcnZhbD0zMDBdIEludGVydmFsIGJldHdlZW4gcmVxdWVzdHMgaW4gbWlsaXNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wb2xsaW5nLmF1dG9TdGFydD10cnVlXSBTdGFydCBwb2xsaW5nIGltbWVkaWF0ZWx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb2xsaW5nLnBhcmFtc10gUGFyYW1ldGVycyB0byBiZSB1c2VkIGluIHBvbGxpbmcgQVBJIHJlcXVlc3RzLlxuICAgKiAgU2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dXBkYXRlcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5wb2xsaW5nLnBhcmFtcy50aW1lb3V0PTEwXSBUaW1lb3V0IGluIHNlY29uZHMgZm9yIGxvbmcgcG9sbGluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gW29wdGlvbnMud2ViSG9vaz1mYWxzZV0gU2V0IHRydWUgdG8gZW5hYmxlIFdlYkhvb2sgb3Igc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndlYkhvb2suaG9zdD1cIjAuMC4wLjBcIl0gSG9zdCB0byBiaW5kIHRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53ZWJIb29rLnBvcnQ9ODQ0M10gUG9ydCB0byBiaW5kIHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLmtleV0gUGF0aCB0byBmaWxlIHdpdGggUEVNIHByaXZhdGUga2V5IGZvciB3ZWJIb29rIHNlcnZlci5cbiAgICogIFRoZSBmaWxlIGlzIHJlYWQgKipzeW5jaHJvbm91c2x5KiohXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53ZWJIb29rLmNlcnRdIFBhdGggdG8gZmlsZSB3aXRoIFBFTSBjZXJ0aWZpY2F0ZSAocHVibGljKSBmb3Igd2ViSG9vayBzZXJ2ZXIuXG4gICAqICBUaGUgZmlsZSBpcyByZWFkICoqc3luY2hyb25vdXNseSoqIVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5wZnhdIFBhdGggdG8gZmlsZSB3aXRoIFBGWCBwcml2YXRlIGtleSBhbmQgY2VydGlmaWNhdGUgY2hhaW4gZm9yIHdlYkhvb2sgc2VydmVyLlxuICAgKiAgVGhlIGZpbGUgaXMgcmVhZCAqKnN5bmNocm9ub3VzbHkqKiFcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53ZWJIb29rLmF1dG9PcGVuPXRydWVdIE9wZW4gd2ViSG9vayBpbW1lZGlhdGVseVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud2ViSG9vay5odHRwc10gT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gYGh0dHBzLmNyZWF0ZVNlcnZlcigpYC5cbiAgICogIE5vdGUgdGhhdCBgb3B0aW9ucy53ZWJIb29rLmtleWAsIGBvcHRpb25zLndlYkhvb2suY2VydGAgYW5kIGBvcHRpb25zLndlYkhvb2sucGZ4YCwgaWYgcHJvdmlkZWQsIHdpbGwgYmVcbiAgICogIHVzZWQgdG8gb3ZlcnJpZGUgYGtleWAsIGBjZXJ0YCBhbmQgYHBmeGAgaW4gdGhpcyBvYmplY3QsIHJlc3BlY3RpdmVseS5cbiAgICogIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHBzLmh0bWwjaHR0cHNfaHR0cHNfY3JlYXRlc2VydmVyX29wdGlvbnNfcmVxdWVzdGxpc3RlbmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2ViSG9vay5oZWFsdGhFbmRwb2ludD1cIi9oZWFsdGh6XCJdIEFuIGVuZHBvaW50IGZvciBoZWFsdGggY2hlY2tzIHRoYXQgYWx3YXlzIHJlc3BvbmRzIHdpdGggMjAwIE9LXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25seUZpcnN0TWF0Y2g9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHN0b3AgYWZ0ZXIgZmlyc3QgbWF0Y2guIE90aGVyd2lzZSwgYWxsIHJlZ2V4cHMgYXJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5yZXF1ZXN0XSBPcHRpb25zIHdoaWNoIHdpbGwgYmUgYWRkZWQgZm9yIGFsbCByZXF1ZXN0cyB0byB0ZWxlZ3JhbSBhcGkuXG4gICAqICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdCNyZXF1ZXN0b3B0aW9ucy1jYWxsYmFjayBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJhc2VBcGlVcmw9XCJodHRwczovL2FwaS50ZWxlZ3JhbS5vcmdcIl0gQVBJIEJhc2UgVVJsOyB1c2VmdWwgZm9yIHByb3h5aW5nIGFuZCB0ZXN0aW5nXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmlsZXBhdGg9dHJ1ZV0gQWxsb3cgcGFzc2luZyBmaWxlLXBhdGhzIGFzIGFyZ3VtZW50cyB3aGVuIHNlbmRpbmcgZmlsZXMsXG4gICAqICBzdWNoIGFzIHBob3RvcyB1c2luZyBgVGVsZWdyYW1Cb3Qjc2VuZFBob3RvKClgLiBTZWUgW3VzYWdlIGluZm9ybWF0aW9uXVt1c2FnZS1zZW5kaW5nLWZpbGVzLXBlcmZvcm1hbmNlXVxuICAgKiAgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyBvcHRpb24gYW5kIGl0cyBjb25zZXF1ZW5jZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmFkUmVqZWN0aW9uPWZhbHNlXSBTZXQgdG8gYHRydWVgXG4gICAqICAqKmlmIGFuZCBvbmx5IGlmKiogdGhlIE5vZGUuanMgdmVyc2lvbiB5b3UncmUgdXNpbmcgdGVybWluYXRlcyB0aGVcbiAgICogIHByb2Nlc3Mgb24gdW5oYW5kbGVkIHJlamVjdGlvbnMuIFRoaXMgb3B0aW9uIGlzIG9ubHkgZm9yXG4gICAqICAqZm9yd2FyZC1jb21wYXRpYmlsaXR5IHB1cnBvc2VzKi5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2tlbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMucG9sbGluZyA9ICh0eXBlb2Ygb3B0aW9ucy5wb2xsaW5nID09PSAndW5kZWZpbmVkJykgPyBmYWxzZSA6IG9wdGlvbnMucG9sbGluZztcbiAgICB0aGlzLm9wdGlvbnMud2ViSG9vayA9ICh0eXBlb2Ygb3B0aW9ucy53ZWJIb29rID09PSAndW5kZWZpbmVkJykgPyBmYWxzZSA6IG9wdGlvbnMud2ViSG9vaztcbiAgICB0aGlzLm9wdGlvbnMuYmFzZUFwaVVybCA9IG9wdGlvbnMuYmFzZUFwaVVybCB8fCAnaHR0cHM6Ly9hcGkudGVsZWdyYW0ub3JnJztcbiAgICB0aGlzLm9wdGlvbnMuZmlsZXBhdGggPSAodHlwZW9mIG9wdGlvbnMuZmlsZXBhdGggPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBvcHRpb25zLmZpbGVwYXRoO1xuICAgIHRoaXMub3B0aW9ucy5iYWRSZWplY3Rpb24gPSAodHlwZW9mIG9wdGlvbnMuYmFkUmVqZWN0aW9uID09PSAndW5kZWZpbmVkJykgPyBmYWxzZSA6IG9wdGlvbnMuYmFkUmVqZWN0aW9uO1xuICAgIHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLl9yZXBseUxpc3RlbmVySWQgPSAwO1xuICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcG9sbGluZyA9IG51bGw7XG4gICAgdGhpcy5fd2ViSG9vayA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5wb2xsaW5nKSB7XG4gICAgICBjb25zdCBhdXRvU3RhcnQgPSBvcHRpb25zLnBvbGxpbmcuYXV0b1N0YXJ0O1xuICAgICAgaWYgKHR5cGVvZiBhdXRvU3RhcnQgPT09ICd1bmRlZmluZWQnIHx8IGF1dG9TdGFydCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndlYkhvb2spIHtcbiAgICAgIGNvbnN0IGF1dG9PcGVuID0gb3B0aW9ucy53ZWJIb29rLmF1dG9PcGVuO1xuICAgICAgaWYgKHR5cGVvZiBhdXRvT3BlbiA9PT0gJ3VuZGVmaW5lZCcgfHwgYXV0b09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5vcGVuV2ViSG9vaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdXJsIHdpdGggYm90IHRva2VuIGFuZCBwcm92aWRlZCBwYXRoL21ldGhvZCB5b3Ugd2FudCB0byBiZSBnb3QvZXhlY3V0ZWQgYnkgYm90XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHVybFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWFraW5nLXJlcXVlc3RzXG4gICAqL1xuICBfYnVpbGRVUkwoX3BhdGgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLmJhc2VBcGlVcmx9L2JvdCR7dGhpcy50b2tlbn0ke3RoaXMub3B0aW9ucy50ZXN0RW52aXJvbm1lbnQgPyAnL3Rlc3QnIDogJyd9LyR7X3BhdGh9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggJ3JlcGx5X21hcmt1cCcgcGFyYW1ldGVyIGJ5IG1ha2luZyBpdCBKU09OLXNlcmlhbGl6ZWQsIGFzXG4gICAqIHJlcXVpcmVkIGJ5IHRoZSBUZWxlZ3JhbSBCb3QgQVBJXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0OyBlaXRoZXIgJ2Zvcm0nIG9yICdxcydcbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlXG4gICAqL1xuICBfZml4UmVwbHlNYXJrdXAob2JqKSB7XG4gICAgY29uc3QgcmVwbHlNYXJrdXAgPSBvYmoucmVwbHlfbWFya3VwO1xuICAgIGlmIChyZXBseU1hcmt1cCAmJiB0eXBlb2YgcmVwbHlNYXJrdXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvYmoucmVwbHlfbWFya3VwID0gc3RyaW5naWZ5KHJlcGx5TWFya3VwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRml4ICdlbnRpdGllcycgb3IgJ2NhcHRpb25fZW50aXRpZXMnIG9yICdleHBsYW5hdGlvbl9lbnRpdGllcycgcGFyYW1ldGVyIGJ5IG1ha2luZyBpdCBKU09OLXNlcmlhbGl6ZWQsIGFzXG4gICAqIHJlcXVpcmVkIGJ5IHRoZSBUZWxlZ3JhbSBCb3QgQVBJXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0O1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kcG9sbFxuICAgKi9cbiAgX2ZpeEVudGl0aWVzRmllbGQob2JqKSB7XG4gICAgY29uc3QgZW50aXRpZXMgPSBvYmouZW50aXRpZXM7XG4gICAgY29uc3QgY2FwdGlvbkVudGl0aWVzID0gb2JqLmNhcHRpb25fZW50aXRpZXM7XG4gICAgY29uc3QgZXhwbGFuYXRpb25FbnRpdGllcyA9IG9iai5leHBsYW5hdGlvbl9lbnRpdGllcztcbiAgICBpZiAoZW50aXRpZXMgJiYgdHlwZW9mIGVudGl0aWVzICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqLmVudGl0aWVzID0gc3RyaW5naWZ5KGVudGl0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FwdGlvbkVudGl0aWVzICYmIHR5cGVvZiBjYXB0aW9uRW50aXRpZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvYmouY2FwdGlvbl9lbnRpdGllcyA9IHN0cmluZ2lmeShjYXB0aW9uRW50aXRpZXMpO1xuICAgIH1cblxuICAgIGlmIChleHBsYW5hdGlvbkVudGl0aWVzICYmIHR5cGVvZiBleHBsYW5hdGlvbkVudGl0aWVzICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqLmV4cGxhbmF0aW9uX2VudGl0aWVzID0gc3RyaW5naWZ5KGV4cGxhbmF0aW9uRW50aXRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIF9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpIHtcbiAgICBpZiAob3B0aW9ucy50aHVtYikge1xuICAgICAgaWYgKG9wdHMuZm9ybURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRhY2hOYW1lID0gJ3Bob3RvJztcbiAgICAgIGNvbnN0IFtmb3JtRGF0YV0gPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShhdHRhY2hOYW1lLCBvcHRpb25zLnRodW1iLnJlcGxhY2UoJ2F0dGFjaDovLycsICcnKSk7XG5cbiAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICBvcHRzLmZvcm1EYXRhW2F0dGFjaE5hbWVdID0gZm9ybURhdGFbYXR0YWNoTmFtZV07XG4gICAgICAgIG9wdHMucXMudGh1bWJuYWlsID0gYGF0dGFjaDovLyR7YXR0YWNoTmFtZX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggJ3JlcGx5X3BhcmFtZXRlcnMnIHBhcmFtZXRlciBieSBtYWtpbmcgaXQgSlNPTi1zZXJpYWxpemVkLCBhc1xuICAgKiByZXF1aXJlZCBieSB0aGUgVGVsZWdyYW0gQm90IEFQSVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdDsgZWl0aGVyICdmb3JtJyBvciAncXMnXG4gICAqIEBwcml2YXRlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbWVzc2FnZVxuICAgKi9cbiAgX2ZpeFJlcGx5UGFyYW1ldGVycyhvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCdyZXBseV9wYXJhbWV0ZXJzJykgJiYgdHlwZW9mIG9iai5yZXBseV9wYXJhbWV0ZXJzICE9PSAnc3RyaW5nJykge1xuICAgICAgb2JqLnJlcGx5X3BhcmFtZXRlcnMgPSBzdHJpbmdpZnkob2JqLnJlcGx5X3BhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHJlcXVlc3QgYWdhaW5zdCB0aGUgQVBJXG4gICAqIEBwYXJhbSAge1N0cmluZ30gX3BhdGggQVBJIGVuZHBvaW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBfcmVxdWVzdChfcGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnRva2VuKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9ycy5GYXRhbEVycm9yKCdUZWxlZ3JhbSBCb3QgVG9rZW4gbm90IHByb3ZpZGVkIScpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3QpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnJlcXVlc3QpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcm0pIHtcbiAgICAgIHRoaXMuX2ZpeFJlcGx5TWFya3VwKG9wdGlvbnMuZm9ybSk7XG4gICAgICB0aGlzLl9maXhFbnRpdGllc0ZpZWxkKG9wdGlvbnMuZm9ybSk7XG4gICAgICB0aGlzLl9maXhSZXBseVBhcmFtZXRlcnMob3B0aW9ucy5mb3JtKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucXMpIHtcbiAgICAgIHRoaXMuX2ZpeFJlcGx5TWFya3VwKG9wdGlvbnMucXMpO1xuICAgICAgdGhpcy5fZml4UmVwbHlQYXJhbWV0ZXJzKG9wdGlvbnMucXMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgIG9wdGlvbnMudXJsID0gdGhpcy5fYnVpbGRVUkwoX3BhdGgpO1xuICAgIG9wdGlvbnMuc2ltcGxlID0gZmFsc2U7XG4gICAgb3B0aW9ucy5yZXNvbHZlV2l0aEZ1bGxSZXNwb25zZSA9IHRydWU7XG4gICAgb3B0aW9ucy5mb3JldmVyID0gdHJ1ZTtcbiAgICBkZWJ1ZygnSFRUUCByZXF1ZXN0OiAlaicsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXF1ZXN0KG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNwID0+IHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IHJlc3AuYm9keSA9IEpTT04ucGFyc2UocmVzcC5ib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QYXJzZUVycm9yKGBFcnJvciBwYXJzaW5nIHJlc3BvbnNlOiAke3Jlc3AuYm9keX1gLCByZXNwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLm9rKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UZWxlZ3JhbUVycm9yKGAke2RhdGEuZXJyb3JfY29kZX0gJHtkYXRhLmRlc2NyaXB0aW9ufWAsIHJlc3ApO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAvLyBUT0RPOiB3aHkgY2FuJ3Qgd2UgZG8gYGVycm9yIGluc3RhbmNlb2YgZXJyb3JzLkJhc2VFcnJvcmA/XG4gICAgICAgIGlmIChlcnJvci5yZXNwb25zZSkgdGhyb3cgZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuRmF0YWxFcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgZGF0YSB0byBiZSB1cGxvYWRlZDsgaGFuZGxlcyBmaWxlIHBhdGhzLCBzdHJlYW1zIGFuZCBidWZmZXJzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGRhdGFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBmaWxlT3B0aW9ucyBGaWxlIG9wdGlvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZmlsZU9wdGlvbnMuZmlsZW5hbWVdIEZpbGUgbmFtZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmaWxlT3B0aW9ucy5jb250ZW50VHlwZV0gQ29udGVudCB0eXBlIChpLmUuIE1JTUUpXG4gICAqIEByZXR1cm4ge0FycmF5fSBmb3JtYXR0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBmb3JtYXR0ZWRbMF0gZm9ybURhdGFcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWRbMV0gZmlsZUlkXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgQnVmZmVyIGZpbGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKiBAc2VlIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZmlsZS10eXBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9ybWF0U2VuZERhdGEodHlwZSwgZGF0YSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlcHJlY2F0aW9uTWVzc2FnZSA9XG4gICAgICAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXMnICtcbiAgICAgICcgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHNlbmRpbmcgZmlsZXMgaGFzIGJlZW4gaW1wcm92ZWQgYW5kJyArXG4gICAgICAnIG9uIGhvdyB0byBkaXNhYmxlIHRoaXMgZGVwcmVjYXRpb24gbWVzc2FnZSBhbHRvZ2V0aGVyLic7XG4gICAgbGV0IGZpbGVkYXRhID0gZGF0YTtcbiAgICBsZXQgZmlsZW5hbWUgPSBmaWxlT3B0aW9ucy5maWxlbmFtZTtcbiAgICBsZXQgY29udGVudFR5cGUgPSBmaWxlT3B0aW9ucy5jb250ZW50VHlwZTtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlN0cmVhbSkge1xuICAgICAgaWYgKCFmaWxlbmFtZSAmJiBkYXRhLnBhdGgpIHtcbiAgICAgICAgLy8gV2lsbCBiZSAnbnVsbCcgaWYgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsICdkYXRhLnBhdGgnID09PSAnLz9pZD0xMjMnIGZyb20gJ3JlcXVlc3QoXCJodHRwczovL2V4YW1wbGUuY29tLz9pZD0xMjNcIiknXG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5wYXJzZShwYXRoLmJhc2VuYW1lKGRhdGEucGF0aC50b1N0cmluZygpKSk7XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IHFzLnVuZXNjYXBlKHVybC5wYXRobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCFmaWxlbmFtZSAmJiAhcHJvY2Vzcy5lbnYuTlRCQV9GSVhfMzUwKSB7XG4gICAgICAgIGRlcHJlY2F0ZShgQnVmZmVycyB3aWxsIGhhdmUgdGhlaXIgZmlsZW5hbWVzIGRlZmF1bHQgdG8gXCJmaWxlbmFtZVwiIGluc3RlYWQgb2YgXCJkYXRhXCIuICR7ZGVwcmVjYXRpb25NZXNzYWdlfWApO1xuICAgICAgICBmaWxlbmFtZSA9ICdkYXRhJztcbiAgICAgIH1cbiAgICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgY29uc3QgZmlsZXR5cGUgPSBmaWxlVHlwZShkYXRhKTtcbiAgICAgICAgaWYgKGZpbGV0eXBlKSB7XG4gICAgICAgICAgY29udGVudFR5cGUgPSBmaWxldHlwZS5taW1lO1xuICAgICAgICAgIGNvbnN0IGV4dCA9IGZpbGV0eXBlLmV4dDtcbiAgICAgICAgICBpZiAoZXh0ICYmICFwcm9jZXNzLmVudi5OVEJBX0ZJWF8zNTApIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gYCR7ZmlsZW5hbWV9LiR7ZXh0fWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFwcm9jZXNzLmVudi5OVEJBX0ZJWF8zNTApIHtcbiAgICAgICAgICBkZXByZWNhdGUoYEFuIGVycm9yIHdpbGwgbm8gbG9uZ2VyIGJlIHRocm93biBpZiBmaWxlLXR5cGUgb2YgYnVmZmVyIGNvdWxkIG5vdCBiZSBkZXRlY3RlZC4gJHtkZXByZWNhdGlvbk1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5GYXRhbEVycm9yKCdVbnN1cHBvcnRlZCBCdWZmZXIgZmlsZS10eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsZXBhdGggJiYgZnMuZXhpc3RzU3luYyhkYXRhKSkge1xuICAgICAgICBmaWxlZGF0YSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZGF0YSk7XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZGF0YV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbnVsbCwgZGF0YV07XG4gICAgfVxuXG4gICAgZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCAnZmlsZW5hbWUnO1xuICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgbWltZS5sb29rdXAoZmlsZW5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OVEJBX0ZJWF8zNTApIHtcbiAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHJlY2F0ZShgSW4gdGhlIGZ1dHVyZSwgY29udGVudC10eXBlIG9mIGZpbGVzIHlvdSBzZW5kIHdpbGwgZGVmYXVsdCB0byBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLiAke2RlcHJlY2F0aW9uTWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBBZGQgbWlzc2luZyBmaWxlIGV4dGVuc2lvbi5cblxuICAgIHJldHVybiBbe1xuICAgICAgW3R5cGVdOiB7XG4gICAgICAgIHZhbHVlOiBmaWxlZGF0YSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LCBudWxsXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwb2xsaW5nLlxuICAgKiBSZWplY3RzIHJldHVybmVkIHByb21pc2UgaWYgYSBXZWJIb29rIGlzIGJlaW5nIHVzZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMucmVzdGFydD10cnVlXSBDb25zZWN1dGl2ZSBjYWxscyB0byB0aGlzIG1ldGhvZCBjYXVzZXMgcG9sbGluZyB0byBiZSByZXN0YXJ0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXJ0UG9sbGluZyhvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5oYXNPcGVuV2ViSG9vaygpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9ycy5GYXRhbEVycm9yKCdQb2xsaW5nIGFuZCBXZWJIb29rIGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKSk7XG4gICAgfVxuICAgIG9wdGlvbnMucmVzdGFydCA9IHR5cGVvZiBvcHRpb25zLnJlc3RhcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMucmVzdGFydDtcbiAgICBpZiAoIXRoaXMuX3BvbGxpbmcpIHtcbiAgICAgIHRoaXMuX3BvbGxpbmcgPSBuZXcgVGVsZWdyYW1Cb3RQb2xsaW5nKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9sbGluZy5zdGFydChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBvZiBgVGVsZWdyYW1Cb3Qjc3RhcnRQb2xsaW5nKClgLiBUaGlzIGlzICoqZGVwcmVjYXRlZCoqLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaW5pdFBvbGxpbmcoKSB7XG4gICAgZGVwcmVjYXRlKCdUZWxlZ3JhbUJvdCNpbml0UG9sbGluZygpIGlzIGRlcHJlY2F0ZWQuIFVzZSBUZWxlZ3JhbUJvdCNzdGFydFBvbGxpbmcoKSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHBvbGxpbmcgYWZ0ZXIgdGhlIGxhc3QgcG9sbGluZyByZXF1ZXN0IHJlc29sdmVzLlxuICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHBvbGxpbmcgaXMgYWxyZWFkeSBzdG9wcGVkLlxuICAgKiBSZXR1cm5pbmcgdGhlIHByb21pc2Ugb2YgdGhlIGxhc3QgcG9sbGluZyByZXF1ZXN0IGlzICoqZGVwcmVjYXRlZCoqLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbF0gQ2FuY2VsIGN1cnJlbnQgcmVxdWVzdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gUmVhc29uIGZvciBzdG9wcGluZyBwb2xsaW5nXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBzdG9wUG9sbGluZyhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl9wb2xsaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb2xsaW5nLnN0b3Aob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxpbmsgZm9yIGZpbGUuXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgbGluayBmb3IgZmlsZSBmb3Igc3Vic2VxdWVudCB1c2UuXG4gICAqIEF0dGVudGlvbjogbGluayB3aWxsIGJlIHZhbGlkIGZvciAxIGhvdXIuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSAoZ2V0RmlsZSlbI2dldGZpbGVmaWxlaWRdIG1ldGhvZCxcbiAgICogd2hpY2ggcmV0dXJucyBqdXN0IHBhdGggdG8gZmlsZSBvbiByZW1vdGUgc2VydmVyICh5b3Ugd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGJ1aWxkIGZ1bGwgdXJpIGFmdGVyIHRoYXQpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHdpbGwgaGF2ZSAgKmZpbGVVUkkqIGluIHJlc29sdmUgY2FsbGJhY2tcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGZpbGVcbiAgICovXG4gIGdldEZpbGVMaW5rKGZpbGVJZCwgZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsZShmaWxlSWQsIGZvcm0pXG4gICAgICAudGhlbihyZXNwID0+IGAke3RoaXMub3B0aW9ucy5iYXNlQXBpVXJsfS9maWxlL2JvdCR7dGhpcy50b2tlbn0vJHtyZXNwLmZpbGVfcGF0aH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByZWFkYWJsZSBzdHJlYW0gZm9yIGZpbGUuXG4gICAqXG4gICAqIGBmaWxlU3RyZWFtLnBhdGhgIGlzIHRoZSBzcGVjaWZpZWQgZmlsZSBJRCBpLmUuIGBmaWxlSWRgLlxuICAgKiBgZmlsZVN0cmVhbWAgZW1pdHMgZXZlbnQgYGluZm9gIHBhc3NpbmcgYSBzaW5nbGUgYXJndW1lbnQgaS5lLlxuICAgKiBgaW5mb2Agd2l0aCB0aGUgaW50ZXJmYWNlIGB7IHVyaSB9YCB3aGVyZSBgdXJpYCBpcyB0aGUgVVJJIG9mIHRoZVxuICAgKiBmaWxlIG9uIFRlbGVncmFtIHNlcnZlcnMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSBbZ2V0RmlsZUxpbmtdKCNUZWxlZ3JhbUJvdCtnZXRGaWxlTGluaykgbWV0aG9kLFxuICAgKiB3aGljaCByZXR1cm5zIHRoZSBmdWxsIFVSSSB0byB0aGUgZmlsZSBvbiByZW1vdGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCBGaWxlIGlkZW50aWZpZXIgdG8gZ2V0IGluZm8gYWJvdXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmVhbS5SZWFkYWJsZX0gZmlsZVN0cmVhbVxuICAgKi9cbiAgZ2V0RmlsZVN0cmVhbShmaWxlSWQsIGZvcm0gPSB7fSkge1xuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKCk7XG4gICAgZmlsZVN0cmVhbS5wYXRoID0gZmlsZUlkO1xuICAgIHRoaXMuZ2V0RmlsZUxpbmsoZmlsZUlkLCBmb3JtKVxuICAgICAgLnRoZW4oKGZpbGVVUkkpID0+IHtcbiAgICAgICAgZmlsZVN0cmVhbS5lbWl0KCdpbmZvJywge1xuICAgICAgICAgIHVyaTogZmlsZVVSSSxcbiAgICAgICAgfSk7XG4gICAgICAgIHB1bXAoc3RyZWFtZWRSZXF1ZXN0KE9iamVjdC5hc3NpZ24oeyB1cmk6IGZpbGVVUkkgfSwgdGhpcy5vcHRpb25zLnJlcXVlc3QpKSwgZmlsZVN0cmVhbSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBmaWxlU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIGZpbGVTdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWRzIGZpbGUgaW4gdGhlIHNwZWNpZmllZCBmb2xkZXIuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGEgc3VnYXIgZXh0ZW5zaW9uIG9mIHRoZSBbZ2V0RmlsZVN0cmVhbV0oI1RlbGVncmFtQm90K2dldEZpbGVTdHJlYW0pIG1ldGhvZCxcbiAgICogd2hpY2ggcmV0dXJucyBhIHJlYWRhYmxlIGZpbGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVJZCAgRmlsZSBpZGVudGlmaWVyIHRvIGdldCBpbmZvIGFib3V0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gZG93bmxvYWREaXIgQWJzb2x1dGUgcGF0aCB0byB0aGUgZm9sZGVyIGluIHdoaWNoIGZpbGUgd2lsbCBiZSBzYXZlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSwgd2hpY2ggd2lsbCBoYXZlICpmaWxlUGF0aCogb2YgZG93bmxvYWRlZCBmaWxlIGluIHJlc29sdmUgY2FsbGJhY2tcbiAgICovXG4gIGRvd25sb2FkRmlsZShmaWxlSWQsIGRvd25sb2FkRGlyLCBmb3JtID0ge30pIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoYSwgYikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IGE7XG4gICAgICByZWplY3QgPSBiO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSB0aGlzLmdldEZpbGVTdHJlYW0oZmlsZUlkLCBmb3JtKTtcbiAgICBmaWxlU3RyZWFtLm9uKCdpbmZvJywgKGluZm8pID0+IHtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gaW5mby51cmkuc2xpY2UoaW5mby51cmkubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgLy8gVE9ETzogRW5zdXJlIGZpbGVOYW1lIGRvZXNuJ3QgY29udGFpbnMgc2xhc2hlc1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZG93bmxvYWREaXIsIGZpbGVOYW1lKTtcbiAgICAgIHB1bXAoZmlsZVN0cmVhbSwgZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7IHJldHVybiByZWplY3QoZXJyb3IpOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVQYXRoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZpbGVTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBSZWdFeHAgdG8gdGVzdCBhZ2FpbnN0IGFuIGluY29tbWluZyB0ZXh0IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSAge1JlZ0V4cH0gICByZWdleHBSZXhlY3V0ZWQgd2l0aCBgZXhlY2AuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCAyIHBhcmFtZXRlcnMsXG4gICAqIHRoZSBgbXNnYCBhbmQgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgYHJlZ2V4cC5leGVjYCBvbiBtZXNzYWdlIHRleHQuXG4gICAqL1xuICBvblRleHQocmVnZXhwLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3RleHRSZWdleHBDYWxsYmFja3MucHVzaCh7IHJlZ2V4cCwgY2FsbGJhY2sgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcmVnaXN0ZXJlZCB3aXRoIGBvblRleHQoKWAuXG4gICAqIEBwYXJhbSAge1JlZ0V4cH0gcmVnZXhwIFJlZ0V4cCB1c2VkIHByZXZpb3VzbHkgaW4gYG9uVGV4dCgpYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlbGV0ZWRMaXN0ZW5lciBUaGUgcmVtb3ZlZCByZXBseSBsaXN0ZW5lciBpZlxuICAgKiAgIGZvdW5kLiBUaGlzIG9iamVjdCBoYXMgYHJlZ2V4cGAgYW5kIGBjYWxsYmFja2BcbiAgICogICBwcm9wZXJ0aWVzLiBJZiBub3QgZm91bmQsIHJldHVybnMgYG51bGxgLlxuICAgKi9cbiAgcmVtb3ZlVGV4dExpc3RlbmVyKHJlZ2V4cCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcy5maW5kSW5kZXgoKHRleHRMaXN0ZW5lcikgPT4ge1xuICAgICAgcmV0dXJuIFN0cmluZyh0ZXh0TGlzdGVuZXIucmVnZXhwKSA9PT0gU3RyaW5nKHJlZ2V4cCk7XG4gICAgfSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSlbMF07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCB3aXRoIGBvblRleHQoKWAuXG4gICAqL1xuICBjbGVhclRleHRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fdGV4dFJlZ2V4cENhbGxiYWNrcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcmVwbHkgdG8gd2FpdCBmb3IgYSBtZXNzYWdlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVGhlIGNoYXQgaWQgd2hlcmUgdGhlIG1lc3NhZ2UgY2FtZXMgZnJvbS5cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gbWVzc2FnZUlkIFRoZSBtZXNzYWdlIGlkIHRvIGJlIHJlcGxpZWQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSByZXBseVxuICAgKiAgbWVzc2FnZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSBpZCBUaGUgSUQgb2YgdGhlIGluc2VydGVkIHJlcGx5IGxpc3RlbmVyLlxuICAgKi9cbiAgb25SZXBseVRvTWVzc2FnZShjaGF0SWQsIG1lc3NhZ2VJZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fcmVwbHlMaXN0ZW5lcklkO1xuICAgIHRoaXMuX3JlcGx5TGlzdGVuZXJzLnB1c2goe1xuICAgICAgaWQsXG4gICAgICBjaGF0SWQsXG4gICAgICBtZXNzYWdlSWQsXG4gICAgICBjYWxsYmFja1xuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcmVwbHkgdGhhdCBoYXMgYmVlbiBwcmV2LiByZWdpc3RlcmVkIGZvciBhIG1lc3NhZ2UgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9IHJlcGx5TGlzdGVuZXJJZCBUaGUgSUQgb2YgdGhlIHJlcGx5IGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBkZWxldGVkTGlzdGVuZXIgVGhlIHJlbW92ZWQgcmVwbHkgbGlzdGVuZXIgaWZcbiAgICogICBmb3VuZC4gVGhpcyBvYmplY3QgaGFzIGBpZGAsIGBjaGF0SWRgLCBgbWVzc2FnZUlkYCBhbmQgYGNhbGxiYWNrYFxuICAgKiAgIHByb3BlcnRpZXMuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBgbnVsbGAuXG4gICAqL1xuICByZW1vdmVSZXBseUxpc3RlbmVyKHJlcGx5TGlzdGVuZXJJZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcmVwbHlMaXN0ZW5lcnMuZmluZEluZGV4KChyZXBseUxpc3RlbmVyKSA9PiB7XG4gICAgICByZXR1cm4gcmVwbHlMaXN0ZW5lci5pZCA9PT0gcmVwbHlMaXN0ZW5lcklkO1xuICAgIH0pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVwbHlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCByZXBsaWVzIHRoYXQgaGF2ZSBiZWVuIHByZXYuIHJlZ2lzdGVyZWQgZm9yIGEgbWVzc2FnZSByZXNwb25zZS5cbiAgICpcbiAgICogQHJldHVybiAge0FycmF5fSBkZWxldGVkTGlzdGVuZXJzIEFuIGFycmF5IG9mIHJlbW92ZWQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY2xlYXJSZXBseUxpc3RlbmVycygpIHtcbiAgICB0aGlzLl9yZXBseUxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHBvbGxpbmcuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1BvbGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvbGxpbmcgPyB0aGlzLl9wb2xsaW5nLmlzUG9sbGluZygpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB3ZWJob29rLlxuICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHdlYmhvb2sgaXMgYWxyZWFkeSBvcGVuLlxuICAgKiBSZWplY3RzIHJldHVybmVkIHByb21pc2UgaWYgUG9sbGluZyBpcyBiZWluZyB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBvcGVuV2ViSG9vaygpIHtcbiAgICBpZiAodGhpcy5pc1BvbGxpbmcoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnMuRmF0YWxFcnJvcignV2ViSG9vayBhbmQgUG9sbGluZyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJykpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3dlYkhvb2spIHtcbiAgICAgIHRoaXMuX3dlYkhvb2sgPSBuZXcgVGVsZWdyYW1Cb3RXZWJIb29rKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2ViSG9vay5vcGVuKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2Ugd2ViaG9vayBhZnRlciBjbG9zaW5nIGFsbCBjdXJyZW50IGNvbm5lY3Rpb25zLlxuICAgKiBNdWx0aXBsZSBpbnZvY2F0aW9ucyBkbyBub3RoaW5nIGlmIHdlYmhvb2sgaXMgYWxyZWFkeSBjbG9zZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2VcbiAgICovXG4gIGNsb3NlV2ViSG9vaygpIHtcbiAgICBpZiAoIXRoaXMuX3dlYkhvb2spIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dlYkhvb2suY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB1c2luZyB3ZWJob29rIGFuZCBpdCBpcyBvcGVuIGkuZS4gYWNjZXB0cyBjb25uZWN0aW9ucy5cbiAgICogT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc09wZW5XZWJIb29rKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJIb29rID8gdGhpcy5fd2ViSG9vay5pc09wZW4oKSA6IGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogUHJvY2VzcyBhbiB1cGRhdGU7IGVtaXR0aW5nIHRoZSBwcm9wZXIgZXZlbnRzIGFuZCBleGVjdXRpbmcgcmVnZXhwXG4gICAqIGNhbGxiYWNrcy4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIHNob3VsZCB5b3UgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICogd2F5IHRvIGZldGNoIHVwZGF0ZXMsIG90aGVyIHRoYW4gdGhvc2UgcHJvdmlkZWQgYnkgVGVsZWdyYW1Cb3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdXBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1cGRhdGVcbiAgICovXG4gIHByb2Nlc3NVcGRhdGUodXBkYXRlKSB7XG4gICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlICVqJywgdXBkYXRlKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdXBkYXRlLm1lc3NhZ2U7XG4gICAgY29uc3QgZWRpdGVkTWVzc2FnZSA9IHVwZGF0ZS5lZGl0ZWRfbWVzc2FnZTtcbiAgICBjb25zdCBjaGFubmVsUG9zdCA9IHVwZGF0ZS5jaGFubmVsX3Bvc3Q7XG4gICAgY29uc3QgZWRpdGVkQ2hhbm5lbFBvc3QgPSB1cGRhdGUuZWRpdGVkX2NoYW5uZWxfcG9zdDtcbiAgICBjb25zdCBidXNpbmVzc0Nvbm5lY3Rpb24gPSB1cGRhdGUuYnVzaW5lc3NfY29ubmVjdGlvbjtcbiAgICBjb25zdCBidXNpbmVzc3NNZXNzYWdlID0gdXBkYXRlLmJ1c2luZXNzX21lc3NhZ2U7XG4gICAgY29uc3QgZWRpdGVkQnVzaW5lc3NNZXNzYWdlID0gdXBkYXRlLmVkaXRlZF9idXNpbmVzc19tZXNzYWdlO1xuICAgIGNvbnN0IGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UgPSB1cGRhdGUuZGVsZXRlZF9idXNpbmVzc19tZXNzYWdlcztcbiAgICBjb25zdCBtZXNzYWdlUmVhY3Rpb24gPSB1cGRhdGUubWVzc2FnZV9yZWFjdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlUmVhY3Rpb25Db3VudCA9IHVwZGF0ZS5tZXNzYWdlX3JlYWN0aW9uX2NvdW50O1xuICAgIGNvbnN0IGlubGluZVF1ZXJ5ID0gdXBkYXRlLmlubGluZV9xdWVyeTtcbiAgICBjb25zdCBjaG9zZW5JbmxpbmVSZXN1bHQgPSB1cGRhdGUuY2hvc2VuX2lubGluZV9yZXN1bHQ7XG4gICAgY29uc3QgY2FsbGJhY2tRdWVyeSA9IHVwZGF0ZS5jYWxsYmFja19xdWVyeTtcbiAgICBjb25zdCBzaGlwcGluZ1F1ZXJ5ID0gdXBkYXRlLnNoaXBwaW5nX3F1ZXJ5O1xuICAgIGNvbnN0IHByZUNoZWNrb3V0UXVlcnkgPSB1cGRhdGUucHJlX2NoZWNrb3V0X3F1ZXJ5O1xuICAgIGNvbnN0IHBvbGwgPSB1cGRhdGUucG9sbDtcbiAgICBjb25zdCBwb2xsQW5zd2VyID0gdXBkYXRlLnBvbGxfYW5zd2VyO1xuICAgIGNvbnN0IG15Q2hhdE1lbWJlciA9IHVwZGF0ZS5teV9jaGF0X21lbWJlcjtcbiAgICBjb25zdCBjaGF0TWVtYmVyID0gdXBkYXRlLmNoYXRfbWVtYmVyO1xuICAgIGNvbnN0IGNoYXRKb2luUmVxdWVzdCA9IHVwZGF0ZS5jaGF0X2pvaW5fcmVxdWVzdDtcbiAgICBjb25zdCBjaGF0Qm9vc3QgPSB1cGRhdGUuY2hhdF9ib29zdDtcbiAgICBjb25zdCByZW1vdmVkQ2hhdEJvb3N0ID0gdXBkYXRlLnJlbW92ZWRfY2hhdF9ib29zdDtcblxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBtZXNzYWdlICVqJywgbWVzc2FnZSk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgICAgbWV0YWRhdGEudHlwZSA9IFRlbGVncmFtQm90Lm1lc3NhZ2VUeXBlcy5maW5kKChtZXNzYWdlVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gbWVzc2FnZVttZXNzYWdlVHlwZV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgICAgIGlmIChtZXRhZGF0YS50eXBlKSB7XG4gICAgICAgIGRlYnVnKCdFbWl0dGluZyAlczogJWonLCBtZXRhZGF0YS50eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KG1ldGFkYXRhLnR5cGUsIG1lc3NhZ2UsIG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnRleHQpIHtcbiAgICAgICAgZGVidWcoJ1RleHQgbWVzc2FnZScpO1xuICAgICAgICB0aGlzLl90ZXh0UmVnZXhwQ2FsbGJhY2tzLnNvbWUocmVnID0+IHtcbiAgICAgICAgICBkZWJ1ZygnTWF0Y2hpbmcgJXMgd2l0aCAlcycsIG1lc3NhZ2UudGV4dCwgcmVnLnJlZ2V4cCk7XG5cbiAgICAgICAgICBpZiAoIShyZWcucmVnZXhwIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmVnLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmVnLnJlZ2V4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnLnJlZ2V4cC5leGVjKG1lc3NhZ2UudGV4dCk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVzZXQgaW5kZXggc28gd2Ugc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVnZXggZWFjaCB0aW1lXG4gICAgICAgICAgcmVnLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIGRlYnVnKCdNYXRjaGVzICVzJywgcmVnLnJlZ2V4cCk7XG4gICAgICAgICAgcmVnLmNhbGxiYWNrKG1lc3NhZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgLy8gcmV0dXJuaW5nIHRydXRoeSB2YWx1ZSBleGl0cyAuc29tZVxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub25seUZpcnN0TWF0Y2g7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UucmVwbHlfdG9fbWVzc2FnZSkge1xuICAgICAgICAvLyBPbmx5IGNhbGxiYWNrcyB3YWl0aW5nIGZvciB0aGlzIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fcmVwbHlMaXN0ZW5lcnMuZm9yRWFjaChyZXBseSA9PiB7XG4gICAgICAgICAgLy8gTWVzc2FnZSBmcm9tIHRoZSBzYW1lIGNoYXRcbiAgICAgICAgICBpZiAocmVwbHkuY2hhdElkID09PSBtZXNzYWdlLmNoYXQuaWQpIHtcbiAgICAgICAgICAgIC8vIFJlc3BvbmRpbmcgdG8gdGhhdCBtZXNzYWdlXG4gICAgICAgICAgICBpZiAocmVwbHkubWVzc2FnZUlkID09PSBtZXNzYWdlLnJlcGx5X3RvX21lc3NhZ2UubWVzc2FnZV9pZCkge1xuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgIHJlcGx5LmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlZGl0ZWRNZXNzYWdlKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX21lc3NhZ2UgJWonLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2UnLCBlZGl0ZWRNZXNzYWdlKTtcbiAgICAgIGlmIChlZGl0ZWRNZXNzYWdlLnRleHQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfbWVzc2FnZV90ZXh0JywgZWRpdGVkTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdGVkTWVzc2FnZS5jYXB0aW9uKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX21lc3NhZ2VfY2FwdGlvbicsIGVkaXRlZE1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbFBvc3QpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaGFubmVsX3Bvc3QgJWonLCBjaGFubmVsUG9zdCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5uZWxfcG9zdCcsIGNoYW5uZWxQb3N0KTtcbiAgICB9IGVsc2UgaWYgKGVkaXRlZENoYW5uZWxQb3N0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgZWRpdGVkX2NoYW5uZWxfcG9zdCAlaicsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdCcsIGVkaXRlZENoYW5uZWxQb3N0KTtcbiAgICAgIGlmIChlZGl0ZWRDaGFubmVsUG9zdC50ZXh0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZWRpdGVkX2NoYW5uZWxfcG9zdF90ZXh0JywgZWRpdGVkQ2hhbm5lbFBvc3QpO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRlZENoYW5uZWxQb3N0LmNhcHRpb24pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlZGl0ZWRfY2hhbm5lbF9wb3N0X2NhcHRpb24nLCBlZGl0ZWRDaGFubmVsUG9zdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc0Nvbm5lY3Rpb24pIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBidXNpbmVzc19jb25uZWN0aW9uICVqJywgYnVzaW5lc3NDb25uZWN0aW9uKTtcbiAgICAgIHRoaXMuZW1pdCgnYnVzaW5lc3NfY29ubmVjdGlvbicsIGJ1c2luZXNzQ29ubmVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChidXNpbmVzc3NNZXNzYWdlKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgYnVzaW5lc3NfbWVzc2FnZSAlaicsIGJ1c2luZXNzc01lc3NhZ2UpO1xuICAgICAgdGhpcy5lbWl0KCdidXNpbmVzc19tZXNzYWdlJywgYnVzaW5lc3NzTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChlZGl0ZWRCdXNpbmVzc01lc3NhZ2UpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBlZGl0ZWRfYnVzaW5lc3NfbWVzc2FnZSAlaicsIGVkaXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoJ2VkaXRlZF9idXNpbmVzc19tZXNzYWdlJywgZWRpdGVkQnVzaW5lc3NNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRlbGV0ZWRCdXNpbmVzc01lc3NhZ2UpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBkZWxldGVkX2J1c2luZXNzX21lc3NhZ2VzICVqJywgZGVsZXRlZEJ1c2luZXNzTWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoJ2RlbGV0ZWRfYnVzaW5lc3NfbWVzc2FnZXMnLCBkZWxldGVkQnVzaW5lc3NNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2VSZWFjdGlvbikge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG1lc3NhZ2VfcmVhY3Rpb24gJWonLCBtZXNzYWdlUmVhY3Rpb24pO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlX3JlYWN0aW9uJywgbWVzc2FnZVJlYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2VSZWFjdGlvbkNvdW50KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgbWVzc2FnZV9yZWFjdGlvbl9jb3VudCAlaicsIG1lc3NhZ2VSZWFjdGlvbkNvdW50KTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZV9yZWFjdGlvbl9jb3VudCcsIG1lc3NhZ2VSZWFjdGlvbkNvdW50KTtcbiAgICB9IGVsc2UgaWYgKGlubGluZVF1ZXJ5KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgaW5saW5lX3F1ZXJ5ICVqJywgaW5saW5lUXVlcnkpO1xuICAgICAgdGhpcy5lbWl0KCdpbmxpbmVfcXVlcnknLCBpbmxpbmVRdWVyeSk7XG4gICAgfSBlbHNlIGlmIChjaG9zZW5JbmxpbmVSZXN1bHQpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaG9zZW5faW5saW5lX3Jlc3VsdCAlaicsIGNob3NlbklubGluZVJlc3VsdCk7XG4gICAgICB0aGlzLmVtaXQoJ2Nob3Nlbl9pbmxpbmVfcmVzdWx0JywgY2hvc2VuSW5saW5lUmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrUXVlcnkpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjYWxsYmFja19xdWVyeSAlaicsIGNhbGxiYWNrUXVlcnkpO1xuICAgICAgdGhpcy5lbWl0KCdjYWxsYmFja19xdWVyeScsIGNhbGxiYWNrUXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoc2hpcHBpbmdRdWVyeSkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHNoaXBwaW5nX3F1ZXJ5ICVqJywgc2hpcHBpbmdRdWVyeSk7XG4gICAgICB0aGlzLmVtaXQoJ3NoaXBwaW5nX3F1ZXJ5Jywgc2hpcHBpbmdRdWVyeSk7XG4gICAgfSBlbHNlIGlmIChwcmVDaGVja291dFF1ZXJ5KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgcHJlX2NoZWNrb3V0X3F1ZXJ5ICVqJywgcHJlQ2hlY2tvdXRRdWVyeSk7XG4gICAgICB0aGlzLmVtaXQoJ3ByZV9jaGVja291dF9xdWVyeScsIHByZUNoZWNrb3V0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAocG9sbCkge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHBvbGwgJWonLCBwb2xsKTtcbiAgICAgIHRoaXMuZW1pdCgncG9sbCcsIHBvbGwpO1xuICAgIH0gZWxzZSBpZiAocG9sbEFuc3dlcikge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIHBvbGxfYW5zd2VyICVqJywgcG9sbEFuc3dlcik7XG4gICAgICB0aGlzLmVtaXQoJ3BvbGxfYW5zd2VyJywgcG9sbEFuc3dlcik7XG4gICAgfSBlbHNlIGlmIChjaGF0TWVtYmVyKSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgY2hhdF9tZW1iZXIgJWonLCBjaGF0TWVtYmVyKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhdF9tZW1iZXInLCBjaGF0TWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKG15Q2hhdE1lbWJlcikge1xuICAgICAgZGVidWcoJ1Byb2Nlc3MgVXBkYXRlIG15X2NoYXRfbWVtYmVyICVqJywgbXlDaGF0TWVtYmVyKTtcbiAgICAgIHRoaXMuZW1pdCgnbXlfY2hhdF9tZW1iZXInLCBteUNoYXRNZW1iZXIpO1xuICAgIH0gZWxzZSBpZiAoY2hhdEpvaW5SZXF1ZXN0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgbXlfY2hhdF9tZW1iZXIgJWonLCBjaGF0Sm9pblJlcXVlc3QpO1xuICAgICAgdGhpcy5lbWl0KCdjaGF0X2pvaW5fcmVxdWVzdCcsIGNoYXRKb2luUmVxdWVzdCk7XG4gICAgfSBlbHNlIGlmIChjaGF0Qm9vc3QpIHtcbiAgICAgIGRlYnVnKCdQcm9jZXNzIFVwZGF0ZSBjaGF0X2Jvb3N0ICVqJywgY2hhdEJvb3N0KTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhdF9ib29zdCcsIGNoYXRCb29zdCk7XG4gICAgfSBlbHNlIGlmIChyZW1vdmVkQ2hhdEJvb3N0KSB7XG4gICAgICBkZWJ1ZygnUHJvY2VzcyBVcGRhdGUgcmVtb3ZlZF9jaGF0X2Jvb3N0ICVqJywgcmVtb3ZlZENoYXRCb29zdCk7XG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZWRfY2hhdF9ib29zdCcsIHJlbW92ZWRDaGF0Qm9vc3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTdGFydCBUZWxlZ3JhbSBCb3QgQVBJIG1ldGhvZHMgKi9cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVjZWl2ZSBpbmNvbWluZyB1cGRhdGVzIHVzaW5nIGxvbmcgcG9sbGluZy5cbiAgKiBUaGlzIG1ldGhvZCBoYXMgYW4gW29sZGVyLCBjb21wYXRpYmxlIHNpZ25hdHVyZV1bZ2V0VXBkYXRlcy12MC4yNS4wXVxuICAqIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZC5cbiAgKlxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHVwZGF0ZXNcbiAgKi9cbiAgZ2V0VXBkYXRlcyhmb3JtID0ge30pIHtcbiAgICAvKiBUaGUgb2xkZXIgbWV0aG9kIHNpZ25hdHVyZSB3YXMgZ2V0VXBkYXRlcyh0aW1lb3V0LCBsaW1pdCwgb2Zmc2V0KS5cbiAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgaWYgKHR5cGVvZiBmb3JtICE9PSAnb2JqZWN0Jykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBnZXRVcGRhdGVzKHRpbWVvdXQsIGxpbWl0LCBvZmZzZXQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjUuMCcpO1xuICAgICAgZm9ybSA9IHtcbiAgICAgICAgdGltZW91dDogYXJndW1lbnRzWzBdLFxuICAgICAgICBsaW1pdDogYXJndW1lbnRzWzFdLFxuICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1syXSxcbiAgICAgIH07XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0VXBkYXRlcycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGFuIHVybCB0byByZWNlaXZlIGluY29taW5nIHVwZGF0ZXMgdmlhIGFuIG91dGdvaW5nIHdlYkhvb2suXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBhbiBbb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlXVtzZXRXZWJIb29rLXYwLjI1LjBdXG4gICAqIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB1cmwgVVJMIHdoZXJlIFRlbGVncmFtIHdpbGwgbWFrZSBIVFRQIFBvc3QuIExlYXZlIGVtcHR5IHRvXG4gICAqIGRlbGV0ZSB3ZWJIb29rLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW19IFtvcHRpb25zLmNlcnRpZmljYXRlXSBQRU0gY2VydGlmaWNhdGUga2V5IChwdWJsaWMpLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnNlY3JldF90b2tlbl0gT3B0aW9uYWwgc2VjcmV0IHRva2VuIHRvIGJlIHNlbnQgaW4gYSBoZWFkZXIgYFgtVGVsZWdyYW0tQm90LUFwaS1TZWNyZXQtVG9rZW5gIGluIGV2ZXJ5IHdlYmhvb2sgcmVxdWVzdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHdlYmhvb2tcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAqL1xuICBzZXRXZWJIb29rKHVybCwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgd2FzIHNldFdlYkhvb2sodXJsLCBjZXJ0KS5cbiAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5ICovXG4gICAgbGV0IGNlcnQ7XG4gICAgLy8gTm90ZTogJ29wdGlvbnMnIGNvdWxkIGJlIGFuIG9iamVjdCwgaWYgYSBzdHJlYW0gd2FzIHByb3ZpZGVkIChpbiBwbGFjZSBvZiAnY2VydCcpXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zIGluc3RhbmNlb2Ygc3RyZWFtLlN0cmVhbSkge1xuICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBzZXRXZWJIb29rKHVybCwgY2VydCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yNS4wJyk7XG4gICAgICBjZXJ0ID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH0gZWxzZSB7XG4gICAgICBjZXJ0ID0gb3B0aW9ucy5jZXJ0aWZpY2F0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgfTtcbiAgICBvcHRzLnFzLnVybCA9IHVybDtcblxuICAgIGlmIChjZXJ0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdjZXJ0aWZpY2F0ZScsIGNlcnQsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgICBvcHRzLnFzLmNlcnRpZmljYXRlID0gc2VuZERhdGFbMV07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRXZWJIb29rJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlbW92ZSB3ZWJob29rIGludGVncmF0aW9uIGlmIHlvdSBkZWNpZGUgdG9cbiAgICogc3dpdGNoIGJhY2sgdG8gZ2V0VXBkYXRlcy4gUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRld2ViaG9va1xuICAgKi9cbiAgZGVsZXRlV2ViSG9vayhmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlV2ViaG9vaycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGN1cnJlbnQgd2ViaG9vayBzdGF0dXMuXG4gICAqIE9uIHN1Y2Nlc3MsIHJldHVybnMgYSBbV2ViaG9va0luZm9dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjd2ViaG9va2luZm8pIG9iamVjdC5cbiAgICogSWYgdGhlIGJvdCBpcyB1c2luZyBnZXRVcGRhdGVzLCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICogdXJsIGZpZWxkIGVtcHR5LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHdlYmhvb2tpbmZvXG4gICAqL1xuICBnZXRXZWJIb29rSW5mbyhmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0V2ViaG9va0luZm8nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgbWV0aG9kIGZvciB0ZXN0aW5nIHlvdXIgYm90J3MgYXV0aGVudGljYXRpb24gdG9rZW4uIFJlcXVpcmVzIG5vIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYm90IGluIGZvcm0gb2YgYSBbVXNlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1c2VyKSBvYmplY3QuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRtZVxuICAgKi9cbiAgZ2V0TWUoZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE1lJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxvZyBvdXQgeW91ciBib3QgZnJvbSB0aGUgY2xvdWQgQm90IEFQSSBzZXJ2ZXIgYmVmb3JlIGxhdW5jaGluZyB0aGUgYm90IGxvY2FsbHkuXG4gICAqIFlvdSBtdXN0IGxvZyBvdXQgdGhlIGJvdCBiZWZvcmUgcnVubmluZyBpdCBsb2NhbGx5LCBvdGhlcndpc2UgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGJvdCB3aWxsIHJlY2VpdmUgdXBkYXRlcy5cbiAgICogQWZ0ZXIgYSBzdWNjZXNzZnVsIGNhbGwsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGxvZyBpbiBhZ2FpbiB1c2luZyB0aGUgc2FtZSB0b2tlbiBmb3IgMTAgbWludXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2xvZ291dFxuICAgKi9cbiAgbG9nT3V0KGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdsb2dPdXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xvc2UgdGhlIGJvdCBpbnN0YW5jZSBiZWZvcmUgbW92aW5nIGl0IGZyb20gb25lIGxvY2FsIHNlcnZlciB0byBhbm90aGVyLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBlcnJvciA0MjkgaW4gdGhlIGZpcnN0IDEwIG1pbnV0ZXMgYWZ0ZXIgdGhlIGJvdCBpcyBsYXVuY2hlZC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Nsb3NlXG4gICAqL1xuICBjbG9zZShmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY2xvc2UnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0ZXh0IG1lc3NhZ2UuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBUZXh0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIHNlbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZG1lc3NhZ2VcbiAgICovXG4gIHNlbmRNZXNzYWdlKGNoYXRJZCwgdGV4dCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRNZXNzYWdlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcndhcmQgbWVzc2FnZXMgb2YgYW55IGtpbmQuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgKiBvcmlnaW5hbCBtZXNzYWdlIHdhcyBzZW50IChvciBjaGFubmVsIHVzZXJuYW1lIGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBtZXNzYWdlSWQgIFVuaXF1ZSBtZXNzYWdlIGlkZW50aWZpZXIgaW4gdGhlIGNoYXQgc3BlY2lmaWVkIGluIGZyb21DaGF0SWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNmb3J3YXJkbWVzc2FnZVxuICAgKi9cbiAgZm9yd2FyZE1lc3NhZ2UoY2hhdElkLCBmcm9tQ2hhdElkLCBtZXNzYWdlSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmZyb21fY2hhdF9pZCA9IGZyb21DaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdmb3J3YXJkTWVzc2FnZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZm9yd2FyZCBtdWx0aXBsZSBtZXNzYWdlcyBvZiBhbnkga2luZC5cbiAgICogSWYgc29tZSBvZiB0aGUgc3BlY2lmaWVkIG1lc3NhZ2VzIGNhbid0IGJlIGZvdW5kIG9yIGZvcndhcmRlZCwgdGhleSBhcmUgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gZnJvbUNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNoYXQgd2hlcmUgdGhlXG4gICAqIG9yaWdpbmFsIG1lc3NhZ2Ugd2FzIHNlbnQgKG9yIGNoYW5uZWwgdXNlcm5hbWUgaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge0FycmF5PE51bWJlcnxTdHJpbmc+fSBtZXNzYWdlSWRzIElkZW50aWZpZXJzIG9mIDEtMTAwIG1lc3NhZ2VzIGluIHRoZSBjaGF0IGZyb21fY2hhdF9pZCB0byBmb3J3YXJkLlxuICAgKiBUaGUgaWRlbnRpZmllcnMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gYSBzdHJpY3RseSBpbmNyZWFzaW5nIG9yZGVyLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQW4gYXJyYXkgb2YgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2VzIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZvcndhcmRtZXNzYWdlc1xuICAgKi9cbiAgZm9yd2FyZE1lc3NhZ2VzKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWRzID0gbWVzc2FnZUlkcztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZm9yd2FyZE1lc3NhZ2VzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcHkgbWVzc2FnZXMgb2YgYW55IGtpbmQuICoqU2VydmljZSBtZXNzYWdlcyBhbmQgaW52b2ljZSBtZXNzYWdlcyBjYW4ndCBiZSBjb3BpZWQuKipcbiAgICogVGhlIG1ldGhvZCBpcyBhbmFsb2dvdXMgdG8gdGhlIG1ldGhvZCBmb3J3YXJkTWVzc2FnZXMsIGJ1dCB0aGUgY29waWVkIG1lc3NhZ2UgZG9lc24ndFxuICAgKiBoYXZlIGEgbGluayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZS5cbiAgICogUmV0dXJucyB0aGUgTWVzc2FnZUlkIG9mIHRoZSBzZW50IG1lc3NhZ2Ugb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICAgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyb21DaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjaGF0IHdoZXJlIHRoZVxuICAgKiBvcmlnaW5hbCBtZXNzYWdlIHdhcyBzZW50XG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IG1lc3NhZ2VJZCAgVW5pcXVlIG1lc3NhZ2UgaWRlbnRpZmllclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIFtNZXNzYWdlSWRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZWlkKSBvZiB0aGUgc2VudCBtZXNzYWdlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlXG4gICAqL1xuICBjb3B5TWVzc2FnZShjaGF0SWQsIGZyb21DaGF0SWQsIG1lc3NhZ2VJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWQgPSBtZXNzYWdlSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NvcHlNZXNzYWdlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjb3B5IG1lc3NhZ2VzIG9mIGFueSBraW5kLiBJZiBzb21lIG9mIHRoZSBzcGVjaWZpZWQgbWVzc2FnZXMgY2FuJ3QgYmUgZm91bmQgb3IgY29waWVkLCB0aGV5IGFyZSBza2lwcGVkLlxuICAgKiBTZXJ2aWNlIG1lc3NhZ2VzLCBnaXZlYXdheSBtZXNzYWdlcywgZ2l2ZWF3YXkgd2lubmVycyBtZXNzYWdlcywgYW5kIGludm9pY2UgbWVzc2FnZXMgY2FuJ3QgYmUgY29waWVkLlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlSWQgb2YgdGhlIHNlbnQgbWVzc2FnZSBvbiBzdWNjZXNzLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBmcm9tQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2hhdCB3aGVyZSB0aGVcbiAgICogb3JpZ2luYWwgbWVzc2FnZSB3YXMgc2VudFxuICAgKiBAcGFyYW0gIHtBcnJheX0gbWVzc2FnZUlkcyAgSWRlbnRpZmllcnMgb2YgMS0xMDAgbWVzc2FnZXMgaW4gdGhlIGNoYXQgZnJvbV9jaGF0X2lkIHRvIGNvcHkuXG4gICAqIFRoZSBpZGVudGlmaWVycyBtdXN0IGJlIHNwZWNpZmllZCBpbiBhIHN0cmljdGx5IGluY3JlYXNpbmcgb3JkZXIuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBbiBhcnJheSBvZiBNZXNzYWdlSWQgb2YgdGhlIHNlbnQgbWVzc2FnZXNcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NvcHltZXNzYWdlc1xuICAgKi9cbiAgY29weU1lc3NhZ2VzKGNoYXRJZCwgZnJvbUNoYXRJZCwgbWVzc2FnZUlkcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uZnJvbV9jaGF0X2lkID0gZnJvbUNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWRzID0gc3RyaW5naWZ5KG1lc3NhZ2VJZHMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjb3B5TWVzc2FnZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBwaG90b1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSBwaG90byBBIGZpbGUgcGF0aCBvciBhIFN0cmVhbS4gQ2FuXG4gICAqIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kcGhvdG9cbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAqL1xuICBzZW5kUGhvdG8oY2hhdElkLCBwaG90bywgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdwaG90bycsIHBob3RvLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnBob3RvID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kUGhvdG8nLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNlbmQgYXVkaW9cbiAgKlxuICAqICoqWW91ciBhdWRpbyBtdXN0IGJlIGluIHRoZSAuTVAzIG9yIC5NNEEgZm9ybWF0LioqXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IGF1ZGlvIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGF1ZGlvXG4gICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICovXG4gIHNlbmRBdWRpbyhjaGF0SWQsIGF1ZGlvLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2F1ZGlvJywgYXVkaW8sIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMuYXVkaW8gPSBzZW5kRGF0YVsxXTtcbiAgICAgIHRoaXMuX2ZpeEFkZEZpbGVUaHVtYm5haWwob3B0aW9ucywgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRBdWRpbycsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICogU2VuZCBEb2N1bWVudFxuICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gZG9jIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSAgT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmREb2N1bWVudFxuICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAqL1xuICBzZW5kRG9jdW1lbnQoY2hhdElkLCBkb2MsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9uc1xuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdkb2N1bWVudCcsIGRvYywgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy5kb2N1bWVudCA9IHNlbmREYXRhWzFdO1xuICAgICAgdGhpcy5fZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZERvY3VtZW50Jywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgdmlkZW8gZmlsZXMsICoqVGVsZWdyYW0gY2xpZW50cyBzdXBwb3J0IG1wNCB2aWRlb3MqKiAob3RoZXIgZm9ybWF0cyBtYXkgYmUgc2VudCBhcyBEb2N1bWVudCkuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHZpZGVvIEEgZmlsZSBwYXRoIG9yIFN0cmVhbS5cbiAgICogQ2FuIGFsc28gYmUgYSBgZmlsZV9pZGAgcHJldmlvdXNseSB1cGxvYWRlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2VuZFZpZGVvKGNoYXRJZCwgdmlkZW8sIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9uc1xuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCd2aWRlbycsIHZpZGVvLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnZpZGVvID0gc2VuZERhdGFbMV07XG4gICAgICB0aGlzLl9maXhBZGRGaWxlVGh1bWJuYWlsKG9wdGlvbnMsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFZpZGVvJywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYW5pbWF0aW9uIGZpbGVzIChHSUYgb3IgSC4yNjQvTVBFRy00IEFWQyB2aWRlbyB3aXRob3V0IHNvdW5kKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gYW5pbWF0aW9uIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kYW5pbWF0aW9uXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2VuZEFuaW1hdGlvbihjaGF0SWQsIGFuaW1hdGlvbiwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfTtcbiAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ2FuaW1hdGlvbicsIGFuaW1hdGlvbiwgZmlsZU9wdGlvbnMpO1xuICAgICAgb3B0cy5mb3JtRGF0YSA9IHNlbmREYXRhWzBdO1xuICAgICAgb3B0cy5xcy5hbmltYXRpb24gPSBzZW5kRGF0YVsxXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRBbmltYXRpb24nLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHZvaWNlXG4gICAqXG4gICAqICoqWW91ciBhdWRpbyBtdXN0IGJlIGluIGFuIC5PR0cgZmlsZSBlbmNvZGVkIHdpdGggT1BVUyoqLCBvciBpbiAuTVAzIGZvcm1hdCwgb3IgaW4gLk00QSBmb3JtYXQgKG90aGVyIGZvcm1hdHMgbWF5IGJlIHNlbnQgYXMgQXVkaW8gb3IgRG9jdW1lbnQpXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHZvaWNlIEEgZmlsZSBwYXRoLCBTdHJlYW0gb3IgQnVmZmVyLlxuICAgKiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdm9pY2VcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20veWFnb3Avbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL2Jsb2IvbWFzdGVyL2RvYy91c2FnZS5tZCNzZW5kaW5nLWZpbGVzXG4gICAqL1xuICBzZW5kVm9pY2UoY2hhdElkLCB2b2ljZSwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfTtcbiAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3ZvaWNlJywgdm9pY2UsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMudm9pY2UgPSBzZW5kRGF0YVsxXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWb2ljZScsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHZpZGVvIG1lc3NhZ2VzXG4gICAqIFRlbGVncmFtIGNsaWVudHMgc3VwcG9ydCAqKnJvdW5kZWQgc3F1YXJlIE1QRUc0IHZpZGVvcyoqIG9mIHVwIHRvIDEgbWludXRlIGxvbmcuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHZpZGVvTm90ZSBBIGZpbGUgcGF0aCBvciBTdHJlYW0uXG4gICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQGluZm8gVGhlIGxlbmd0aCBwYXJhbWV0ZXIgaXMgYWN0dWFsbHkgb3B0aW9uYWwuIEhvd2V2ZXIsIHRoZSBBUEkgKGF0IHRpbWUgb2Ygd3JpdGluZykgcmVxdWlyZXMgeW91IHRvIGFsd2F5cyBwcm92aWRlIGl0IHVudGlsIGl0IGlzIGZpeGVkLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvbm90ZVxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvYmxvYi9tYXN0ZXIvZG9jL3VzYWdlLm1kI3NlbmRpbmctZmlsZXNcbiAgKi9cbiAgc2VuZFZpZGVvTm90ZShjaGF0SWQsIHZpZGVvTm90ZSwgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfTtcbiAgICBvcHRzLnFzLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoJ3ZpZGVvX25vdGUnLCB2aWRlb05vdGUsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMudmlkZW9fbm90ZSA9IHNlbmREYXRhWzFdO1xuICAgICAgdGhpcy5fZml4QWRkRmlsZVRodW1ibmFpbChvcHRpb25zLCBvcHRzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRWaWRlb05vdGUnLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBhIGdyb3VwIG9mIHBob3RvcyBvciB2aWRlb3MgYXMgYW4gYWxidW0uXG4gICAqXG4gICAqICoqRG9jdW1lbnRzIGFuZCBhdWRpbyBmaWxlcyBjYW4gYmUgb25seSBncm91cGVkIGluIGFuIGFsYnVtIHdpdGggbWVzc2FnZXMgb2YgdGhlIHNhbWUgdHlwZSoqXG4gICAqXG4gICAqIElmIHlvdSB3aXNoIHRvIFtzcGVjaWZ5IGZpbGUgb3B0aW9uc10oaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlcyksXG4gICAqIGFkZCBhIGBmaWxlT3B0aW9uc2AgcHJvcGVydHkgdG8gdGhlIHRhcmdldCBpbnB1dCBpbiBgbWVkaWFgLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge0FycmF5fSBtZWRpYSBBIEpTT04tc2VyaWFsaXplZCBhcnJheSBkZXNjcmliaW5nIHBob3RvcyBhbmQgdmlkZW9zIHRvIGJlIHNlbnQsIG11c3QgaW5jbHVkZSAy4oCTMTAgaXRlbXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGFuIGFycmF5IG9mIHRoZSBzZW50IFtNZXNzYWdlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKVxuICAgKiBpcyByZXR1cm5lZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZWRpYWdyb3VwXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9ibG9iL21hc3Rlci9kb2MvdXNhZ2UubWQjc2VuZGluZy1maWxlc1xuICAgKi9cbiAgc2VuZE1lZGlhR3JvdXAoY2hhdElkLCBtZWRpYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuXG4gICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuICAgIGNvbnN0IGlucHV0TWVkaWEgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgbWVkaWEpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBpbnB1dCk7XG4gICAgICBkZWxldGUgcGF5bG9hZC5tZWRpYTtcbiAgICAgIGRlbGV0ZSBwYXlsb2FkLmZpbGVPcHRpb25zO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXR0YWNoTmFtZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIGNvbnN0IFtmb3JtRGF0YSwgZmlsZUlkXSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKGF0dGFjaE5hbWUsIGlucHV0Lm1lZGlhLCBpbnB1dC5maWxlT3B0aW9ucyk7XG4gICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgIG9wdHMuZm9ybURhdGFbYXR0YWNoTmFtZV0gPSBmb3JtRGF0YVthdHRhY2hOYW1lXTtcbiAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gYGF0dGFjaDovLyR7YXR0YWNoTmFtZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBheWxvYWQubWVkaWEgPSBmaWxlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG4gICAgICBpbnB1dE1lZGlhLnB1c2gocGF5bG9hZCk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBvcHRzLnFzLm1lZGlhID0gc3RyaW5naWZ5KGlucHV0TWVkaWEpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRNZWRpYUdyb3VwJywgb3B0cyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZW5kIGxvY2F0aW9uLlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2VuZCBwb2ludCBvbiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7RmxvYXR9IGxhdGl0dWRlIExhdGl0dWRlIG9mIGxvY2F0aW9uXG4gICAqIEBwYXJhbSAge0Zsb2F0fSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIGxvY2F0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRsb2NhdGlvblxuICAgKi9cbiAgc2VuZExvY2F0aW9uKGNoYXRJZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZExvY2F0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IGxpdmUgbG9jYXRpb24gbWVzc2FnZXMgc2VudCBieVxuICAgKiB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgKlxuICAgKiAgQSBsb2NhdGlvbiAqKmNhbiBiZSBlZGl0ZWQgdW50aWwgaXRzIGxpdmVfcGVyaW9kIGV4cGlyZXMgb3IgZWRpdGluZyBpcyBleHBsaWNpdGx5IGRpc2FibGVkIGJ5IGEgY2FsbCB0byBbc3RvcE1lc3NhZ2VMaXZlTG9jYXRpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RvcG1lc3NhZ2VsaXZlbG9jYXRpb24pKipcbiAgICpcbiAgICogTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yXG4gICAqIGlubGluZV9tZXNzYWdlX2lkIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7RmxvYXR9IGxhdGl0dWRlIExhdGl0dWRlIG9mIGxvY2F0aW9uXG4gICAqIEBwYXJhbSAge0Zsb2F0fSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIGxvY2F0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdG1lc3NhZ2VsaXZlbG9jYXRpb25cbiAgICovXG4gIGVkaXRNZXNzYWdlTGl2ZUxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VMaXZlTG9jYXRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHN0b3AgdXBkYXRpbmcgYSBsaXZlIGxvY2F0aW9uIG1lc3NhZ2Ugc2VudCBieVxuICAgKiB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpIGJlZm9yZSBsaXZlX3BlcmlvZCBleHBpcmVzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3JcbiAgICogaW5saW5lX21lc3NhZ2VfaWQgaW4geW91ciByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnMgKHByb3ZpZGUgZWl0aGVyIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCBoZXJlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgZWRpdGVkIG1lc3NhZ2UgaXMgbm90IGFuIGlubGluZSBtZXNzYWdlLCB0aGUgZWRpdGVkIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkLCBvdGhlcndpc2UgVHJ1ZSBpcyByZXR1cm5lZC5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3N0b3BtZXNzYWdlbGl2ZWxvY2F0aW9uXG4gICAqL1xuICBzdG9wTWVzc2FnZUxpdmVMb2NhdGlvbihmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc3RvcE1lc3NhZ2VMaXZlTG9jYXRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB2ZW51ZS5cbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgaW5mb3JtYXRpb24gYWJvdXQgYSB2ZW51ZS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge0Zsb2F0fSBsYXRpdHVkZSBMYXRpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtGbG9hdH0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiBsb2NhdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIE5hbWUgb2YgdGhlIHZlbnVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWRkcmVzcyBBZGRyZXNzIG9mIHRoZSB2ZW51ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZlbnVlXG4gICAqL1xuICBzZW5kVmVudWUoY2hhdElkLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aXRsZSwgYWRkcmVzcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICBmb3JtLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgZm9ybS5hZGRyZXNzID0gYWRkcmVzcztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFZlbnVlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgY29udGFjdC5cbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgcGhvbmUgY29udGFjdHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBob25lTnVtYmVyIENvbnRhY3QncyBwaG9uZSBudW1iZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaXJzdE5hbWUgQ29udGFjdCdzIGZpcnN0IG5hbWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGNvbnRhY3RcbiAgICovXG4gIHNlbmRDb250YWN0KGNoYXRJZCwgcGhvbmVOdW1iZXIsIGZpcnN0TmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ucGhvbmVfbnVtYmVyID0gcGhvbmVOdW1iZXI7XG4gICAgZm9ybS5maXJzdF9uYW1lID0gZmlyc3ROYW1lO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kQ29udGFjdCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHBvbGwuXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGEgbmF0aXZlIHBvbGwuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cC9jaGFubmVsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcXVlc3Rpb24gUG9sbCBxdWVzdGlvbiwgMS0zMDAgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtBcnJheX0gcG9sbE9wdGlvbnMgUG9sbCBvcHRpb25zLCBiZXR3ZWVuIDItMTAgb3B0aW9ucyAob25seSAxLTEwMCBjaGFyYWN0ZXJzIGVhY2gpXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCB0aGUgc2VudCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRwb2xsXG4gICAqL1xuICBzZW5kUG9sbChjaGF0SWQsIHF1ZXN0aW9uLCBwb2xsT3B0aW9ucywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ucXVlc3Rpb24gPSBxdWVzdGlvbjtcbiAgICBmb3JtLm9wdGlvbnMgPSBzdHJpbmdpZnkocG9sbE9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kUG9sbCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIERpY2VcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNlbmQgYW4gYW5pbWF0ZWQgZW1vamkgdGhhdCB3aWxsIGRpc3BsYXkgYSByYW5kb20gdmFsdWUuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGRpY2VcbiAgICovXG4gIHNlbmREaWNlKGNoYXRJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdkaWNlJyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kRGljZScsIG9wdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogU2VuZCBjaGF0IGFjdGlvbi5cbiAgICpcbiAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4geW91IG5lZWQgdG8gdGVsbCB0aGUgdXNlciB0aGF0IHNvbWV0aGluZyBpcyBoYXBwZW5pbmcgb24gdGhlIGJvdCdzIHNpZGUuXG4gICAqICoqVGhlIHN0YXR1cyBpcyBzZXQgZm9yIDUgc2Vjb25kcyBvciBsZXNzKiogKHdoZW4gYSBtZXNzYWdlIGFycml2ZXMgZnJvbSB5b3VyIGJvdCwgVGVsZWdyYW0gY2xpZW50cyBjbGVhciBpdHMgdHlwaW5nIHN0YXR1cykuXG4gICAqXG4gICAqICBBY3Rpb24gYHR5cGluZ2AgZm9yIFt0ZXh0IG1lc3NhZ2VzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRtZXNzYWdlKSxcbiAgICogYHVwbG9hZF9waG90b2AgZm9yIFtwaG90b3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHBob3RvKSwgYHJlY29yZF92aWRlb2Agb3IgYHVwbG9hZF92aWRlb2AgZm9yIFt2aWRlb3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZHZpZGVvKSxcbiAgICogYHJlY29yZF92b2ljZWAgb3IgYHVwbG9hZF92b2ljZWAgZm9yIFt2b2ljZSBub3Rlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdm9pY2UpLCBgdXBsb2FkX2RvY3VtZW50YCBmb3IgW2dlbmVyYWwgZmlsZXNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGRvY3VtZW50KSxcbiAgICogYGNob29zZV9zdGlja2VyYCBmb3IgW3N0aWNrZXJzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRzdGlja2VyKSwgYGZpbmRfbG9jYXRpb25gIGZvciBbbG9jYXRpb24gZGF0YV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kbG9jYXRpb24pLFxuICAgKiBgcmVjb3JkX3ZpZGVvX25vdGVgIG9yIGB1cGxvYWRfdmlkZW9fbm90ZWAgZm9yIFt2aWRlbyBub3Rlc10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kdmlkZW9ub3RlKS5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWN0aW9uIFR5cGUgb2YgYWN0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2VuZGNoYXRhY3Rpb25cbiAgICovXG4gIHNlbmRDaGF0QWN0aW9uKGNoYXRJZCwgYWN0aW9uLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5hY3Rpb24gPSBhY3Rpb247XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRDaGF0QWN0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGNob3NlbiByZWFjdGlvbnMgb24gYSBtZXNzYWdlLlxuICAgKiAtIFNlcnZpY2UgbWVzc2FnZXMgY2FuJ3QgYmUgcmVhY3RlZCB0by5cbiAgICogLSBBdXRvbWF0aWNhbGx5IGZvcndhcmRlZCBtZXNzYWdlcyBmcm9tIGEgY2hhbm5lbCB0byBpdHMgZGlzY3Vzc2lvbiBncm91cCBoYXZlIHRoZSBzYW1lIGF2YWlsYWJsZSByZWFjdGlvbnMgYXMgbWVzc2FnZXMgaW4gdGhlIGNoYW5uZWwuXG4gICAqIC0gSW4gYWxidW1zLCBib3RzIG11c3QgcmVhY3QgdG8gdGhlIGZpcnN0IG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgQGNoYW5uZWx1c2VybmFtZSlcbiAgICogQHBhcmFtICB7TnVtYmVyfSBtZXNzYWdlSWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRtZXNzYWdlcmVhY3Rpb25cbiAgICovXG4gIHNldE1lc3NhZ2VSZWFjdGlvbihjaGF0SWQsIG1lc3NhZ2VJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV9pZCA9IG1lc3NhZ2VJZDtcbiAgICBpZiAoZm9ybS5yZWFjdGlvbikge1xuICAgICAgZm9ybS5yZWFjdGlvbiA9IHN0cmluZ2lmeShmb3JtLnJlYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE1lc3NhZ2VSZWFjdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGEgbGlzdCBvZiBwcm9maWxlIHBpY3R1cmVzIGZvciBhIHVzZXIuXG4gICAqIFJldHVybnMgYSBbVXNlclByb2ZpbGVQaG90b3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcnByb2ZpbGVwaG90b3MpIG9iamVjdC5cbiAgICogVGhpcyBtZXRob2QgaGFzIGFuIFtvbGRlciwgY29tcGF0aWJsZSBzaWduYXR1cmVdW2dldFVzZXJQcm9maWxlUGhvdG9zLXYwLjI1LjBdXG4gICAqIHRoYXQgaXMgYmVpbmcgZGVwcmVjYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIFJldHVybnMgYSBbVXNlclByb2ZpbGVQaG90b3NdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXNlcnByb2ZpbGVwaG90b3MpIG9iamVjdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dXNlcnByb2ZpbGVwaG90b3NcbiAgICovXG4gIGdldFVzZXJQcm9maWxlUGhvdG9zKHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgLyogVGhlIG9sZGVyIG1ldGhvZCBzaWduYXR1cmUgd2FzIGdldFVzZXJQcm9maWxlUGhvdG9zKHVzZXJJZCwgb2Zmc2V0LCBsaW1pdCkuXG4gICAgICogV2UgbmVlZCB0byBlbnN1cmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICAgKiBjb25zaXN0ZW5jeSBvZiB0aGUgbWV0aG9kIHNpZ25hdHVyZXMgdGhyb3VnaG91dCB0aGUgbGlicmFyeSAqL1xuICAgIGlmICh0eXBlb2YgZm9ybSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgIGRlcHJlY2F0ZSgnVGhlIG1ldGhvZCBzaWduYXR1cmUgZ2V0VXNlclByb2ZpbGVQaG90b3ModXNlcklkLCBvZmZzZXQsIGxpbWl0KSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYwLjI1LjAnKTtcbiAgICAgIGZvcm0gPSB7XG4gICAgICAgIG9mZnNldDogYXJndW1lbnRzWzFdLFxuICAgICAgICBsaW1pdDogYXJndW1lbnRzWzJdLFxuICAgICAgfTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgIH1cbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFVzZXJQcm9maWxlUGhvdG9zJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlLlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGJhc2ljIGluZm8gYWJvdXQgYSBmaWxlIGFuZCBwcmVwYXJlIGl0IGZvciBkb3dubG9hZGluZy5cbiAgICpcbiAgICogQXR0ZW50aW9uOiAqKmxpbmsgd2lsbCBiZSB2YWxpZCBmb3IgMSBob3VyLioqXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZUlkICBGaWxlIGlkZW50aWZpZXIgdG8gZ2V0IGluZm8gYWJvdXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGEgW0ZpbGVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZmlsZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRmaWxlXG4gICAqL1xuICBnZXRGaWxlKGZpbGVJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5maWxlX2lkID0gZmlsZUlkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRGaWxlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYmFuIGEgdXNlciBpbiBhIGdyb3VwLCBhIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsLlxuICAgICogSW4gdGhlIGNhc2Ugb2Ygc3VwZXJncm91cHMgYW5kIGNoYW5uZWxzLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvXG4gICAgKiByZXR1cm4gdG8gdGhlIGNoYXQgb24gdGhlaXIgb3duIHVzaW5nIGludml0ZSBsaW5rcywgZXRjLiwgdW5sZXNzIHVuYmFubmVkIGZpcnN0Li5cbiAgICAqXG4gICAgKiBUaGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBncm91cCwgc3VwZXJncm91cCBvciBhIGNoYW5uZWwqKiBmb3IgdGhpcyB0byB3b3JrLlxuICAgICpcbiAgICAqXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzcy5cbiAgICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNiYW5jaGF0bWVtYmVyXG4gICAgKi9cbiAgYmFuQ2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYmFuQ2hhdE1lbWJlcicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmJhbiBhIHByZXZpb3VzbHkga2lja2VkIHVzZXIgaW4gYSBzdXBlcmdyb3VwLlxuICAqIFRoZSB1c2VyIHdpbGwgbm90IHJldHVybiB0byB0aGUgZ3JvdXAgYXV0b21hdGljYWxseSwgYnV0IHdpbGwgYmVcbiAgKiBhYmxlIHRvIGpvaW4gdmlhIGxpbmssIGV0Yy5cbiAgKlxuICAqIFRoZSAqKmJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IqKiBpbiB0aGUgc3VwZXJncm91cCBvciBjaGFubmVsIGZvciB0aGlzIHRvIHdvcmsuXG4gICpcbiAgKiAqKkJ5IGRlZmF1bHQqKiwgdGhpcyBtZXRob2QgZ3VhcmFudGVlcyB0aGF0IGFmdGVyIHRoZSBjYWxsIHRoZSB1c2VyIGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgY2hhdCwgYnV0IHdpbGwgYmUgYWJsZSB0byBqb2luIGl0LlxuICAqIFNvICoqaWYgdGhlIHVzZXIgaXMgYSBtZW1iZXIgb2YgdGhlIGNoYXQgdGhleSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjaGF0KiouIElmIHlvdSBkb24ndCB3YW50IHRoaXMsIHVzZSB0aGUgcGFyYW1ldGVyICpvbmx5X2lmX2Jhbm5lZCpcbiAgKlxuICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCAgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VuYmFuY2hhdG1lbWJlclxuICAqL1xuICB1bmJhbkNoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VuYmFuQ2hhdE1lbWJlcicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZXN0cmljdCBhIHVzZXIgaW4gYSBzdXBlcmdyb3VwLlxuICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIHN1cGVyZ3JvdXAqKiBmb3IgdGhpcyB0byB3b3JrXG4gICogYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLiBQYXNzIFRydWUgZm9yIGFsbCBib29sZWFuIHBhcmFtZXRlcnNcbiAgKiB0byBsaWZ0IHJlc3RyaWN0aW9ucyBmcm9tIGEgdXNlci4gUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmVzdHJpY3RjaGF0bWVtYmVyXG4gICovXG4gIHJlc3RyaWN0Q2hhdE1lbWJlcihjaGF0SWQsIHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVzdHJpY3RDaGF0TWVtYmVyJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBwcm9tb3RlIG9yIGRlbW90ZSBhIHVzZXIgaW4gYSBzdXBlcmdyb3VwIG9yIGEgY2hhbm5lbC5cbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvcioqIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmtcbiAgICogYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLiBQYXNzIEZhbHNlIGZvciBhbGwgYm9vbGVhbiBwYXJhbWV0ZXJzIHRvIGRlbW90ZSBhIHVzZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcHJvbW90ZWNoYXRtZW1iZXJcbiAgICovXG4gIHByb21vdGVDaGF0TWVtYmVyKGNoYXRJZCwgdXNlcklkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdwcm9tb3RlQ2hhdE1lbWJlcicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgY3VzdG9tIHRpdGxlIGZvciBhbiBhZG1pbmlzdHJhdG9yIGluIGEgc3VwZXJncm91cCBwcm9tb3RlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY3VzdG9tVGl0bGUgTmV3IGN1c3RvbSB0aXRsZSBmb3IgdGhlIGFkbWluaXN0cmF0b3I7IDAtMTYgY2hhcmFjdGVycywgZW1vamkgYXJlIG5vdCBhbGxvd2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRhZG1pbmlzdHJhdG9yY3VzdG9tdGl0bGVcbiAgICovXG4gIHNldENoYXRBZG1pbmlzdHJhdG9yQ3VzdG9tVGl0bGUoY2hhdElkLCB1c2VySWQsIGN1c3RvbVRpdGxlLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIGZvcm0uY3VzdG9tX3RpdGxlID0gY3VzdG9tVGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRBZG1pbmlzdHJhdG9yQ3VzdG9tVGl0bGUnLCB7IGZvcm0gfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYmFuIGEgY2hhbm5lbCBjaGF0IGluIGEgc3VwZXJncm91cCBvciBhIGNoYW5uZWwuXG4gICAqXG4gICAqIFVudGlsIHRoZSBjaGF0IGlzIFt1bmJhbm5lZF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmJhbmNoYXRzZW5kZXJjaGF0KSwgdGhlIG93bmVyIG9mIHRoZSBiYW5uZWQgY2hhdCB3b24ndCBiZSBhYmxlIHRvIHNlbmQgbWVzc2FnZXMgb24gYmVoYWxmIG9mIGFueSBvZiB0aGVpciBjaGFubmVscy5cbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgc3VwZXJncm91cCBvciBjaGFubmVsKiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0c1xuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcn0gc2VuZGVyQ2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JhbmNoYXRzZW5kZXJjaGF0XG4gICAqL1xuICBiYW5DaGF0U2VuZGVyQ2hhdChjaGF0SWQsIHNlbmRlckNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uc2VuZGVyX2NoYXRfaWQgPSBzZW5kZXJDaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2JhbkNoYXRTZW5kZXJDaGF0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIHVuYmFuIGEgcHJldmlvdXNseSBiYW5uZWQgY2hhbm5lbCBjaGF0IGluIGEgc3VwZXJncm91cCBvciBjaGFubmVsLlxuICAqXG4gICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvcioqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAqIEBwYXJhbSAge051bWJlcn0gc2VuZGVyQ2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmJhbmNoYXRzZW5kZXJjaGF0XG4gICovXG4gIHVuYmFuQ2hhdFNlbmRlckNoYXQoY2hhdElkLCBzZW5kZXJDaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnNlbmRlcl9jaGF0X2lkID0gc2VuZGVyQ2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCd1bmJhbkNoYXRTZW5kZXJDaGF0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgZGVmYXVsdCBjaGF0IHBlcm1pc3Npb25zIGZvciBhbGwgbWVtYmVycy5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgZ3JvdXAgb3IgYSBzdXBlcmdyb3VwKiogZm9yIHRoaXMgdG9cbiAgICogd29yayBhbmQgKiptdXN0IGhhdmUgdGhlIGBjYW5fcmVzdHJpY3RfbWVtYmVyc2AgYWRtaW4gcmlnaHRzLioqXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtBcnJheX0gY2hhdFBlcm1pc3Npb25zIE5ldyBkZWZhdWx0IGNoYXQgcGVybWlzc2lvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHBlcm1pc3Npb25zXG4gICAqL1xuICBzZXRDaGF0UGVybWlzc2lvbnMoY2hhdElkLCBjaGF0UGVybWlzc2lvbnMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnBlcm1pc3Npb25zID0gc3RyaW5naWZ5KGNoYXRQZXJtaXNzaW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRQZXJtaXNzaW9ucycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgYSBuZXcgcHJpbWFyeSBpbnZpdGUgbGluayBmb3IgYSBjaGF0LiAqKkFueSBwcmV2aW91c2x5IGdlbmVyYXRlZCBwcmltYXJ5IGxpbmsgaXMgcmV2b2tlZCoqLlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEV4cG9ydGVkIGludml0ZSBsaW5rIGFzIFN0cmluZyBvbiBzdWNjZXNzLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZXhwb3J0Y2hhdGludml0ZWxpbmtcbiAgICovXG4gIGV4cG9ydENoYXRJbnZpdGVMaW5rKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdleHBvcnRDaGF0SW52aXRlTGluaycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFuIGFkZGl0aW9uYWwgaW52aXRlIGxpbmsgZm9yIGEgY2hhdC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgKlxuICAgKiBUaGUgbGluayBnZW5lcmF0ZWQgd2l0aCB0aGlzIG1ldGhvZCBjYW4gYmUgcmV2b2tlZCB1c2luZyB0aGUgbWV0aG9kIFtyZXZva2VDaGF0SW52aXRlTGlua10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZXZva2VjaGF0aW52aXRlbGluaylcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBpbnZpdGUgbGluayBhcyBbQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdGludml0ZWxpbmspIG9iamVjdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY3JlYXRlY2hhdGludml0ZWxpbmtcbiAgICovXG4gIGNyZWF0ZUNoYXRJbnZpdGVMaW5rKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjcmVhdGVDaGF0SW52aXRlTGluaycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBhIG5vbi1wcmltYXJ5IGludml0ZSBsaW5rIGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogVGhlIGJvdCAqKm11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgYWRtaW4gcmlnaHRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGludml0ZUxpbmsgVGV4dCB3aXRoIHRoZSBpbnZpdGUgbGluayB0byBlZGl0XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgZWRpdGVkIGludml0ZSBsaW5rIGFzIGEgW0NoYXRJbnZpdGVMaW5rXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRpbnZpdGVsaW5rKSBvYmplY3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRjaGF0aW52aXRlbGlua1xuICAgKi9cbiAgZWRpdENoYXRJbnZpdGVMaW5rKGNoYXRJZCwgaW52aXRlTGluaywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uaW52aXRlX2xpbmsgPSBpbnZpdGVMaW5rO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0Q2hhdEludml0ZUxpbmsnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJldm9rZSBhbiBpbnZpdGUgbGluayBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqIE5vdGU6IElmIHRoZSBwcmltYXJ5IGxpbmsgaXMgcmV2b2tlZCwgYSBuZXcgbGluayBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaW52aXRlTGluayBUaGUgaW52aXRlIGxpbmsgdG8gcmV2b2tlXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmV2b2tlZCBpbnZpdGUgbGluayBhcyBbQ2hhdEludml0ZUxpbmtdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdGludml0ZWxpbmspIG9iamVjdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmV2b2tlY2hhdGludml0ZWxpbmtcbiAgICovXG4gIHJldm9rZUNoYXRJbnZpdGVMaW5rKGNoYXRJZCwgaW52aXRlTGluaywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uaW52aXRlX2xpbmsgPSBpbnZpdGVMaW5rO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZXZva2VDaGF0SW52aXRlTGluaycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gYXBwcm92ZSBhIGNoYXQgam9pbiByZXF1ZXN0LlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgKiptdXN0IGhhdmUgdGhlIGBjYW5faW52aXRlX3VzZXJzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0LioqXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYXBwcm92ZWNoYXRqb2lucmVxdWVzdFxuICAgKi9cbiAgYXBwcm92ZUNoYXRKb2luUmVxdWVzdChjaGF0SWQsIHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnYXBwcm92ZUNoYXRKb2luUmVxdWVzdCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVjbGluZSBhIGNoYXQgam9pbiByZXF1ZXN0LlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgKiptdXN0IGhhdmUgdGhlIGBjYW5faW52aXRlX3VzZXJzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0KiouXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVjbGluZWNoYXRqb2lucmVxdWVzdFxuICAgKi9cbiAgZGVjbGluZUNoYXRKb2luUmVxdWVzdChjaGF0SWQsIHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVjbGluZUNoYXRKb2luUmVxdWVzdCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgbmV3IHByb2ZpbGUgcGhvdG8gZm9yIHRoZSBjaGF0LiAqKlBob3RvcyBjYW4ndCBiZSBjaGFuZ2VkIGZvciBwcml2YXRlIGNoYXRzKiouXG4gICAqXG4gICAqIFRoZSBib3QgKiptdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQqKiBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGFkbWluIHJpZ2h0cy5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge3N0cmVhbS5TdHJlYW18QnVmZmVyfSBwaG90byBBIGZpbGUgcGF0aCBvciBhIFN0cmVhbS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y2hhdHBob3RvXG4gICAqL1xuICBzZXRDaGF0UGhvdG8oY2hhdElkLCBwaG90bywgb3B0aW9ucyA9IHt9LCBmaWxlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgIH07XG4gICAgb3B0cy5xcy5jaGF0X2lkID0gY2hhdElkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IHRoaXMuX2Zvcm1hdFNlbmREYXRhKCdwaG90bycsIHBob3RvLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnBob3RvID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0UGhvdG8nLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBjaGF0IHBob3RvLiAqKlBob3RvcyBjYW4ndCBiZSBjaGFuZ2VkIGZvciBwcml2YXRlIGNoYXRzKiouXG4gICpcbiAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlY2hhdHBob3RvXG4gICovXG4gIGRlbGV0ZUNoYXRQaG90byhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlQ2hhdFBob3RvJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIHRpdGxlIG9mIGEgY2hhdC4gKipUaXRsZXMgY2FuJ3QgYmUgY2hhbmdlZCBmb3IgcHJpdmF0ZSBjaGF0cyoqLlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIE5ldyBjaGF0IHRpdGxlLCAxLTI1NSBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXR0aXRsZVxuICAgKi9cbiAgc2V0Q2hhdFRpdGxlKGNoYXRJZCwgdGl0bGUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRUaXRsZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBkZXNjcmlwdGlvbiBvZiBhIGdyb3VwLCBhIHN1cGVyZ3JvdXAgb3IgYSBjaGFubmVsLlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbiByaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRlc2NyaXB0aW9uIE5ldyBjaGF0IHRpdGxlLCAwLTI1NSBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGNoYXRkZXNjcmlwdGlvblxuICAgKi9cbiAgc2V0Q2hhdERlc2NyaXB0aW9uKGNoYXRJZCwgZGVzY3JpcHRpb24sIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXREZXNjcmlwdGlvbicsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcGluIGEgbWVzc2FnZSBpbiBhIHN1cGVyZ3JvdXAuXG4gICAqXG4gICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgICogcmlnaHQgaW4gYSBzdXBlcmdyb3VwIG9yIGBjYW5fZWRpdF9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvciByaWdodCBpbiBhIGNoYW5uZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1lc3NhZ2VJZCBJZGVudGlmaWVyIG9mIGEgbWVzc2FnZSB0byBwaW5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcGluY2hhdG1lc3NhZ2VcbiAgICovXG4gIHBpbkNoYXRNZXNzYWdlKGNoYXRJZCwgbWVzc2FnZUlkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkID0gbWVzc2FnZUlkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdwaW5DaGF0TWVzc2FnZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVtb3ZlIGEgbWVzc2FnZSBmcm9tIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGNoYXRcbiAgICpcbiAgICogSWYgdGhlIGNoYXQgaXMgbm90IGEgcHJpdmF0ZSBjaGF0LCB0aGUgKipib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBgY2FuX3Bpbl9tZXNzYWdlc2AgYWRtaW5pc3RyYXRvclxuICAgKiByaWdodCBpbiBhIHN1cGVyZ3JvdXAgb3IgYGNhbl9lZGl0X21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0IGluIGEgY2hhbm5lbC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VucGluY2hhdG1lc3NhZ2VcbiAgICovXG4gIHVucGluQ2hhdE1lc3NhZ2UoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VucGluQ2hhdE1lc3NhZ2UnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgcGlubmVkIG1lc3NhZ2VzIGluIGEgY2hhdC5cbiAgKlxuICAqIElmIHRoZSBjaGF0IGlzIG5vdCBhIHByaXZhdGUgY2hhdCwgdGhlICoqYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCoqIGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgYGNhbl9waW5fbWVzc2FnZXNgIGFkbWluaXN0cmF0b3JcbiAgKiByaWdodCBpbiBhIHN1cGVyZ3JvdXAgb3IgYGNhbl9lZGl0X21lc3NhZ2VzYCBhZG1pbmlzdHJhdG9yIHJpZ2h0IGluIGEgY2hhbm5lbC5cbiAgKlxuICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bnBpbmFsbGNoYXRtZXNzYWdlc1xuICAqL1xuICB1bnBpbkFsbENoYXRNZXNzYWdlcyhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5waW5BbGxDaGF0TWVzc2FnZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIGZvciB5b3VyIGJvdCB0byBsZWF2ZSBhIGdyb3VwLCBzdXBlcmdyb3VwIG9yIGNoYW5uZWxcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBjaGF0IG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgY2hhbm5lbCAoaW4gdGhlIGZvcm1hdCBgQGNoYW5uZWx1c2VybmFtZWApXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2xlYXZlY2hhdFxuICAgKi9cbiAgbGVhdmVDaGF0KGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdsZWF2ZUNoYXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB1cCB0byBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGF0XG4gICAqIChjdXJyZW50IG5hbWUgb2YgdGhlIHVzZXIgZm9yIG9uZS1vbi1vbmUgY29udmVyc2F0aW9ucywgY3VycmVudFxuICAgKiB1c2VybmFtZSBvZiBhIHVzZXIsIGdyb3VwIG9yIGNoYW5uZWwsIGV0Yy4pLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKSBvciBjaGFubmVsXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBbQ2hhdEZ1bGxJbmZvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRmdWxsaW5mbykgb2JqZWN0IG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRcbiAgICovXG4gIGdldENoYXQoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCBhIGxpc3Qgb2YgYWRtaW5pc3RyYXRvcnMgaW4gYSBjaGF0XG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIGFuIEFycmF5IG9mIFtDaGF0TWVtYmVyXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRtZW1iZXIpIG9iamVjdHMgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgY2hhdCBhZG1pbmlzdHJhdG9ycyBleGNlcHQgb3RoZXIgYm90cy5cbiAgICogSWYgdGhlIGNoYXQgaXMgYSBncm91cCBvciBhIHN1cGVyZ3JvdXAgYW5kIG5vIGFkbWluaXN0cmF0b3JzIHdlcmUgYXBwb2ludGVkLCBvbmx5IHRoZSBjcmVhdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRhZG1pbmlzdHJhdG9yc1xuICAgKi9cbiAgZ2V0Q2hhdEFkbWluaXN0cmF0b3JzKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRDaGF0QWRtaW5pc3RyYXRvcnMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbWVtYmVycyBpbiBhIGNoYXQuXG4gICpcbiAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cFxuICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IEludCBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRtZW1iZXJjb3VudFxuICAqL1xuICBnZXRDaGF0TWVtYmVyQ291bnQoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXRNZW1iZXJDb3VudCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGEgbWVtYmVyIG9mIGEgY2hhdC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXBcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gW0NoYXRNZW1iZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY2hhdG1lbWJlcikgb2JqZWN0IG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRtZW1iZXJcbiAgICovXG4gIGdldENoYXRNZW1iZXIoY2hhdElkLCB1c2VySWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldENoYXRNZW1iZXInLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIG5ldyBncm91cCBzdGlja2VyIHNldCBmb3IgYSBzdXBlcmdyb3VwLlxuICAgKlxuICAgKiBUaGUgYm90ICoqbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0KiogZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBhcHByb3ByaWF0ZSBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICpcbiAgICogKipOb3RlOioqIFVzZSB0aGUgZmllbGQgYGNhbl9zZXRfc3RpY2tlcl9zZXRgIG9wdGlvbmFsbHkgcmV0dXJuZWQgaW4gW2dldENoYXRdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Y2hhdCkgcmVxdWVzdHMgdG8gY2hlY2sgaWYgdGhlIGJvdCBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlclNldE5hbWUgTmFtZSBvZiB0aGUgc3RpY2tlciBzZXQgdG8gYmUgc2V0IGFzIHRoZSBncm91cCBzdGlja2VyIHNldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0c3RpY2tlcnNldFxuICAgKi9cbiAgc2V0Q2hhdFN0aWNrZXJTZXQoY2hhdElkLCBzdGlja2VyU2V0TmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0uc3RpY2tlcl9zZXRfbmFtZSA9IHN0aWNrZXJTZXROYW1lO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRDaGF0U3RpY2tlclNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBncm91cCBzdGlja2VyIHNldCBmcm9tIGEgc3VwZXJncm91cC5cbiAgICpcbiAgICogVXNlIHRoZSBmaWVsZCBgY2FuX3NldF9zdGlja2VyX3NldGAgb3B0aW9uYWxseSByZXR1cm5lZCBpbiBbZ2V0Q2hhdF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRjaGF0KSByZXF1ZXN0cyB0byBjaGVjayBpZiB0aGUgYm90IGNhbiB1c2UgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlY2hhdHN0aWNrZXJzZXRcbiAgICovXG4gIGRlbGV0ZUNoYXRTdGlja2VyU2V0KGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVDaGF0U3RpY2tlclNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGN1c3RvbSBlbW9qaSBzdGlja2Vycywgd2hpY2ggY2FuIGJlIHVzZWQgYXMgYSBmb3J1bSB0b3BpYyBpY29uIGJ5IGFueSB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBcnJheSBvZiBbU3RpY2tlcl0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdGlja2VyKSBvYmplY3RzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRmb3J1bXRvcGljaWNvbnN0aWNrZXJzXG4gICAqL1xuICBnZXRGb3J1bVRvcGljSWNvblN0aWNrZXJzKGNoYXRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRGb3J1bVRvcGljSWNvblN0aWNrZXJzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYSB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICpcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3JlYXRlZCB0b3BpYyBhcyBhIFtGb3J1bVRvcGljXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZvcnVtdG9waWMpIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgVG9waWMgbmFtZSwgMS0xMjggY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NyZWF0ZWZvcnVtdG9waWNcbiAgICovXG4gIGNyZWF0ZUZvcnVtVG9waWMoY2hhdElkLCBuYW1lLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY3JlYXRlRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBuYW1lIGFuZCBpY29uIG9mIGEgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cywgdW5sZXNzIGl0IGlzIHRoZSBjcmVhdG9yIG9mIHRoZSB0b3BpYy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZWRpdGZvcnVtdG9waWNcbiAgICovXG4gIGVkaXRGb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdEZvcnVtVG9waWMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsb3NlIGFuIG9wZW4gdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMsIHVubGVzcyBpdCBpcyB0aGUgY3JlYXRvciBvZiB0aGUgdG9waWMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Nsb3NlZm9ydW10b3BpY1xuICAgKi9cbiAgY2xvc2VGb3J1bVRvcGljKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY2xvc2VGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZW9wZW4gYSBjbG9zZWQgdG9waWMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMsIHVubGVzcyBpdCBpcyB0aGUgY3JlYXRvciBvZiB0aGUgdG9waWMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZVRocmVhZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IG1lc3NhZ2UgdGhyZWFkIG9mIHRoZSBmb3J1bSB0b3BpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3Jlb3BlbmZvcnVtdG9waWNcbiAgICovXG4gIHJlb3BlbkZvcnVtVG9waWMoY2hhdElkLCBtZXNzYWdlVGhyZWFkSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfdGhyZWFkX2lkID0gbWVzc2FnZVRocmVhZElkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdyZW9wZW5Gb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBmb3J1bSB0b3BpYyBhbG9uZyB3aXRoIGFsbCBpdHMgbWVzc2FnZXMgaW4gYSBmb3J1bSBzdXBlcmdyb3VwIGNoYXQuXG4gICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX2RlbGV0ZV9tZXNzYWdlcyBhZG1pbmlzdHJhdG9yIHJpZ2h0cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlZm9ydW10b3BpY1xuICAgKi9cbiAgZGVsZXRlRm9ydW1Ub3BpYyhjaGF0SWQsIG1lc3NhZ2VUaHJlYWRJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubWVzc2FnZV90aHJlYWRfaWQgPSBtZXNzYWdlVGhyZWFkSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZUZvcnVtVG9waWMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNsZWFyIHRoZSBsaXN0IG9mIHBpbm5lZCBtZXNzYWdlcyBpbiBhIGZvcnVtIHRvcGljLlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9waW5fbWVzc2FnZXMgYWRtaW5pc3RyYXRvciByaWdodCBpbiB0aGUgc3VwZXJncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtZXNzYWdlVGhyZWFkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgbWVzc2FnZSB0aHJlYWQgb2YgdGhlIGZvcnVtIHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5waW5hbGxmb3J1bXRvcGljbWVzc2FnZXNcbiAgICovXG4gIHVucGluQWxsRm9ydW1Ub3BpY01lc3NhZ2VzKGNoYXRJZCwgbWVzc2FnZVRocmVhZElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX3RocmVhZF9pZCA9IG1lc3NhZ2VUaHJlYWRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndW5waW5BbGxGb3J1bVRvcGljTWVzc2FnZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCB0aGUgbmFtZSBvZiB0aGUgJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICogVGhlIHRvcGljIHdpbGwgYmUgYXV0b21hdGljYWxseSB1bmhpZGRlbiBpZiBpdCB3YXMgaGlkZGVuLlxuICAqXG4gICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmV3IHRvcGljIG5hbWUsIDEtMTI4IGNoYXJhY3RlcnNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0Z2VuZXJhbGZvcnVtdG9waWNcbiAgKi9cbiAgZWRpdEdlbmVyYWxGb3J1bVRvcGljKGNoYXRJZCwgbmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2VkaXRHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbG9zZSBhbiBvcGVuICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdW5oaWRkZW4gaWYgaXQgd2FzIGhpZGRlbi5cbiAgKlxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGdyb3VwIG9yIHVzZXJuYW1lIG9mIHRoZSB0YXJnZXQgc3VwZXJncm91cCAoaW4gdGhlIGZvcm1hdCBAc3VwZXJncm91cHVzZXJuYW1lKVxuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Nsb3NlZ2VuZXJhbGZvcnVtdG9waWNcbiAgKi9cbiAgY2xvc2VHZW5lcmFsRm9ydW1Ub3BpYyhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnY2xvc2VHZW5lcmFsRm9ydW1Ub3BpYycsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZW9wZW4gYSBjbG9zZWQgJ0dlbmVyYWwnIHRvcGljIGluIGEgZm9ydW0gc3VwZXJncm91cCBjaGF0LlxuICAqIFRoZSBib3QgbXVzdCBiZSBhbiBhZG1pbmlzdHJhdG9yIGluIHRoZSBjaGF0IGZvciB0aGlzIHRvIHdvcmsgYW5kIG11c3QgaGF2ZSB0aGUgY2FuX21hbmFnZV90b3BpY3MgYWRtaW5pc3RyYXRvciByaWdodHMuXG4gICogVGhlIHRvcGljIHdpbGwgYmUgYXV0b21hdGljYWxseSB1bmhpZGRlbiBpZiBpdCB3YXMgaGlkZGVuLlxuICAqXG4gICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjcmVvcGVuZ2VuZXJhbGZvcnVtdG9waWNcbiAgKi9cbiAgcmVvcGVuR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3Jlb3BlbkdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIGhpZGUgdGhlICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9tYW5hZ2VfdG9waWNzIGFkbWluaXN0cmF0b3IgcmlnaHRzLlxuICAqIFRoZSB0b3BpYyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkIGlmIGl0IHdhcyBvcGVuLlxuICAqXG4gICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjaGlkZWdlbmVyYWxmb3J1bXRvcGljXG4gICovXG4gIGhpZGVHZW5lcmFsRm9ydW1Ub3BpYyhjaGF0SWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnaGlkZUdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byB1bmhpZGUgdGhlICdHZW5lcmFsJyB0b3BpYyBpbiBhIGZvcnVtIHN1cGVyZ3JvdXAgY2hhdC5cbiAgICogVGhlIGJvdCBtdXN0IGJlIGFuIGFkbWluaXN0cmF0b3IgaW4gdGhlIGNoYXQgZm9yIHRoaXMgdG8gd29yayBhbmQgbXVzdCBoYXZlIHRoZSBjYW5fbWFuYWdlX3RvcGljcyBhZG1pbmlzdHJhdG9yIHJpZ2h0c1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGNoYXRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRhcmdldCBncm91cCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IHN1cGVyZ3JvdXAgKGluIHRoZSBmb3JtYXQgQHN1cGVyZ3JvdXB1c2VybmFtZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1bmhpZGVnZW5lcmFsZm9ydW10b3BpY1xuICAgKi9cbiAgdW5oaWRlR2VuZXJhbEZvcnVtVG9waWMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VuaGlkZUdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjbGVhciB0aGUgbGlzdCBvZiBwaW5uZWQgbWVzc2FnZXMgaW4gYSBHZW5lcmFsIGZvcnVtIHRvcGljLlxuICAgKiBUaGUgYm90IG11c3QgYmUgYW4gYWRtaW5pc3RyYXRvciBpbiB0aGUgY2hhdCBmb3IgdGhpcyB0byB3b3JrIGFuZCBtdXN0IGhhdmUgdGhlIGNhbl9waW5fbWVzc2FnZXMgYWRtaW5pc3RyYXRvciByaWdodCBpbiB0aGUgc3VwZXJncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgZ3JvdXAgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBzdXBlcmdyb3VwIChpbiB0aGUgZm9ybWF0IEBzdXBlcmdyb3VwdXNlcm5hbWUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdW5waW5hbGxnZW5lcmFsZm9ydW10b3BpY21lc3NhZ2VzXG4gICAqL1xuICB1bnBpbkFsbEdlbmVyYWxGb3J1bVRvcGljTWVzc2FnZXMoY2hhdElkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3VuaGlkZUdlbmVyYWxGb3J1bVRvcGljJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuc3dlcnMgdG8gY2FsbGJhY2sgcXVlcmllcyBzZW50IGZyb21cbiAgICogW2lubGluZSBrZXlib2FyZHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cyNpbmxpbmUta2V5Ym9hcmRzLWFuZC1vbi10aGUtZmx5LXVwZGF0aW5nKS5cbiAgICpcbiAgICogVGhlIGFuc3dlciB3aWxsIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhcyBhIG5vdGlmaWNhdGlvbiBhdCB0aGUgdG9wIG9mIHRoZSBjaGF0IHNjcmVlbiBvciBhcyBhbiBhbGVydC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzICoqb2xkZXIsIGNvbXBhdGlibGUgc2lnbmF0dXJlcyAoWzFdW2Fuc3dlckNhbGxiYWNrUXVlcnktdjAuMjcuMV0pKFsyXVthbnN3ZXJDYWxsYmFja1F1ZXJ5LXYwLjI5LjBdKSoqXG4gICAqIHRoYXQgYXJlIGJlaW5nIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY2FsbGJhY2tRdWVyeUlkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2VyY2FsbGJhY2txdWVyeVxuICAgKi9cbiAgYW5zd2VyQ2FsbGJhY2tRdWVyeShjYWxsYmFja1F1ZXJ5SWQsIGZvcm0gPSB7fSkge1xuICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIChpbi9iZWZvcmUgdjAuMjcuMSkgd2FzIGFuc3dlckNhbGxiYWNrUXVlcnkoY2FsbGJhY2tRdWVyeUlkLCB0ZXh0LCBzaG93QWxlcnQpLlxuICAgICAqIFdlIG5lZWQgdG8gZW5zdXJlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdoaWxlIG1haW50YWluaW5nXG4gICAgICogY29uc2lzdGVuY3kgb2YgdGhlIG1ldGhvZCBzaWduYXR1cmVzIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkgKi9cbiAgICBpZiAodHlwZW9mIGZvcm0gIT09ICdvYmplY3QnKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICBkZXByZWNhdGUoJ1RoZSBtZXRob2Qgc2lnbmF0dXJlIGFuc3dlckNhbGxiYWNrUXVlcnkoY2FsbGJhY2tRdWVyeUlkLCB0ZXh0LCBzaG93QWxlcnQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjAuMjcuMScpO1xuICAgICAgZm9ybSA9IHtcbiAgICAgICAgY2FsbGJhY2tfcXVlcnlfaWQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgdGV4dDogYXJndW1lbnRzWzFdLFxuICAgICAgICBzaG93X2FsZXJ0OiBhcmd1bWVudHNbMl0sXG4gICAgICB9O1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgfVxuICAgIC8qIFRoZSBvbGRlciBtZXRob2Qgc2lnbmF0dXJlIChpbi9iZWZvcmUgdjAuMjkuMCkgd2FzIGFuc3dlckNhbGxiYWNrUXVlcnkoW29wdGlvbnNdKS5cbiAgICAgKiBXZSBuZWVkIHRvIGVuc3VyZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAqIGNvbnNpc3RlbmN5IG9mIHRoZSBtZXRob2Qgc2lnbmF0dXJlcyB0aHJvdWdob3V0IHRoZSBsaWJyYXJ5LiAqL1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2tRdWVyeUlkID09PSAnb2JqZWN0Jykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgZGVwcmVjYXRlKCdUaGUgbWV0aG9kIHNpZ25hdHVyZSBhbnN3ZXJDYWxsYmFja1F1ZXJ5KFtvcHRpb25zXSkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2MC4yOS4wJyk7XG4gICAgICBmb3JtID0gY2FsbGJhY2tRdWVyeUlkO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm0uY2FsbGJhY2tfcXVlcnlfaWQgPSBjYWxsYmFja1F1ZXJ5SWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJDYWxsYmFja1F1ZXJ5JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGxpc3Qgb2YgYm9vc3RzIGFkZGVkIHRvIGEgY2hhdCBieSBhIHVzZS5cbiAgICogUmVxdWlyZXMgYWRtaW5pc3RyYXRvciByaWdodHMgaW4gdGhlIGNoYXRcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwL2NoYW5uZWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyX2lkIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgcmV0dXJucyBhIFtVc2VyQ2hhdEJvb3N0c10oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSN1c2VyY2hhdGJvb3N0cykgb2JqZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXR1c2VyY2hhdGJvb3N0c1xuICAgKi9cbiAgZ2V0VXNlckNoYXRCb29zdHMoY2hhdElkLCBwb2xsSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWQgPSBwb2xsSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldFVzZXJDaGF0Qm9vc3RzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbm5lY3Rpb24gb2YgdGhlIGJvdCB3aXRoIGEgYnVzaW5lc3MgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBidXNpbmVzc0Nvbm5lY3Rpb25JZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBncm91cC9jaGFubmVsXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCByZXR1cm5zIFtCdXNpbmVzc0Nvbm5lY3Rpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYnVzaW5lc3Njb25uZWN0aW9uKSBvYmplY3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGJ1c2luZXNzY29ubmVjdGlvblxuICAgKi9cbiAgZ2V0QnVzaW5lc3NDb25uZWN0aW9uKGJ1c2luZXNzQ29ubmVjdGlvbklkLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmJ1c2luZXNzX2Nvbm5lY3Rpb25faWQgPSBidXNpbmVzc0Nvbm5lY3Rpb25JZDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0QnVzaW5lc3NDb25uZWN0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzLlxuICAgKlxuICAgKiBTZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzI2NvbW1hbmRzIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgYm90IGNvbW1hbmRzXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyAgTGlzdCBvZiBib3QgY29tbWFuZHMgdG8gYmUgc2V0IGFzIHRoZSBsaXN0IG9mIHRoZSBbYm90J3MgY29tbWFuZHNdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90Y29tbWFuZCkuIEF0IG1vc3QgMTAwIGNvbW1hbmRzIGNhbiBiZSBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15Y29tbWFuZHNcbiAgICovXG4gIHNldE15Q29tbWFuZHMoY29tbWFuZHMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY29tbWFuZHMgPSBzdHJpbmdpZnkoY29tbWFuZHMpO1xuXG4gICAgaWYgKGZvcm0uc2NvcGUpIHtcbiAgICAgIGZvcm0uc2NvcGUgPSBzdHJpbmdpZnkoZm9ybS5zY29wZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15Q29tbWFuZHMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSB0aGUgbGlzdCBvZiB0aGUgYm90J3MgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiBzY29wZSBhbmQgdXNlciBsYW5ndWFnZS5cbiAgICpcbiAgICogIEFmdGVyIGRlbGV0aW9uLCBbaGlnaGVyIGxldmVsIGNvbW1hbmRzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RldGVybWluaW5nLWxpc3Qtb2YtY29tbWFuZHMpIHdpbGwgYmUgc2hvd24gdG8gYWZmZWN0ZWQgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZW15Y29tbWFuZHNcbiAgICovXG4gIGRlbGV0ZU15Q29tbWFuZHMoZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZU15Q29tbWFuZHMnLCB7IGZvcm0gfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGxpc3Qgb2YgdGhlIGJvdCdzIGNvbW1hbmRzIGZvciB0aGUgZ2l2ZW4gc2NvcGUgYW5kIHVzZXIgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBcnJheSBvZiBbQm90Q29tbWFuZF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNib3Rjb21tYW5kKSBvbiBzdWNjZXNzLiBJZiBjb21tYW5kcyBhcmVuJ3Qgc2V0LCBhbiBlbXB0eSBsaXN0IGlzIHJldHVybmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0bXljb21tYW5kc1xuICAgKi9cbiAgZ2V0TXlDb21tYW5kcyhmb3JtID0ge30pIHtcbiAgICBpZiAoZm9ybS5zY29wZSkge1xuICAgICAgZm9ybS5zY29wZSA9IHN0cmluZ2lmeShmb3JtLnNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldE15Q29tbWFuZHMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3MgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0bXluYW1lXG4gICAqL1xuICBzZXRNeU5hbWUoZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15TmFtZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IHRoZSBjdXJyZW50IGJvdCBuYW1lIGZvciB0aGUgZ2l2ZW4gdXNlciBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFtCb3ROYW1lXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2JvdG5hbWUpIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldG15bmFtZVxuICAgKi9cbiAgZ2V0TXlOYW1lKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeU5hbWUnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3MgZGVzY3JpcHRpb24sIHdoaWNoIGlzIHNob3duIGluIHRoZSBjaGF0IHdpdGggdGhlIGJvdCBpZiB0aGUgY2hhdCBpcyBlbXB0eS5cbiAgICpcbiAgICogUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldG15ZGVzY3JpcHRpb25cbiAgICovXG4gIHNldE15RGVzY3JpcHRpb24oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldE15RGVzY3JpcHRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGdldCB0aGUgY3VycmVudCBib3QgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiB1c2VyIGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBbQm90RGVzY3JpcHRpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90ZGVzY3JpcHRpb24pIG9uIHN1Y2Nlc3MuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteWRlc2NyaXB0aW9uXG4gICAqL1xuICBnZXRNeURlc2NyaXB0aW9uKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeURlc2NyaXB0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGJvdCdzIHNob3J0IGRlc2NyaXB0aW9uLCB3aGljaCBpcyBzaG93biBvbiB0aGUgYm90J3MgcHJvZmlsZSBwYWdlXG4gICAqIGFuZCBpcyBzZW50IHRvZ2V0aGVyIHdpdGggdGhlIGxpbmsgd2hlbiB1c2VycyBzaGFyZSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRteXNob3J0ZGVzY3JpcHRpb25cbiAgICovXG4gIHNldE15U2hvcnREZXNjcmlwdGlvbihmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0TXlTaG9ydERlc2NyaXB0aW9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgYm90IHNob3J0IGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gdXNlciBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgW0JvdFNob3J0RGVzY3JpcHRpb25dKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYm90c2hvcnRkZXNjcmlwdGlvbikgb24gc3VjY2Vzcy5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldG15c2hvcnRkZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0TXlTaG9ydERlc2NyaXB0aW9uKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeVNob3J0RGVzY3JpcHRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYm90J3MgbWVudSBidXR0b24gaW4gYSBwcml2YXRlIGNoYXQsIG9yIHRoZSBkZWZhdWx0IG1lbnUgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRjaGF0bWVudWJ1dHRvblxuICAgKi9cbiAgc2V0Q2hhdE1lbnVCdXR0b24oZm9ybSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldENoYXRNZW51QnV0dG9uJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvdCdzIG1lbnUgYnV0dG9uIGluIGEgcHJpdmF0ZSBjaGF0LCBvciB0aGUgZGVmYXVsdCBtZW51IGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFtNZW51QnV0dG9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lbnVidXR0b24pIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRtZW51YnV0dG9uXG4gICAqL1xuICBnZXRDaGF0TWVudUJ1dHRvbihmb3JtID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0Q2hhdE1lbnVCdXR0b24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBhZG1pbmlzdHJhdG9yIHJpZ2h0cyByZXF1ZXN0ZWQgYnkgdGhlIGJvdCB3aGVuIGl0J3MgYWRkZWQgYXMgYW4gYWRtaW5pc3RyYXRvciB0byBncm91cHMgb3IgY2hhbm5lbHMuXG4gICAqXG4gICAqIFRoZXNlIHJpZ2h0cyB3aWxsIGJlIHN1Z2dlc3RlZCB0byB1c2VycywgYnV0IHRoZXkgYXJlIGFyZSBmcmVlIHRvIG1vZGlmeSB0aGUgbGlzdCBiZWZvcmUgYWRkaW5nIHRoZSBib3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGNoYXRtZW51YnV0dG9uXG4gICAqL1xuICBzZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgZGVmYXVsdCBhZG1pbmlzdHJhdG9yIHJpZ2h0cyBvZiB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gW0NoYXRBZG1pbmlzdHJhdG9yUmlnaHRzXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2NoYXRhZG1pbmlzdHJhdG9ycmlnaHRzKSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNnZXRteWRlZmF1bHRhZG1pbmlzdHJhdG9ycmlnaHRzXG4gICAqL1xuICBnZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzKGZvcm0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRNeURlZmF1bHRBZG1pbmlzdHJhdG9yUmlnaHRzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBlZGl0IHRleHQgb3IgW2dhbWVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2FtZXMpIG1lc3NhZ2VzIHNlbnQgYnkgdGhlIGJvdCBvciB2aWEgdGhlIGJvdCAoZm9yIGlubGluZSBib3RzKS5cbiAgICpcbiAgICogTm90ZTogdGhhdCAqKnlvdSBtdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkKiogaW4geW91ciByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHQgIE5ldyB0ZXh0IG9mIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZXRleHRcbiAgICovXG4gIGVkaXRNZXNzYWdlVGV4dCh0ZXh0LCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnRleHQgPSB0ZXh0O1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZVRleHQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgY2FwdGlvbnMgb2YgbWVzc2FnZXMgc2VudCBieSB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgKlxuICAgKiBOb3RlOiBZb3UgKiptdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkKiogaW4geW91ciByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNhcHRpb24gIE5ldyBjYXB0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZWNhcHRpb25cbiAgICovXG4gIGVkaXRNZXNzYWdlQ2FwdGlvbihjYXB0aW9uLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNhcHRpb24gPSBjYXB0aW9uO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZUNhcHRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGVkaXQgYW5pbWF0aW9uLCBhdWRpbywgZG9jdW1lbnQsIHBob3RvLCBvciB2aWRlbyBtZXNzYWdlcy5cbiAgICpcbiAgICogSWYgYSBtZXNzYWdlIGlzIGEgcGFydCBvZiBhIG1lc3NhZ2UgYWxidW0sIHRoZW4gaXQgY2FuIGJlIGVkaXRlZCBvbmx5IHRvIGEgcGhvdG8gb3IgYSB2aWRlby5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBtZXNzYWdlIHR5cGUgY2FuIGJlIGNoYW5nZWQgYXJiaXRyYXJpbHkuIFdoZW4gaW5saW5lIG1lc3NhZ2UgaXMgZWRpdGVkLCBuZXcgZmlsZSBjYW4ndCBiZSB1cGxvYWRlZC5cbiAgICogVXNlIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSB2aWEgaXRzIGZpbGVfaWQgb3Igc3BlY2lmeSBhIFVSTC5cbiAgICpcbiAgICogTm90ZTogWW91ICoqbXVzdCBwcm92aWRlIG9uZSBvZiBjaGF0X2lkLCBtZXNzYWdlX2lkLCBvciBpbmxpbmVfbWVzc2FnZV9pZCoqIGluIHlvdXIgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtZWRpYSAgQSBKU09OLXNlcmlhbGl6ZWQgb2JqZWN0IGZvciBhIG5ldyBtZWRpYSBjb250ZW50IG9mIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9ucyAocHJvdmlkZSBlaXRoZXIgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkIGhlcmUpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIGlmIHRoZSBlZGl0ZWQgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBlZGl0ZWQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBUcnVlIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNlZGl0bWVzc2FnZW1lZGlhXG4gICAqL1xuICBlZGl0TWVzc2FnZU1lZGlhKG1lZGlhLCBmb3JtID0ge30pIHtcbiAgICBjb25zdCByZWdleEF0dGFjaCA9IC9hdHRhY2g6XFwvXFwvLisvO1xuXG4gICAgaWYgKHR5cGVvZiBtZWRpYS5tZWRpYSA9PT0gJ3N0cmluZycgJiYgcmVnZXhBdHRhY2gudGVzdChtZWRpYS5tZWRpYSkpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIHFzOiBmb3JtLFxuICAgICAgfTtcblxuICAgICAgb3B0cy5mb3JtRGF0YSA9IHt9O1xuXG4gICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgbWVkaWEpO1xuICAgICAgZGVsZXRlIHBheWxvYWQubWVkaWE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaE5hbWUgPSBTdHJpbmcoMCk7XG4gICAgICAgIGNvbnN0IFtmb3JtRGF0YV0gPSB0aGlzLl9mb3JtYXRTZW5kRGF0YShcbiAgICAgICAgICBhdHRhY2hOYW1lLFxuICAgICAgICAgIG1lZGlhLm1lZGlhLnJlcGxhY2UoJ2F0dGFjaDovLycsICcnKSxcbiAgICAgICAgICBtZWRpYS5maWxlT3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChmb3JtRGF0YSkge1xuICAgICAgICAgIG9wdHMuZm9ybURhdGFbYXR0YWNoTmFtZV0gPSBmb3JtRGF0YVthdHRhY2hOYW1lXTtcbiAgICAgICAgICBwYXlsb2FkLm1lZGlhID0gYGF0dGFjaDovLyR7YXR0YWNoTmFtZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuRmF0YWxFcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgdGhlIHJlcGxhY2VtZW50IGFjdGlvbiBmb3IgeW91ciAke21lZGlhLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgICB9XG5cbiAgICAgIG9wdHMucXMubWVkaWEgPSBzdHJpbmdpZnkocGF5bG9hZCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdlZGl0TWVzc2FnZU1lZGlhJywgb3B0cyk7XG4gICAgfVxuXG4gICAgZm9ybS5tZWRpYSA9IHN0cmluZ2lmeShtZWRpYSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VNZWRpYScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZWRpdCBvbmx5IHRoZSByZXBseSBtYXJrdXAgb2YgbWVzc2FnZXMgc2VudCBieSB0aGUgYm90IG9yIHZpYSB0aGUgYm90IChmb3IgaW5saW5lIGJvdHMpLlxuICAgKlxuICAgKiBOb3RlOiBZb3UgKiptdXN0IHByb3ZpZGUgb25lIG9mIGNoYXRfaWQsIG1lc3NhZ2VfaWQsIG9yIGlubGluZV9tZXNzYWdlX2lkKiogaW4geW91ciByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlcGx5TWFya3VwICBBIEpTT04tc2VyaWFsaXplZCBvYmplY3QgZm9yIGFuIGlubGluZSBrZXlib2FyZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zIChwcm92aWRlIGVpdGhlciBvbmUgb2YgY2hhdF9pZCwgbWVzc2FnZV9pZCwgb3IgaW5saW5lX21lc3NhZ2VfaWQgaGVyZSlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgaWYgdGhlIGVkaXRlZCBtZXNzYWdlIGlzIG5vdCBhbiBpbmxpbmUgbWVzc2FnZSwgdGhlIGVkaXRlZCBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2VkaXRtZXNzYWdldGV4dFxuICAgKi9cbiAgZWRpdE1lc3NhZ2VSZXBseU1hcmt1cChyZXBseU1hcmt1cCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5yZXBseV9tYXJrdXAgPSByZXBseU1hcmt1cDtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZWRpdE1lc3NhZ2VSZXBseU1hcmt1cCcsIHsgZm9ybSB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzdG9wIGEgcG9sbCB3aGljaCB3YXMgc2VudCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAvY2hhbm5lbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBvbGxJZCBJZGVudGlmaWVyIG9mIHRoZSBvcmlnaW5hbCBtZXNzYWdlIHdpdGggdGhlIHBvbGxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzdG9wcGVkIFtQb2xsXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3BvbGwpIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdG9wcG9sbFxuICAgKi9cbiAgc3RvcFBvbGwoY2hhdElkLCBwb2xsSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWQgPSBwb2xsSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3N0b3BQb2xsJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIHN0YXRpYyAuV0VCUCwgW2FuaW1hdGVkXShodHRwczovL3RlbGVncmFtLm9yZy9ibG9nL2FuaW1hdGVkLXN0aWNrZXJzKSAuVEdTLFxuICAgKiBvciBbdmlkZW9dKGh0dHBzOi8vdGVsZWdyYW0ub3JnL2Jsb2cvdmlkZW8tc3RpY2tlcnMtYmV0dGVyLXJlYWN0aW9ucykgLldFQk0gc3RpY2tlcnMuXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHN0aWNrZXIgQSBmaWxlIHBhdGgsIFN0cmVhbSBvciBCdWZmZXIuXG4gICAqIENhbiBhbHNvIGJlIGEgYGZpbGVfaWRgIHByZXZpb3VzbHkgdXBsb2FkZWQuIFN0aWNrZXJzIGFyZSBXZWJQIGZvcm1hdCBmaWxlcy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kc3RpY2tlclxuICAgKi9cbiAgc2VuZFN0aWNrZXIoY2hhdElkLCBzdGlja2VyLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9O1xuICAgIG9wdHMucXMuY2hhdF9pZCA9IGNoYXRJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnc3RpY2tlcicsIHN0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMuc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2VuZFN0aWNrZXInLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGEgc3RpY2tlciBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBzdGlja2VyIHNldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgYSBbU3RpY2tlclNldF0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzdGlja2Vyc2V0KSBvYmplY3QgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHN0aWNrZXJzZXRcbiAgICovXG4gIGdldFN0aWNrZXJTZXQobmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZ2V0U3RpY2tlclNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGN1c3RvbSBlbW9qaSBzdGlja2VycyBieSB0aGVpciBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGN1c3RvbV9lbW9qaV9pZHMgTGlzdCBvZiBjdXN0b20gZW1vamkgaWRlbnRpZmllcnMuIEF0IG1vc3QgMjAwIGN1c3RvbSBlbW9qaSBpZGVudGlmaWVycyBjYW4gYmUgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQXJyYXkgb2YgW1N0aWNrZXJdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc3RpY2tlcikgb2JqZWN0cy5cbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldGN1c3RvbWVtb2ppc3RpY2tlcnNcbiAgICovXG4gIGdldEN1c3RvbUVtb2ppU3RpY2tlcnMoY3VzdG9tRW1vamlJZHMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY3VzdG9tX2Vtb2ppX2lkcyA9IHN0cmluZ2lmeShjdXN0b21FbW9qaUlkcyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldEN1c3RvbUVtb2ppU3RpY2tlcnMnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHVwbG9hZCBhIGZpbGUgd2l0aCBhIHN0aWNrZXIgZm9yIGxhdGVyIHVzZSBpbiAqY3JlYXRlTmV3U3RpY2tlclNldCogYW5kICphZGRTdGlja2VyVG9TZXQqIG1ldGhvZHMgKGNhbiBiZSB1c2VkIG11bHRpcGxlXG4gICAqIHRpbWVzKS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVXNlciBpZGVudGlmaWVyIG9mIHN0aWNrZXIgZmlsZSBvd25lclxuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHN0aWNrZXIgQSBmaWxlIHBhdGggb3IgYSBTdHJlYW0gd2l0aCB0aGUgc3RpY2tlciBpbiAuV0VCUCwgLlBORywgLlRHUywgb3IgLldFQk0gZm9ybWF0LiBDYW4gYWxzbyBiZSBhIGBmaWxlX2lkYCBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RpY2tlckZvcm1hdCBBbGxvdyB2YWx1ZXM6ICBgc3RhdGljYCwgYGFuaW1hdGVkYCBvciBgdmlkZW9gXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtmaWxlT3B0aW9uc10gT3B0aW9uYWwgZmlsZSByZWxhdGVkIG1ldGEtZGF0YVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtGaWxlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2ZpbGUpIG9iamVjdCBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBsb2Fkc3RpY2tlcmZpbGVcbiAgICovXG4gIHVwbG9hZFN0aWNrZXJGaWxlKHVzZXJJZCwgc3RpY2tlciwgc3RpY2tlckZvcm1hdCA9ICdzdGF0aWMnLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgfTtcbiAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgb3B0cy5xcy5zdGlja2VyX2Zvcm1hdCA9IHN0aWNrZXJGb3JtYXQ7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgnc3RpY2tlcicsIHN0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXMuc3RpY2tlciA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgndXBsb2FkU3RpY2tlckZpbGUnLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIG5ldyBzdGlja2VyIHNldCBvd25lZCBieSBhIHVzZXIuXG4gICAqXG4gICAqIFRoZSBib3Qgd2lsbCBiZSBhYmxlIHRvIGVkaXQgdGhlIGNyZWF0ZWQgc3RpY2tlciBzZXQuXG4gICAqXG4gICAqIFlvdSBtdXN0IHVzZSBleGFjdGx5IG9uZSBvZiB0aGUgZmllbGRzICpwbmdfc3RpY2tlciosICp0Z3Nfc3RpY2tlciosIG9yICp3ZWJtX3N0aWNrZXIqXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkIFVzZXIgaWRlbnRpZmllciBvZiBjcmVhdGVkIHN0aWNrZXIgc2V0IG93bmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTaG9ydCBuYW1lIG9mIHN0aWNrZXIgc2V0LCB0byBiZSB1c2VkIGluIGB0Lm1lL2FkZHN0aWNrZXJzL2AgVVJMcyAoZS5nLiwgICAqXCJhbmltYWxzXCIqKS4gQ2FuIGNvbnRhaW4gb25seSBlbmdsaXNoIGxldHRlcnMsIGRpZ2l0cyBhbmQgdW5kZXJzY29yZXMuXG4gICAqICBNdXN0IGJlZ2luIHdpdGggYSBsZXR0ZXIsIGNhbid0IGNvbnRhaW4gY29uc2VjdXRpdmUgdW5kZXJzY29yZXMgYW5kIG11c3QgZW5kIGluIGBcIl9ieV88Ym90X3VzZXJuYW1lPlwiYC4gYDxib3RfdXNlcm5hbWU+YCBpcyBjYXNlIGluc2Vuc2l0aXZlLiAxLTY0IGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdGl0bGUgU3RpY2tlciBzZXQgdGl0bGUsIDEtNjQgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd8c3RyZWFtLlN0cmVhbXxCdWZmZXJ9IHBuZ1N0aWNrZXIgUG5nIGltYWdlIHdpdGggdGhlIHN0aWNrZXIsIG11c3QgYmUgdXAgdG8gNTEyIGtpbG9ieXRlcyBpbiBzaXplLFxuICAgKiAgZGltZW5zaW9ucyBtdXN0IG5vdCBleGNlZWQgNTEycHgsIGFuZCBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG11c3QgYmUgZXhhY3RseSA1MTJweC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbW9qaXMgT25lIG9yIG1vcmUgZW1vamkgY29ycmVzcG9uZGluZyB0byB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY3JlYXRlbmV3c3RpY2tlcnNldFxuICAgKi9cbiAgY3JlYXRlTmV3U3RpY2tlclNldCh1c2VySWQsIG5hbWUsIHRpdGxlLCBwbmdTdGlja2VyLCBlbW9qaXMsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMudXNlcl9pZCA9IHVzZXJJZDtcbiAgICBvcHRzLnFzLm5hbWUgPSBuYW1lO1xuICAgIG9wdHMucXMudGl0bGUgPSB0aXRsZTtcbiAgICBvcHRzLnFzLmVtb2ppcyA9IGVtb2ppcztcbiAgICBvcHRzLnFzLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkob3B0aW9ucy5tYXNrX3Bvc2l0aW9uKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgncG5nX3N0aWNrZXInLCBwbmdTdGlja2VyLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnBuZ19zdGlja2VyID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdjcmVhdGVOZXdTdGlja2VyU2V0Jywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGFkZCBhIG5ldyBzdGlja2VyIHRvIGEgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogWW91IG11c3QgdXNlIGV4YWN0bHkgb25lIG9mIHRoZSBmaWVsZHMgKnBuZ19zdGlja2VyKiwgKnRnc19zdGlja2VyKiwgb3IgKndlYm1fc3RpY2tlcipcbiAgICpcbiAgICogQW5pbWF0ZWQgc3RpY2tlcnMgY2FuIGJlIGFkZGVkIHRvIGFuaW1hdGVkIHN0aWNrZXIgc2V0cyBhbmQgb25seSB0byB0aGVtXG4gICAqXG4gICAqIE5vdGU6XG4gICAqIC0gRW1vamkgc3RpY2tlciBzZXRzIGNhbiBoYXZlIHVwIHRvIDIwMCBzdGlja2VyXG4gICAqIC0gU3RhdGljIG9yIEFuaW1hdGVkIHN0aWNrZXIgc2V0cyBjYW4gaGF2ZSB1cCB0byAxMjAgc3RpY2tlcnNcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VySWQgVXNlciBpZGVudGlmaWVyIG9mIHN0aWNrZXIgc2V0IG93bmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBTdGlja2VyIHNldCBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ3xzdHJlYW0uU3RyZWFtfEJ1ZmZlcn0gc3RpY2tlciBQbmcgaW1hZ2Ugd2l0aCB0aGUgc3RpY2tlciAobXVzdCBiZSB1cCB0byA1MTIga2lsb2J5dGVzIGluIHNpemUsXG4gICAqIGRpbWVuc2lvbnMgbXVzdCBub3QgZXhjZWVkIDUxMnB4LCBhbmQgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtdXN0IGJlIGV4YWN0bHkgNTEycHgsIFtUR1MgYW5pbWF0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3N0aWNrZXJzI2FuaW1hdGVkLXN0aWNrZXItcmVxdWlyZW1lbnRzKVxuICAgKiB3aXRoIHRoZSBzdGlja2VyIG9yIFtXRUJNIHZpZGVvXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3N0aWNrZXJzI3ZpZGVvLXN0aWNrZXItcmVxdWlyZW1lbnRzKSB3aXRoIHRoZSBzdGlja2VyLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVtb2ppcyBPbmUgb3IgbW9yZSBlbW9qaSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlclR5cGUgQWxsb3cgdmFsdWVzOiBgcG5nX3N0aWNrZXJgLCBgdGdzX3N0aWNrZXJgLCBvciBgd2VibV9zdGlja2VyYC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2ZpbGVPcHRpb25zXSBPcHRpb25hbCBmaWxlIHJlbGF0ZWQgbWV0YS1kYXRhXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2FkZHN0aWNrZXJ0b3NldFxuICAgKi9cbiAgYWRkU3RpY2tlclRvU2V0KHVzZXJJZCwgbmFtZSwgc3RpY2tlciwgZW1vamlzLCBzdGlja2VyVHlwZSA9ICdwbmdfc3RpY2tlcicsIG9wdGlvbnMgPSB7fSwgZmlsZU9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBxczogb3B0aW9ucyxcbiAgICB9O1xuICAgIG9wdHMucXMudXNlcl9pZCA9IHVzZXJJZDtcbiAgICBvcHRzLnFzLm5hbWUgPSBuYW1lO1xuICAgIG9wdHMucXMuZW1vamlzID0gZW1vamlzO1xuICAgIG9wdHMucXMubWFza19wb3NpdGlvbiA9IHN0cmluZ2lmeShvcHRpb25zLm1hc2tfcG9zaXRpb24pO1xuXG4gICAgaWYgKHR5cGVvZiBzdGlja2VyVHlwZSAhPT0gJ3N0cmluZycgfHwgWydwbmdfc3RpY2tlcicsICd0Z3Nfc3RpY2tlcicsICd3ZWJtX3N0aWNrZXInXS5pbmRleE9mKHN0aWNrZXJUeXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3N0aWNrZXJUeXBlIG11c3QgYmUgYSBzdHJpbmcgYW5kIHRoZSBhbGxvdyB0eXBlcyBpczogcG5nX3N0aWNrZXIsIHRnc19zdGlja2VyLCB3ZWJtX3N0aWNrZXInKSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gdGhpcy5fZm9ybWF0U2VuZERhdGEoc3RpY2tlclR5cGUsIHN0aWNrZXIsIGZpbGVPcHRpb25zKTtcbiAgICAgIG9wdHMuZm9ybURhdGEgPSBzZW5kRGF0YVswXTtcbiAgICAgIG9wdHMucXNbc3RpY2tlclR5cGVdID0gc2VuZERhdGFbMV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhZGRTdGlja2VyVG9TZXQnLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gbW92ZSBhIHN0aWNrZXIgaW4gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90IHRvIGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gc3RpY2tlciBGaWxlIGlkZW50aWZpZXIgb2YgdGhlIHN0aWNrZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBwb3NpdGlvbiBOZXcgc3RpY2tlciBwb3NpdGlvbiBpbiB0aGUgc2V0LCB6ZXJvLWJhc2VkXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJwb3NpdGlvbmluc2V0XG4gICAqL1xuICBzZXRTdGlja2VyUG9zaXRpb25JblNldChzdGlja2VyLCBwb3NpdGlvbiwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICBmb3JtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJQb3NpdGlvbkluU2V0JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBzdGlja2VyIGZyb20gYSBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2RlbGV0ZXN0aWNrZXJmcm9tc2V0XG4gICAqIEB0b2RvIEFkZCB0ZXN0cyBmb3IgdGhpcyBtZXRob2QhXG4gICAqL1xuICBkZWxldGVTdGlja2VyRnJvbVNldChzdGlja2VyLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdkZWxldGVTdGlja2VyRnJvbVNldCcsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVwbGFjZSBhbiBleGlzdGluZyBzdGlja2VyIGluIGEgc3RpY2tlciBzZXQgd2l0aCBhIG5ldyBvbmVcbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfSB1c2VyX2lkIFVzZXIgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlciBzZXQgb3duZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNyZXBsYWNlc3RpY2tlcmluc2V0XG4gICAqIEB0b2RvIEFkZCB0ZXN0cyBmb3IgdGhpcyBtZXRob2QhXG4gICAqL1xuICByZXBsYWNlU3RpY2tlckluU2V0KHVzZXJJZCwgbmFtZSwgb2xkU3RpY2tlciwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgZm9ybS5vbGRfc3RpY2tlciA9IG9sZFN0aWNrZXI7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVN0aWNrZXJGcm9tU2V0JywgeyBmb3JtIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgbGlzdCBvZiBlbW9qaSBhc3NpZ25lZCB0byBhIHJlZ3VsYXIgb3IgY3VzdG9tIGVtb2ppIHN0aWNrZXIuXG4gICAqXG4gICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSB7IEFycmF5IH0gZW1vamlMaXN0IEEgSlNPTi1zZXJpYWxpemVkIGxpc3Qgb2YgMS0yMCBlbW9qaSBhc3NvY2lhdGVkIHdpdGggdGhlIHN0aWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0c3RpY2tlcmVtb2ppbGlzdFxuICAgKi9cbiAgc2V0U3RpY2tlckVtb2ppTGlzdChzdGlja2VyLCBlbW9qaUxpc3QsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uc3RpY2tlciA9IHN0aWNrZXI7XG4gICAgZm9ybS5lbW9qaV9saXN0ID0gc3RyaW5naWZ5KGVtb2ppTGlzdCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJFbW9qaUxpc3QnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgbGlzdCBvZiBlbW9qaSBhc3NpZ25lZCB0byBhIGByZWd1bGFyYCBvciBgY3VzdG9tIGVtb2ppYCBzdGlja2VyLlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdGlja2VyIEZpbGUgaWRlbnRpZmllciBvZiB0aGUgc3RpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vya2V5d29yZHNcbiAgICovXG4gIHNldFN0aWNrZXJLZXl3b3JkcyhzdGlja2VyLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnN0aWNrZXIgPSBzdGlja2VyO1xuICAgIGlmIChmb3JtLmtleXdvcmRzKSB7XG4gICAgICBmb3JtLmtleXdvcmRzID0gc3RyaW5naWZ5KGZvcm0ua2V5d29yZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlcktleXdvcmRzJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIFttYXNrIHBvc2l0aW9uXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21hc2twb3NpdGlvbikgb2YgYSBtYXNrIHN0aWNrZXIuXG4gICAqXG4gICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0aWNrZXIgRmlsZSBpZGVudGlmaWVyIG9mIHRoZSBzdGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJtYXNrcG9zaXRpb25cbiAgICovXG4gIHNldFN0aWNrZXJNYXNrUG9zaXRpb24oc3RpY2tlciwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5zdGlja2VyID0gc3RpY2tlcjtcbiAgICBpZiAoZm9ybS5tYXNrX3Bvc2l0aW9uKSB7XG4gICAgICBmb3JtLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkoZm9ybS5tYXNrX3Bvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldFN0aWNrZXJNYXNrUG9zaXRpb24nLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgdGl0bGUgb2YgYSBjcmVhdGVkIHN0aWNrZXIgc2V0LlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZSBTdGlja2VyIHNldCB0aXRsZSwgMS02NCBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUcnVlIG9uIHN1Y2Nlc3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldHN0aWNrZXJzZXR0aXRsZVxuICAgKi9cbiAgc2V0U3RpY2tlclNldFRpdGxlKG5hbWUsIHRpdGxlLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLm5hbWUgPSBuYW1lO1xuICAgIGZvcm0udGl0bGUgPSB0aXRsZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlclNldFRpdGxlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBhZGQgYSB0aHVtYiB0byBhIHNldCBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIEFuaW1hdGVkIHRodW1ibmFpbHMgY2FuIGJlIHNldCBmb3IgYW5pbWF0ZWQgc3RpY2tlciBzZXRzIG9ubHkuIFZpZGVvIHRodW1ibmFpbHMgY2FuIGJlIHNldCBvbmx5IGZvciB2aWRlbyBzdGlja2VyIHNldHMgb25seVxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHVzZXJJZCBVc2VyIGlkZW50aWZpZXIgb2Ygc3RpY2tlciBzZXQgb3duZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICogQHBhcmFtICB7U3RyaW5nfHN0cmVhbS5TdHJlYW18QnVmZmVyfSB0aHVtYm5haWwgQSAuV0VCUCBvciAuUE5HIGltYWdlIHdpdGggdGhlIHRodW1ibmFpbCxcbiAgICogbXVzdCBiZSB1cCB0byAxMjgga2lsb2J5dGVzIGluIHNpemUgYW5kIGhhdmUgd2lkdGggYW5kIGhlaWdodCBleGFjdGx5IDEwMHB4LFxuICAgKiBhIFRHUyBhbmltYXRpb24gd2l0aCB0aGUgdGh1bWJuYWlsIHVwIHRvIDMyIGtpbG9ieXRlcyBpbiBzaXplIG9yIGEgV0VCTSB2aWRlbyB3aXRoIHRoZSB0aHVtYm5haWwgdXAgdG8gMzIga2lsb2J5dGVzIGluIHNpemUuXG4gICAqXG4gICAqIFBhc3MgYSBmaWxlX2lkIGFzIGEgU3RyaW5nIHRvIHNlbmQgYSBmaWxlIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gdGhlIFRlbGVncmFtIHNlcnZlcnMsIHBhc3MgYW4gSFRUUCBVUkwgYXMgYSBTdHJpbmcgZm9yIFRlbGVncmFtXG4gICAqIHRvIGdldCBhIGZpbGUgZnJvbSB0aGUgSW50ZXJuZXQsIG9yIHVwbG9hZCBhIG5ldyBvbmUuIEFuaW1hdGVkIHN0aWNrZXIgc2V0IHRodW1ibmFpbHMgY2FuJ3QgYmUgdXBsb2FkZWQgdmlhIEhUVFAgVVJMLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbZmlsZU9wdGlvbnNdIE9wdGlvbmFsIGZpbGUgcmVsYXRlZCBtZXRhLWRhdGFcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZXRzdGlja2Vyc2V0dGh1bWJuYWlsXG4gICAqL1xuICBzZXRTdGlja2VyU2V0VGh1bWJuYWlsKHVzZXJJZCwgbmFtZSwgdGh1bWJuYWlsLCBvcHRpb25zID0ge30sIGZpbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgfTtcbiAgICBvcHRzLnFzLnVzZXJfaWQgPSB1c2VySWQ7XG4gICAgb3B0cy5xcy5uYW1lID0gbmFtZTtcbiAgICBvcHRzLnFzLm1hc2tfcG9zaXRpb24gPSBzdHJpbmdpZnkob3B0aW9ucy5tYXNrX3Bvc2l0aW9uKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLl9mb3JtYXRTZW5kRGF0YSgndGh1bWJuYWlsJywgdGh1bWJuYWlsLCBmaWxlT3B0aW9ucyk7XG4gICAgICBvcHRzLmZvcm1EYXRhID0gc2VuZERhdGFbMF07XG4gICAgICBvcHRzLnFzLnRodW1ibmFpbCA9IHNlbmREYXRhWzFdO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0U3RpY2tlclNldFRodW1ibmFpbCcsIG9wdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgdGh1bWJuYWlsIG9mIGEgY3VzdG9tIGVtb2ppIHN0aWNrZXIgc2V0LlxuICAgKlxuICAgKiBUaGUgc3RpY2tlciBtdXN0IGJlbG9uZyB0byBhIHN0aWNrZXIgc2V0IGNyZWF0ZWQgYnkgdGhlIGJvdC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIFN0aWNrZXIgc2V0IG5hbWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRydWUgb24gc3VjY2Vzc1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjc2V0Y3VzdG9tZW1vamlzdGlja2Vyc2V0dGh1bWJuYWlsXG4gICAqL1xuICBzZXRDdXN0b21FbW9qaVN0aWNrZXJTZXRUaHVtYm5haWwobmFtZSwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnc2V0Q3VzdG9tRW1vamlTdGlja2VyU2V0VGh1bWJuYWlsJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBkZWxldGUgYSBzdGlja2VyIHNldCB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBib3QuXG4gICAqXG4gICAqIFRoZSBzdGlja2VyIG11c3QgYmVsb25nIHRvIGEgc3RpY2tlciBzZXQgY3JlYXRlZCBieSB0aGUgYm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgU3RpY2tlciBzZXQgbmFtZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVzdGlja2Vyc2V0XG4gICAqL1xuICBkZWxldGVTdGlja2VyU2V0KG5hbWUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0ubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZVN0aWNrZXJTZXQnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhbnN3ZXJzIHRvIGFuIGlubGluZSBxdWVyeS5cbiAgICpcbiAgICogTm90ZTogTm8gbW9yZSB0aGFuIDUwIHJlc3VsdHMgcGVyIHF1ZXJ5IGFyZSBhbGxvd2VkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlubGluZVF1ZXJ5SWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHF1ZXJ5XG4gICAqIEBwYXJhbSAge0lubGluZVF1ZXJ5UmVzdWx0W119IHJlc3VsdHMgQW4gYXJyYXkgb2YgcmVzdWx0cyBmb3IgdGhlIGlubGluZSBxdWVyeVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgVHJ1ZSBpcyByZXR1cm5lZFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2VyaW5saW5lcXVlcnlcbiAgICovXG4gIGFuc3dlcklubGluZVF1ZXJ5KGlubGluZVF1ZXJ5SWQsIHJlc3VsdHMsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uaW5saW5lX3F1ZXJ5X2lkID0gaW5saW5lUXVlcnlJZDtcbiAgICBmb3JtLnJlc3VsdHMgPSBzdHJpbmdpZnkocmVzdWx0cyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlcklubGluZVF1ZXJ5JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIHJlc3VsdCBvZiBhbiBpbnRlcmFjdGlvbiB3aXRoIGEgW1dlYiBBcHBdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy93ZWJhcHBzKVxuICAgKiBhbmQgc2VuZCBhIGNvcnJlc3BvbmRpbmcgbWVzc2FnZSBvbiBiZWhhbGYgb2YgdGhlIHVzZXIgdG8gdGhlIGNoYXQgZnJvbSB3aGljaCB0aGUgcXVlcnkgb3JpZ2luYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSB3ZWJBcHBRdWVyeUlkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgICogQHBhcmFtICB7SW5saW5lUXVlcnlSZXN1bHR9IHJlc3VsdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIG9uZSByZXN1bHQgb2YgYW4gaW5saW5lIHF1ZXJ5XG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBhIFtTZW50V2ViQXBwTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW50d2ViYXBwbWVzc2FnZSkgb2JqZWN0IGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJ3ZWJhcHBxdWVyeVxuICAgKi9cbiAgYW5zd2VyV2ViQXBwUXVlcnkod2ViQXBwUXVlcnlJZCwgcmVzdWx0LCBmb3JtID0ge30pIHtcbiAgICBmb3JtLndlYl9hcHBfcXVlcnlfaWQgPSB3ZWJBcHBRdWVyeUlkO1xuICAgIGZvcm0ucmVzdWx0ID0gc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlcldlYkFwcFF1ZXJ5JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGFuIGludm9pY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgYEBjaGFubmVsdXNlcm5hbWVgKVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIFByb2R1Y3QgbmFtZSwgMS0zMiBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGVzY3JpcHRpb24gUHJvZHVjdCBkZXNjcmlwdGlvbiwgMS0yNTUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBheWxvYWQgQm90IGRlZmluZWQgaW52b2ljZSBwYXlsb2FkLCAxLTEyOCBieXRlcy4gVGhpcyB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIsIHVzZSBmb3IgeW91ciBpbnRlcm5hbCBwcm9jZXNzZXMuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJvdmlkZXJUb2tlbiBQYXltZW50cyBwcm92aWRlciB0b2tlbiwgb2J0YWluZWQgdmlhIGBAQm90RmF0aGVyYFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGN1cnJlbmN5IFRocmVlLWxldHRlciBJU08gNDIxNyBjdXJyZW5jeSBjb2RlXG4gICAqIEBwYXJhbSAge0FycmF5fSBwcmljZXMgQnJlYWtkb3duIG9mIHByaWNlc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgdGhlIHNlbnQgW01lc3NhZ2VdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjbWVzc2FnZSkgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NlbmRpbnZvaWNlXG4gICAqL1xuICBzZW5kSW52b2ljZShjaGF0SWQsIHRpdGxlLCBkZXNjcmlwdGlvbiwgcGF5bG9hZCwgcHJvdmlkZXJUb2tlbiwgY3VycmVuY3ksIHByaWNlcywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5jaGF0X2lkID0gY2hhdElkO1xuICAgIGZvcm0udGl0bGUgPSB0aXRsZTtcbiAgICBmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgZm9ybS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICBmb3JtLnByb3ZpZGVyX3Rva2VuID0gcHJvdmlkZXJUb2tlbjtcbiAgICBmb3JtLmN1cnJlbmN5ID0gY3VycmVuY3k7XG4gICAgZm9ybS5wcmljZXMgPSBzdHJpbmdpZnkocHJpY2VzKTtcbiAgICBmb3JtLnByb3ZpZGVyX2RhdGEgPSBzdHJpbmdpZnkoZm9ybS5wcm92aWRlcl9kYXRhKTtcbiAgICBpZiAoZm9ybS5zdWdnZXN0ZWRfdGlwX2Ftb3VudHMpIHtcbiAgICAgIGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzID0gc3RyaW5naWZ5KGZvcm0uc3VnZ2VzdGVkX3RpcF9hbW91bnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NlbmRJbnZvaWNlJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhIGxpbmsgZm9yIGFuIGludm9pY2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgUHJvZHVjdCBuYW1lLCAxLTMyIGNoYXJhY3RlcnNcbiAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gUHJvZHVjdCBkZXNjcmlwdGlvbiwgMS0yNTUgY2hhcmFjdGVyc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkIEJvdCBkZWZpbmVkIGludm9pY2UgcGF5bG9hZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm92aWRlclRva2VuIFBheW1lbnQgcHJvdmlkZXIgdG9rZW5cbiAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVuY3kgVGhyZWUtbGV0dGVyIElTTyA0MjE3IGN1cnJlbmN5IGNvZGVcbiAgKiBAcGFyYW0ge0FycmF5fSBwcmljZXMgQnJlYWtkb3duIG9mIHByaWNlc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSBjcmVhdGVkIGludm9pY2UgbGluayBhcyBTdHJpbmcgb24gc3VjY2Vzcy5cbiAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjY3JlYXRlaW52b2ljZWxpbmtcbiAgKi9cbiAgY3JlYXRlSW52b2ljZUxpbmsodGl0bGUsIGRlc2NyaXB0aW9uLCBwYXlsb2FkLCBwcm92aWRlclRva2VuLCBjdXJyZW5jeSwgcHJpY2VzLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLnRpdGxlID0gdGl0bGU7XG4gICAgZm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGZvcm0ucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgZm9ybS5wcm92aWRlcl90b2tlbiA9IHByb3ZpZGVyVG9rZW47XG4gICAgZm9ybS5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIGZvcm0ucHJpY2VzID0gc3RyaW5naWZ5KHByaWNlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2NyZWF0ZUludm9pY2VMaW5rJywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlcGx5IHRvIHNoaXBwaW5nIHF1ZXJpZXMuXG4gICpcbiAgKiBJZiB5b3Ugc2VudCBhbiBpbnZvaWNlIHJlcXVlc3RpbmcgYSBzaGlwcGluZyBhZGRyZXNzIGFuZCB0aGUgcGFyYW1ldGVyIGlzX2ZsZXhpYmxlIHdhcyBzcGVjaWZpZWQsXG4gICogdGhlIEJvdCBBUEkgd2lsbCBzZW5kIGFuIFtVcGRhdGVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjdXBkYXRlKSB3aXRoIGEgc2hpcHBpbmdfcXVlcnkgZmllbGQgdG8gdGhlIGJvdFxuICAqXG4gICogQHBhcmFtICB7U3RyaW5nfSBzaGlwcGluZ1F1ZXJ5SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcXVlcnkgdG8gYmUgYW5zd2VyZWRcbiAgKiBAcGFyYW0gIHtCb29sZWFufSBvayBTcGVjaWZ5IGlmIGRlbGl2ZXJ5IG9mIHRoZSBwcm9kdWN0IGlzIHBvc3NpYmxlXG4gICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICogQHJldHVybiB7UHJvbWlzZX0gT24gc3VjY2VzcywgVHJ1ZSBpcyByZXR1cm5lZFxuICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNhbnN3ZXJzaGlwcGluZ3F1ZXJ5XG4gICovXG4gIGFuc3dlclNoaXBwaW5nUXVlcnkoc2hpcHBpbmdRdWVyeUlkLCBvaywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5zaGlwcGluZ19xdWVyeV9pZCA9IHNoaXBwaW5nUXVlcnlJZDtcbiAgICBmb3JtLm9rID0gb2s7XG4gICAgZm9ybS5zaGlwcGluZ19vcHRpb25zID0gc3RyaW5naWZ5KGZvcm0uc2hpcHBpbmdfb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2Fuc3dlclNoaXBwaW5nUXVlcnknLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlc3BvbmQgdG8gc3VjaCBwcmUtY2hlY2tvdXQgcXVlcmllc1xuICAgKlxuICAgKiBPbmNlIHRoZSB1c2VyIGhhcyBjb25maXJtZWQgdGhlaXIgcGF5bWVudCBhbmQgc2hpcHBpbmcgZGV0YWlscywgdGhlIEJvdCBBUEkgc2VuZHMgdGhlIGZpbmFsIGNvbmZpcm1hdGlvbiBpbiB0aGUgZm9ybSBvZlxuICAgKiBhbiBbVXBkYXRlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3VwZGF0ZSkgd2l0aCB0aGUgZmllbGQgKnByZV9jaGVja291dF9xdWVyeSouXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgQm90IEFQSSBtdXN0IHJlY2VpdmUgYW4gYW5zd2VyIHdpdGhpbiAxMCBzZWNvbmRzIGFmdGVyIHRoZSBwcmUtY2hlY2tvdXQgcXVlcnkgd2FzIHNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJlQ2hlY2tvdXRRdWVyeUlkICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHF1ZXJ5IHRvIGJlIGFuc3dlcmVkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9rIFNwZWNpZnkgaWYgZXZlcnkgb3JkZXIgZGV0YWlscyBhcmUgb2tcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIFRydWUgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcnByZWNoZWNrb3V0cXVlcnlcbiAgICovXG4gIGFuc3dlclByZUNoZWNrb3V0UXVlcnkocHJlQ2hlY2tvdXRRdWVyeUlkLCBvaywgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS5wcmVfY2hlY2tvdXRfcXVlcnlfaWQgPSBwcmVDaGVja291dFF1ZXJ5SWQ7XG4gICAgZm9ybS5vayA9IG9rO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdhbnN3ZXJQcmVDaGVja291dFF1ZXJ5JywgeyBmb3JtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZW5kIGEgZ2FtZS5cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gY2hhdElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IGBAY2hhbm5lbHVzZXJuYW1lYClcbiAgICogQHBhcmFtICB7U3RyaW5nfSBnYW1lU2hvcnROYW1lIG5hbWUgb2YgdGhlIGdhbWUgdG8gYmUgc2VudC4gU2V0IHVwIHlvdXIgZ2FtZXMgdmlhIGBAQm90RmF0aGVyYC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHRoZSBzZW50IFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpIGlzIHJldHVybmVkXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNzZW5kZ2FtZVxuICAgKi9cbiAgc2VuZEdhbWUoY2hhdElkLCBnYW1lU2hvcnROYW1lLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5nYW1lX3Nob3J0X25hbWUgPSBnYW1lU2hvcnROYW1lO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdzZW5kR2FtZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gc2V0IHRoZSBzY29yZSBvZiB0aGUgc3BlY2lmaWVkIHVzZXIgaW4gYSBnYW1lIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBzY29yZSBOZXcgc2NvcmUgdmFsdWUsIG11c3QgYmUgbm9uLW5lZ2F0aXZlXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBPbiBzdWNjZXNzLCBpZiB0aGUgbWVzc2FnZSBpcyBub3QgYW4gaW5saW5lIG1lc3NhZ2UsIHRoZSBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIFRydWUgaXMgcmV0dXJuZWRcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI3NldGdhbWVzY29yZVxuICAgKi9cbiAgc2V0R2FtZVNjb3JlKHVzZXJJZCwgc2NvcmUsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0udXNlcl9pZCA9IHVzZXJJZDtcbiAgICBmb3JtLnNjb3JlID0gc2NvcmU7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ3NldEdhbWVTY29yZScsIHsgZm9ybSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gZ2V0IGRhdGEgZm9yIGhpZ2ggc2NvcmUgdGFibGVzLlxuICAgKlxuICAgKiBXaWxsIHJldHVybiB0aGUgc2NvcmUgb2YgdGhlIHNwZWNpZmllZCB1c2VyIGFuZCBzZXZlcmFsIG9mIHRoZWlyIG5laWdoYm9ycyBpbiBhIGdhbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdXNlcklkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBUZWxlZ3JhbSBxdWVyeSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IE9uIHN1Y2Nlc3MsIHJldHVybnMgYW4gQXJyYXkgb2YgW0dhbWVIaWdoU2NvcmVdKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2FtZWhpZ2hzY29yZSkgb2JqZWN0c1xuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0Z2FtZWhpZ2hzY29yZXNcbiAgICovXG4gIGdldEdhbWVIaWdoU2NvcmVzKHVzZXJJZCwgZm9ybSA9IHt9KSB7XG4gICAgZm9ybS51c2VyX2lkID0gdXNlcklkO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXRHYW1lSGlnaFNjb3JlcycsIHsgZm9ybSB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gKiBVc2UgdGhpcyBtZXRob2QgdG8gZGVsZXRlIGEgbWVzc2FnZSwgaW5jbHVkaW5nIHNlcnZpY2UgbWVzc2FnZXMsIHdpdGggdGhlIGZvbGxvd2luZyBsaW1pdGF0aW9uczpcbiAqIC0gQSBtZXNzYWdlIGNhbiBvbmx5IGJlIGRlbGV0ZWQgaWYgaXQgd2FzIHNlbnQgbGVzcyB0aGFuIDQ4IGhvdXJzIGFnby5cbiAqIC0gQSBkaWNlIG1lc3NhZ2UgY2FuIG9ubHkgYmUgZGVsZXRlZCBpZiBpdCB3YXMgc2VudCBtb3JlIHRoYW4gMjQgaG91cnMgYWdvLlxuICogLSBCb3RzIGNhbiBkZWxldGUgb3V0Z29pbmcgbWVzc2FnZXMgaW4gZ3JvdXBzIGFuZCBzdXBlcmdyb3Vwcy5cbiAqIC0gQm90cyBjYW4gZGVsZXRlIGluY29taW5nIG1lc3NhZ2VzIGluIGdyb3Vwcywgc3VwZXJncm91cHMgYW5kIGNoYW5uZWxzLlxuICogLSBCb3RzIGdyYW50ZWQgYGNhbl9wb3N0X21lc3NhZ2VzYCBwZXJtaXNzaW9ucyBjYW4gZGVsZXRlIG91dGdvaW5nIG1lc3NhZ2VzIGluIGNoYW5uZWxzLlxuICogLSBJZiB0aGUgYm90IGlzIGFuIGFkbWluaXN0cmF0b3Igb2YgYSBncm91cCwgaXQgY2FuIGRlbGV0ZSBhbnkgbWVzc2FnZSB0aGVyZS5cbiAqIC0gSWYgdGhlIGJvdCBoYXMgYGNhbl9kZWxldGVfbWVzc2FnZXNgIHBlcm1pc3Npb24gaW4gYSBzdXBlcmdyb3VwLCBpdCBjYW4gZGVsZXRlIGFueSBtZXNzYWdlIHRoZXJlLlxuICpcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGNoYXRJZCAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB0YXJnZXQgY2hhdCBvciB1c2VybmFtZSBvZiB0aGUgdGFyZ2V0IGNoYW5uZWwgKGluIHRoZSBmb3JtYXQgQGNoYW5uZWx1c2VybmFtZSlcbiAqIEBwYXJhbSAge051bWJlcn0gbWVzc2FnZUlkICBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdGFyZ2V0IG1lc3NhZ2VcbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgVGVsZWdyYW0gcXVlcnkgb3B0aW9uc1xuICogQHJldHVybiB7UHJvbWlzZX0gVHJ1ZSBvbiBzdWNjZXNzXG4gKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZGVsZXRlbWVzc2FnZVxuICovXG4gIGRlbGV0ZU1lc3NhZ2UoY2hhdElkLCBtZXNzYWdlSWQsIGZvcm0gPSB7fSkge1xuICAgIGZvcm0uY2hhdF9pZCA9IGNoYXRJZDtcbiAgICBmb3JtLm1lc3NhZ2VfaWQgPSBtZXNzYWdlSWQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2RlbGV0ZU1lc3NhZ2UnLCB7IGZvcm0gfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGRlbGV0ZSBtdWx0aXBsZSBtZXNzYWdlcyBzaW11bHRhbmVvdXNseS4gSWYgc29tZSBvZiB0aGUgc3BlY2lmaWVkIG1lc3NhZ2VzIGNhbid0IGJlIGZvdW5kLCB0aGV5IGFyZSBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSBjaGF0SWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdGFyZ2V0IGNoYXQgb3IgdXNlcm5hbWUgb2YgdGhlIHRhcmdldCBjaGFubmVsIChpbiB0aGUgZm9ybWF0IEBjaGFubmVsdXNlcm5hbWUpXG4gICAqIEBwYXJhbSAge0FycmF5PE51bWJlcnxTdHJpbmc+fSBtZXNzYWdlSWRzICBJZGVudGlmaWVycyBvZiAxLTEwMCBtZXNzYWdlcyB0byBkZWxldGUuIFNlZSBkZWxldGVNZXNzYWdlIGZvciBsaW1pdGF0aW9ucyBvbiB3aGljaCBtZXNzYWdlcyBjYW4gYmUgZGVsZXRlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIFRlbGVncmFtIHF1ZXJ5IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gVHJ1ZSBvbiBzdWNjZXNzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNkZWxldGVtZXNzYWdlc1xuICAgKi9cbiAgZGVsZXRlTWVzc2FnZXMoY2hhdElkLCBtZXNzYWdlSWRzLCBmb3JtID0ge30pIHtcbiAgICBmb3JtLmNoYXRfaWQgPSBjaGF0SWQ7XG4gICAgZm9ybS5tZXNzYWdlX2lkcyA9IHN0cmluZ2lmeShtZXNzYWdlSWRzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnZGVsZXRlTWVzc2FnZXMnLCB7IGZvcm0gfSk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVncmFtQm90O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegram.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegramPolling.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst deprecate = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\").deprecate);\nconst ANOTHER_WEB_HOOK_USED = 409;\n\n\nclass TelegramBotPolling {\n  /**\n   * Handles polling against the Telegram servers.\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = (typeof bot.options.polling === 'boolean') ? {} : bot.options.polling;\n    this.options.interval = (typeof this.options.interval === 'number') ? this.options.interval : 300;\n    this.options.params = (typeof this.options.params === 'object') ? this.options.params : {};\n    this.options.params.offset = (typeof this.options.params.offset === 'number') ? this.options.params.offset : 0;\n    this.options.params.timeout = (typeof this.options.params.timeout === 'number') ? this.options.params.timeout : 10;\n    if (typeof this.options.timeout === 'number') {\n      deprecate('`options.polling.timeout` is deprecated. Use `options.polling.params` instead.');\n      this.options.params.timeout = this.options.timeout;\n    }\n    this._lastUpdate = 0;\n    this._lastRequest = null;\n    this._abort = false;\n    this._pollingTimeout = null;\n  }\n\n  /**\n   * Start polling\n   * @param  {Object} [options]\n   * @param  {Object} [options.restart]\n   * @return {Promise}\n   */\n  start(options = {}) {\n    if (this._lastRequest) {\n      if (!options.restart) {\n        return Promise.resolve();\n      }\n      return this.stop({\n        cancel: true,\n        reason: 'Polling restart',\n      }).then(() => {\n        return this._polling();\n      });\n    }\n    return this._polling();\n  }\n\n  /**\n   * Stop polling\n   * @param  {Object} [options] Options\n   * @param  {Boolean} [options.cancel] Cancel current request\n   * @param  {String} [options.reason] Reason for stopping polling\n   * @return {Promise}\n   */\n  stop(options = {}) {\n    if (!this._lastRequest) {\n      return Promise.resolve();\n    }\n    const lastRequest = this._lastRequest;\n    this._lastRequest = null;\n    clearTimeout(this._pollingTimeout);\n    if (options.cancel) {\n      const reason = options.reason || 'Polling stop';\n      lastRequest.cancel(reason);\n      return Promise.resolve();\n    }\n    this._abort = true;\n    return lastRequest.finally(() => {\n      this._abort = false;\n    });\n  }\n\n  /**\n   * Return `true` if is polling. Otherwise, `false`.\n   */\n  isPolling() {\n    return !!this._lastRequest;\n  }\n\n  /**\n   * Handle error thrown during polling.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('polling_error').length) {\n      return console.error('error: [polling_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('polling_error', error);\n  }\n\n  /**\n   * Invokes polling (with recursion!)\n   * @return {Promise} promise of the current request\n   * @private\n   */\n  _polling() {\n    this._lastRequest = this\n      ._getUpdates()\n      .then(updates => {\n        this._lastUpdate = Date.now();\n        debug('polling data %j', updates);\n        updates.forEach(update => {\n          this.options.params.offset = update.update_id + 1;\n          debug('updated offset: %s', this.options.params.offset);\n          try {\n            this.bot.processUpdate(update);\n          } catch (err) {\n            err._processing = true;\n            throw err;\n          }\n        });\n        return null;\n      })\n      .catch(err => {\n        debug('polling error: %s', err.message);\n        if (!err._processing) {\n          return this._error(err);\n        }\n        delete err._processing;\n        /*\n         * An error occured while processing the items,\n         * i.e. in `this.bot.processUpdate()` above.\n         * We need to mark the already-processed items\n         * to avoid fetching them again once the application\n         * is restarted, or moves to next polling interval\n         * (in cases where unhandled rejections do not terminate\n         * the process).\n         * See https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067\n         */\n        if (!this.bot.options.badRejection) {\n          return this._error(err);\n        }\n        const opts = {\n          offset: this.options.params.offset,\n          limit: 1,\n          timeout: 0,\n        };\n        return this.bot.getUpdates(opts).then(() => {\n          return this._error(err);\n        }).catch(requestErr => {\n          /*\n           * We have been unable to handle this error.\n           * We have to log this to stderr to ensure devops\n           * understands that they may receive already-processed items\n           * on app restart.\n           * We simply can not rescue this situation, emit \"error\"\n           * event, with the hope that the application exits.\n           */\n          /* eslint-disable no-console */\n          const bugUrl = 'https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067';\n          console.error('error: Internal handling of The Offset Infinite Loop failed');\n          console.error(`error: Due to error '${requestErr}'`);\n          console.error('error: You may receive already-processed updates on app restart');\n          console.error(`error: Please see ${bugUrl} for more information`);\n          /* eslint-enable no-console */\n          return this.bot.emit('error', new errors.FatalError(err));\n        });\n      })\n      .finally(() => {\n        if (this._abort) {\n          debug('Polling is aborted!');\n        } else {\n          debug('setTimeout for %s miliseconds', this.options.interval);\n          this._pollingTimeout = setTimeout(() => this._polling(), this.options.interval);\n        }\n      });\n    return this._lastRequest;\n  }\n\n  /**\n   * Unset current webhook. Used when we detect that a webhook has been set\n   * and we are trying to poll. Polling and WebHook are mutually exclusive.\n   * @see https://core.telegram.org/bots/api#getting-updates\n   * @private\n   */\n  _unsetWebHook() {\n    debug('unsetting webhook');\n    return this.bot._request('setWebHook');\n  }\n\n  /**\n   * Retrieve updates\n   */\n  _getUpdates() {\n    debug('polling with options: %j', this.options.params);\n    return this.bot.getUpdates(this.options.params)\n      .catch(err => {\n        if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {\n          return this._unsetWebHook().then(() => {\n            return this.bot.getUpdates(this.options.params);\n          });\n        }\n        throw err;\n      });\n  }\n}\n\nmodule.exports = TelegramBotPolling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbVBvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLDBFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBTztBQUM3QixrQkFBa0IseUdBQTRCO0FBQzlDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcc3JjXFx0ZWxlZ3JhbVBvbGxpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJyk7XG5jb25zdCBkZXByZWNhdGUgPSByZXF1aXJlKCcuL3V0aWxzJykuZGVwcmVjYXRlO1xuY29uc3QgQU5PVEhFUl9XRUJfSE9PS19VU0VEID0gNDA5O1xuXG5cbmNsYXNzIFRlbGVncmFtQm90UG9sbGluZyB7XG4gIC8qKlxuICAgKiBIYW5kbGVzIHBvbGxpbmcgYWdhaW5zdCB0aGUgVGVsZWdyYW0gc2VydmVycy5cbiAgICogQHBhcmFtICB7VGVsZWdyYW1Cb3R9IGJvdFxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dGluZy11cGRhdGVzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihib3QpIHtcbiAgICB0aGlzLmJvdCA9IGJvdDtcbiAgICB0aGlzLm9wdGlvbnMgPSAodHlwZW9mIGJvdC5vcHRpb25zLnBvbGxpbmcgPT09ICdib29sZWFuJykgPyB7fSA6IGJvdC5vcHRpb25zLnBvbGxpbmc7XG4gICAgdGhpcy5vcHRpb25zLmludGVydmFsID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgPT09ICdudW1iZXInKSA/IHRoaXMub3B0aW9ucy5pbnRlcnZhbCA6IDMwMDtcbiAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zID09PSAnb2JqZWN0JykgPyB0aGlzLm9wdGlvbnMucGFyYW1zIDoge307XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcy5vZmZzZXQgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbXMub2Zmc2V0ID09PSAnbnVtYmVyJykgPyB0aGlzLm9wdGlvbnMucGFyYW1zLm9mZnNldCA6IDA7XG4gICAgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zLnRpbWVvdXQgPT09ICdudW1iZXInKSA/IHRoaXMub3B0aW9ucy5wYXJhbXMudGltZW91dCA6IDEwO1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICBkZXByZWNhdGUoJ2BvcHRpb25zLnBvbGxpbmcudGltZW91dGAgaXMgZGVwcmVjYXRlZC4gVXNlIGBvcHRpb25zLnBvbGxpbmcucGFyYW1zYCBpbnN0ZWFkLicpO1xuICAgICAgdGhpcy5vcHRpb25zLnBhcmFtcy50aW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSAwO1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9hYm9ydCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvbGxpbmdUaW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwb2xsaW5nXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMucmVzdGFydF1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXJ0KG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9sYXN0UmVxdWVzdCkge1xuICAgICAgaWYgKCFvcHRpb25zLnJlc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcCh7XG4gICAgICAgIGNhbmNlbDogdHJ1ZSxcbiAgICAgICAgcmVhc29uOiAnUG9sbGluZyByZXN0YXJ0JyxcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb2xsaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBwb2xsaW5nXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsXSBDYW5jZWwgY3VycmVudCByZXF1ZXN0XG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMucmVhc29uXSBSZWFzb24gZm9yIHN0b3BwaW5nIHBvbGxpbmdcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHN0b3Aob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0UmVxdWVzdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UmVxdWVzdCA9IHRoaXMuX2xhc3RSZXF1ZXN0O1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0ID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcG9sbGluZ1RpbWVvdXQpO1xuICAgIGlmIChvcHRpb25zLmNhbmNlbCkge1xuICAgICAgY29uc3QgcmVhc29uID0gb3B0aW9ucy5yZWFzb24gfHwgJ1BvbGxpbmcgc3RvcCc7XG4gICAgICBsYXN0UmVxdWVzdC5jYW5jZWwocmVhc29uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5fYWJvcnQgPSB0cnVlO1xuICAgIHJldHVybiBsYXN0UmVxdWVzdC5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuX2Fib3J0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCBpZiBpcyBwb2xsaW5nLiBPdGhlcndpc2UsIGBmYWxzZWAuXG4gICAqL1xuICBpc1BvbGxpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbGFzdFJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGVycm9yIHRocm93biBkdXJpbmcgcG9sbGluZy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7RXJyb3J9IGVycm9yXG4gICAqL1xuICBfZXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuYm90Lmxpc3RlbmVycygncG9sbGluZ19lcnJvcicpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBbcG9sbGluZ19lcnJvcl0gJWonLCBlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ib3QuZW1pdCgncG9sbGluZ19lcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHBvbGxpbmcgKHdpdGggcmVjdXJzaW9uISlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSBvZiB0aGUgY3VycmVudCByZXF1ZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9sbGluZygpIHtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IHRoaXNcbiAgICAgIC5fZ2V0VXBkYXRlcygpXG4gICAgICAudGhlbih1cGRhdGVzID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIGRlYnVnKCdwb2xsaW5nIGRhdGEgJWonLCB1cGRhdGVzKTtcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnBhcmFtcy5vZmZzZXQgPSB1cGRhdGUudXBkYXRlX2lkICsgMTtcbiAgICAgICAgICBkZWJ1ZygndXBkYXRlZCBvZmZzZXQ6ICVzJywgdGhpcy5vcHRpb25zLnBhcmFtcy5vZmZzZXQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJvdC5wcm9jZXNzVXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuX3Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBkZWJ1ZygncG9sbGluZyBlcnJvcjogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIGlmICghZXJyLl9wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVyci5fcHJvY2Vzc2luZztcbiAgICAgICAgLypcbiAgICAgICAgICogQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBwcm9jZXNzaW5nIHRoZSBpdGVtcyxcbiAgICAgICAgICogaS5lLiBpbiBgdGhpcy5ib3QucHJvY2Vzc1VwZGF0ZSgpYCBhYm92ZS5cbiAgICAgICAgICogV2UgbmVlZCB0byBtYXJrIHRoZSBhbHJlYWR5LXByb2Nlc3NlZCBpdGVtc1xuICAgICAgICAgKiB0byBhdm9pZCBmZXRjaGluZyB0aGVtIGFnYWluIG9uY2UgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgICAqIGlzIHJlc3RhcnRlZCwgb3IgbW92ZXMgdG8gbmV4dCBwb2xsaW5nIGludGVydmFsXG4gICAgICAgICAqIChpbiBjYXNlcyB3aGVyZSB1bmhhbmRsZWQgcmVqZWN0aW9ucyBkbyBub3QgdGVybWluYXRlXG4gICAgICAgICAqIHRoZSBwcm9jZXNzKS5cbiAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95YWdvcC9ub2RlLXRlbGVncmFtLWJvdC1hcGkvaXNzdWVzLzM2I2lzc3VlY29tbWVudC0yNjg1MzIwNjdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghdGhpcy5ib3Qub3B0aW9ucy5iYWRSZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5vcHRpb25zLnBhcmFtcy5vZmZzZXQsXG4gICAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90LmdldFVwZGF0ZXMob3B0cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH0pLmNhdGNoKHJlcXVlc3RFcnIgPT4ge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogV2UgaGF2ZSBiZWVuIHVuYWJsZSB0byBoYW5kbGUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgKiBXZSBoYXZlIHRvIGxvZyB0aGlzIHRvIHN0ZGVyciB0byBlbnN1cmUgZGV2b3BzXG4gICAgICAgICAgICogdW5kZXJzdGFuZHMgdGhhdCB0aGV5IG1heSByZWNlaXZlIGFscmVhZHktcHJvY2Vzc2VkIGl0ZW1zXG4gICAgICAgICAgICogb24gYXBwIHJlc3RhcnQuXG4gICAgICAgICAgICogV2Ugc2ltcGx5IGNhbiBub3QgcmVzY3VlIHRoaXMgc2l0dWF0aW9uLCBlbWl0IFwiZXJyb3JcIlxuICAgICAgICAgICAqIGV2ZW50LCB3aXRoIHRoZSBob3BlIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGV4aXRzLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICBjb25zdCBidWdVcmwgPSAnaHR0cHM6Ly9naXRodWIuY29tL3lhZ29wL25vZGUtdGVsZWdyYW0tYm90LWFwaS9pc3N1ZXMvMzYjaXNzdWVjb21tZW50LTI2ODUzMjA2Nyc7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IEludGVybmFsIGhhbmRsaW5nIG9mIFRoZSBPZmZzZXQgSW5maW5pdGUgTG9vcCBmYWlsZWQnKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBlcnJvcjogRHVlIHRvIGVycm9yICcke3JlcXVlc3RFcnJ9J2ApO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBZb3UgbWF5IHJlY2VpdmUgYWxyZWFkeS1wcm9jZXNzZWQgdXBkYXRlcyBvbiBhcHAgcmVzdGFydCcpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGVycm9yOiBQbGVhc2Ugc2VlICR7YnVnVXJsfSBmb3IgbW9yZSBpbmZvcm1hdGlvbmApO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIHJldHVybiB0aGlzLmJvdC5lbWl0KCdlcnJvcicsIG5ldyBlcnJvcnMuRmF0YWxFcnJvcihlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fYWJvcnQpIHtcbiAgICAgICAgICBkZWJ1ZygnUG9sbGluZyBpcyBhYm9ydGVkIScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdzZXRUaW1lb3V0IGZvciAlcyBtaWxpc2Vjb25kcycsIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy5fcG9sbGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3BvbGxpbmcoKSwgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc2V0IGN1cnJlbnQgd2ViaG9vay4gVXNlZCB3aGVuIHdlIGRldGVjdCB0aGF0IGEgd2ViaG9vayBoYXMgYmVlbiBzZXRcbiAgICogYW5kIHdlIGFyZSB0cnlpbmcgdG8gcG9sbC4gUG9sbGluZyBhbmQgV2ViSG9vayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjZ2V0dGluZy11cGRhdGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdW5zZXRXZWJIb29rKCkge1xuICAgIGRlYnVnKCd1bnNldHRpbmcgd2ViaG9vaycpO1xuICAgIHJldHVybiB0aGlzLmJvdC5fcmVxdWVzdCgnc2V0V2ViSG9vaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHVwZGF0ZXNcbiAgICovXG4gIF9nZXRVcGRhdGVzKCkge1xuICAgIGRlYnVnKCdwb2xsaW5nIHdpdGggb3B0aW9uczogJWonLCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcy5ib3QuZ2V0VXBkYXRlcyh0aGlzLm9wdGlvbnMucGFyYW1zKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IEFOT1RIRVJfV0VCX0hPT0tfVVNFRCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl91bnNldFdlYkhvb2soKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdC5nZXRVcGRhdGVzKHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGVsZWdyYW1Cb3RQb2xsaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegramPolling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js":
/*!*******************************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/telegramWebHook.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/node-telegram-bot-api/src/errors.js\");\nconst debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/node-telegram-bot-api/node_modules/debug/src/index.js\")('node-telegram-bot-api');\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bl = __webpack_require__(/*! bl */ \"(rsc)/./node_modules/bl/bl.js\");\n\nclass TelegramBotWebHook {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = (typeof bot.options.webHook === 'boolean') ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n  open() {\n    if (this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.listen(this.options.port, this.options.host, () => {\n        debug('WebHook listening on port %s', this.options.port);\n        this._open = true;\n        return resolve();\n      });\n\n      this._webServer.once('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Close the webHook\n   * @return {Promise}\n   */\n  close() {\n    if (!this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.close(error => {\n        if (error) return reject(error);\n        this._open = false;\n        return resolve();\n      });\n    });\n  }\n\n  /**\n   * Return `true` if server is listening. Otherwise, `false`.\n   */\n  isOpen() {\n    // NOTE: Since `http.Server.listening` was added in v5.7.0\n    // and we still need to support Node v4,\n    // we are going to fallback to 'this._open'.\n    // The following LOC would suffice for newer versions of Node.js\n    // return this._webServer.listening;\n    return this._open;\n  }\n\n  /**\n   * Handle error thrown during processing of webhook request.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('webhook_error').length) {\n      return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('webhook_error', error);\n  }\n\n  /**\n   * Handle request body by passing it to 'callback'\n   * @private\n   */\n  _parseBody(error, body) {\n    if (error) {\n      return this._error(new errors.FatalError(error));\n    }\n\n    let data;\n    try {\n      data = JSON.parse(body.toString());\n    } catch (parseError) {\n      return this._error(new errors.ParseError(parseError.message));\n    }\n\n    return this.bot.processUpdate(data);\n  }\n\n  /**\n   * Listener for 'request' event on server\n   * @private\n   * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n   * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n   */\n  _requestListener(req, res) {\n    debug('WebHook request URL: %s', req.url);\n    debug('WebHook request headers: %j', req.headers);\n\n    if (req.url.indexOf(this.bot.token) !== -1) {\n      if (req.method !== 'POST') {\n        debug('WebHook request isn\\'t a POST');\n        res.statusCode = 418; // I'm a teabot!\n        res.end();\n      } else {\n        req\n          .pipe(bl(this._parseBody))\n          .on('finish', () => res.end('OK'));\n      }\n    } else if (this._healthRegex.test(req.url)) {\n      debug('WebHook health check passed');\n      res.statusCode = 200;\n      res.end('OK');\n    } else {\n      debug('WebHook request unauthorized');\n      res.statusCode = 401;\n      res.end();\n    }\n  }\n}\n\nmodule.exports = TelegramBotWebHook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy90ZWxlZ3JhbVdlYkhvb2suanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLDBFQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkYXJzaFxcT25lRHJpdmVcXERlc2t0b3BcXENvZGVcXE1FUk4gV2ViIERldlxcR3JhcGhpXFxub2RlX21vZHVsZXNcXG5vZGUtdGVsZWdyYW0tYm90LWFwaVxcc3JjXFx0ZWxlZ3JhbVdlYkhvb2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbm9kZS10ZWxlZ3JhbS1ib3QtYXBpJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgYmwgPSByZXF1aXJlKCdibCcpO1xuXG5jbGFzcyBUZWxlZ3JhbUJvdFdlYkhvb2sge1xuICAvKipcbiAgICogU2V0cyB1cCBhIHdlYmhvb2sgdG8gcmVjZWl2ZSB1cGRhdGVzXG4gICAqIEBwYXJhbSAge1RlbGVncmFtQm90fSBib3RcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2dldHRpbmctdXBkYXRlc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYm90KSB7XG4gICAgdGhpcy5ib3QgPSBib3Q7XG4gICAgdGhpcy5vcHRpb25zID0gKHR5cGVvZiBib3Qub3B0aW9ucy53ZWJIb29rID09PSAnYm9vbGVhbicpID8ge30gOiBib3Qub3B0aW9ucy53ZWJIb29rO1xuICAgIHRoaXMub3B0aW9ucy5ob3N0ID0gdGhpcy5vcHRpb25zLmhvc3QgfHwgJzAuMC4wLjAnO1xuICAgIHRoaXMub3B0aW9ucy5wb3J0ID0gdGhpcy5vcHRpb25zLnBvcnQgfHwgODQ0MztcbiAgICB0aGlzLm9wdGlvbnMuaHR0cHMgPSB0aGlzLm9wdGlvbnMuaHR0cHMgfHwge307XG4gICAgdGhpcy5vcHRpb25zLmhlYWx0aEVuZHBvaW50ID0gdGhpcy5vcHRpb25zLmhlYWx0aEVuZHBvaW50IHx8ICcvaGVhbHRoeic7XG4gICAgdGhpcy5faGVhbHRoUmVnZXggPSBuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5oZWFsdGhFbmRwb2ludCk7XG4gICAgdGhpcy5fd2ViU2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdExpc3RlbmVyID0gdGhpcy5fcmVxdWVzdExpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcGFyc2VCb2R5ID0gdGhpcy5fcGFyc2VCb2R5LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtleSAmJiB0aGlzLm9wdGlvbnMuY2VydCkge1xuICAgICAgZGVidWcoJ0hUVFBTIFdlYkhvb2sgZW5hYmxlZCAoYnkga2V5L2NlcnQpJyk7XG4gICAgICB0aGlzLm9wdGlvbnMuaHR0cHMua2V5ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMub3B0aW9ucy5rZXkpO1xuICAgICAgdGhpcy5vcHRpb25zLmh0dHBzLmNlcnQgPSBmcy5yZWFkRmlsZVN5bmModGhpcy5vcHRpb25zLmNlcnQpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHRoaXMub3B0aW9ucy5odHRwcywgdGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wZngpIHtcbiAgICAgIGRlYnVnKCdIVFRQUyBXZWJIb29rIGVuYWJsZWQgKGJ5IHBmeCknKTtcbiAgICAgIHRoaXMub3B0aW9ucy5odHRwcy5wZnggPSBmcy5yZWFkRmlsZVN5bmModGhpcy5vcHRpb25zLnBmeCk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwcy5jcmVhdGVTZXJ2ZXIodGhpcy5vcHRpb25zLmh0dHBzLCB0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmh0dHBzKS5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdIVFRQUyBXZWJIb29rIGVuYWJsZWQgYnkgKGh0dHBzKScpO1xuICAgICAgdGhpcy5fd2ViU2VydmVyID0gaHR0cHMuY3JlYXRlU2VydmVyKHRoaXMub3B0aW9ucy5odHRwcywgdGhpcy5fcmVxdWVzdExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0hUVFAgV2ViSG9vayBlbmFibGVkJyk7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcih0aGlzLl9yZXF1ZXN0TGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIFdlYkhvb2sgYnkgbGlzdGVuaW5nIG9uIHRoZSBwb3J0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl93ZWJTZXJ2ZXIubGlzdGVuKHRoaXMub3B0aW9ucy5wb3J0LCB0aGlzLm9wdGlvbnMuaG9zdCwgKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnV2ViSG9vayBsaXN0ZW5pbmcgb24gcG9ydCAlcycsIHRoaXMub3B0aW9ucy5wb3J0KTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fd2ViU2VydmVyLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSB3ZWJIb29rXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3dlYlNlcnZlci5jbG9zZShlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWYgc2VydmVyIGlzIGxpc3RlbmluZy4gT3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIC8vIE5PVEU6IFNpbmNlIGBodHRwLlNlcnZlci5saXN0ZW5pbmdgIHdhcyBhZGRlZCBpbiB2NS43LjBcbiAgICAvLyBhbmQgd2Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IE5vZGUgdjQsXG4gICAgLy8gd2UgYXJlIGdvaW5nIHRvIGZhbGxiYWNrIHRvICd0aGlzLl9vcGVuJy5cbiAgICAvLyBUaGUgZm9sbG93aW5nIExPQyB3b3VsZCBzdWZmaWNlIGZvciBuZXdlciB2ZXJzaW9ucyBvZiBOb2RlLmpzXG4gICAgLy8gcmV0dXJuIHRoaXMuX3dlYlNlcnZlci5saXN0ZW5pbmc7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGVycm9yIHRocm93biBkdXJpbmcgcHJvY2Vzc2luZyBvZiB3ZWJob29rIHJlcXVlc3QuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge0Vycm9yfSBlcnJvclxuICAgKi9cbiAgX2Vycm9yKGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLmJvdC5saXN0ZW5lcnMoJ3dlYmhvb2tfZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdlcnJvcjogW3dlYmhvb2tfZXJyb3JdICVqJywgZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYm90LmVtaXQoJ3dlYmhvb2tfZXJyb3InLCBlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHJlcXVlc3QgYm9keSBieSBwYXNzaW5nIGl0IHRvICdjYWxsYmFjaydcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJzZUJvZHkoZXJyb3IsIGJvZHkpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcihuZXcgZXJyb3JzLkZhdGFsRXJyb3IoZXJyb3IpKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYm9keS50b1N0cmluZygpKTtcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IobmV3IGVycm9ycy5QYXJzZUVycm9yKHBhcnNlRXJyb3IubWVzc2FnZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJvdC5wcm9jZXNzVXBkYXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbmVyIGZvciAncmVxdWVzdCcgZXZlbnQgb24gc2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9odHRwLmh0bWwjaHR0cF9odHRwX2NyZWF0ZXNlcnZlcl9yZXF1ZXN0bGlzdGVuZXJcbiAgICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2h0dHBzLmh0bWwjaHR0cHNfaHR0cHNfY3JlYXRlc2VydmVyX29wdGlvbnNfcmVxdWVzdGxpc3RlbmVyXG4gICAqL1xuICBfcmVxdWVzdExpc3RlbmVyKHJlcSwgcmVzKSB7XG4gICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCBVUkw6ICVzJywgcmVxLnVybCk7XG4gICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCBoZWFkZXJzOiAlaicsIHJlcS5oZWFkZXJzKTtcblxuICAgIGlmIChyZXEudXJsLmluZGV4T2YodGhpcy5ib3QudG9rZW4pICE9PSAtMSkge1xuICAgICAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgICBkZWJ1ZygnV2ViSG9vayByZXF1ZXN0IGlzblxcJ3QgYSBQT1NUJyk7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDE4OyAvLyBJJ20gYSB0ZWFib3QhXG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcVxuICAgICAgICAgIC5waXBlKGJsKHRoaXMuX3BhcnNlQm9keSkpXG4gICAgICAgICAgLm9uKCdmaW5pc2gnLCAoKSA9PiByZXMuZW5kKCdPSycpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2hlYWx0aFJlZ2V4LnRlc3QocmVxLnVybCkpIHtcbiAgICAgIGRlYnVnKCdXZWJIb29rIGhlYWx0aCBjaGVjayBwYXNzZWQnKTtcbiAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjAwO1xuICAgICAgcmVzLmVuZCgnT0snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ1dlYkhvb2sgcmVxdWVzdCB1bmF1dGhvcml6ZWQnKTtcbiAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDAxO1xuICAgICAgcmVzLmVuZCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlbGVncmFtQm90V2ViSG9vaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/telegramWebHook.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-telegram-bot-api/src/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-telegram-bot-api/src/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\");\n// Native deprecation warning\nexports.deprecate = (msg) => util.deprecate(() => { }, msg, 'node-telegram-bot-api')();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS10ZWxlZ3JhbS1ib3QtYXBpL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQSxpQkFBaUIsb0NBQW9DIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRhcnNoXFxPbmVEcml2ZVxcRGVza3RvcFxcQ29kZVxcTUVSTiBXZWIgRGV2XFxHcmFwaGlcXG5vZGVfbW9kdWxlc1xcbm9kZS10ZWxlZ3JhbS1ib3QtYXBpXFxzcmNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4vLyBOYXRpdmUgZGVwcmVjYXRpb24gd2FybmluZ1xuZXhwb3J0cy5kZXByZWNhdGUgPSAobXNnKSA9PiB1dGlsLmRlcHJlY2F0ZSgoKSA9PiB7IH0sIG1zZywgJ25vZGUtdGVsZWdyYW0tYm90LWFwaScpKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-telegram-bot-api/src/utils.js\n");

/***/ })

};
;